
(function() {
var __main_module_name__ = "main";
var __resources__ = {};
var __remote_resources__ = {};
function __imageResource(data) { var img = new Image(); img.src = data; return img; };
var FLIP_Y_AXIS = false;
var ENABLE_WEB_GL = false;
var SHOW_REDRAW_REGIONS = false;

__resources__["/__builtin__/event.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*global module exports require*/
/*jslint white: true, undef: true, nomen: true, bitwise: true, regexp: true, newcap: true*/


/**
 * @namespace
 * Support for listening for and triggering events
 */
var event = {};

/**
 * @private
 * @ignore
 * Returns the event listener property of an object, creating it if it doesn't
 * already exist.
 *
 * @returns {Object}
 */
function getListeners(obj, eventName) {
    if (!obj.js_listeners_) {
        obj.js_listeners_ = {};
    }
    if (!eventName) {
        return obj.js_listeners_;
    }
    if (!obj.js_listeners_[eventName]) {
        obj.js_listeners_[eventName] = {};
    }
    return obj.js_listeners_[eventName];
}

/**
 * @private
 * @ignore
 * Keep track of the next ID for each new EventListener
 */
var eventID = 0;

/**
 * @class
 * Represents an event being listened to. You should not create instances of
 * this directly, it is instead returned by event.addListener
 *
 * @extends Object
 * 
 * @param {Object} source Object to listen to for an event
 * @param {String} eventName Name of the event to listen for
 * @param {Function} handler Callback to fire when the event triggers
 */
event.EventListener = function (source, eventName, handler) {
    /**
     * Object to listen to for an event
     * @type Object 
     */
    this.source = source;
    
    /**
     * Name of the event to listen for
     * @type String
     */
    this.eventName = eventName;

    /**
     * Callback to fire when the event triggers
     * @type Function
     */
    this.handler = handler;

    /**
     * Unique ID number for this instance
     * @type Integer 
     */
    this.id = ++eventID;

    getListeners(source, eventName)[this.id] = this;
};

/**
 * Register an event listener
 *
 * @param {Object} source Object to listen to for an event
 * @param {String} eventName Name of the event to listen for
 * @param {Function} handler Callback to fire when the event triggers
 *
 * @returns {event.EventListener} The event listener. Pass to removeListener to destroy it.
 */
event.addListener = function (source, eventName, handler) {
    return new event.EventListener(source, eventName, handler);
};

/**
 * Trigger an event. All listeners will be notified.
 *
 * @param {Object} source Object to trigger the event on
 * @param {String} eventName Name of the event to trigger
 */
event.trigger = function (source, eventName) {
    var listeners = getListeners(source, eventName),
        args = Array.prototype.slice.call(arguments, 2),
        eventID,
        l;

    for (eventID in listeners) {
        if (listeners.hasOwnProperty(eventID)) {
            l = listeners[eventID];
            if (l) {
                l.handler.apply(undefined, args);
            }
        }
    }
};

/**
 * Remove a previously registered event listener
 *
 * @param {event.EventListener} listener EventListener to remove, as returned by event.addListener
 */
event.removeListener = function (listener) {
    delete getListeners(listener.source, listener.eventName)[listener.eventID];
};

/**
 * Remove a all event listeners for a given event
 *
 * @param {Object} source Object to remove listeners from
 * @param {String} eventName Name of event to remove listeners from
 */
event.clearListeners = function (source, eventName) {
    var listeners = getListeners(source, eventName),
        eventID;


    for (eventID in listeners) {
        if (listeners.hasOwnProperty(eventID)) {
            var l = listeners[eventID];
            if (l) {
                event.removeListener(l);
            }
        }
    }
};

/**
 * Remove all event listeners on an object
 *
 * @param {Object} source Object to remove listeners from
 */
event.clearInstanceListeners = function (source, eventName) {
    var listeners = getListeners(source),
        eventID;

    for (eventName in listeners) {
        if (listeners.hasOwnProperty(eventName)) {
            var el = listeners[eventName];
            for (eventID in el) {
                if (el.hasOwnProperty(eventID)) {
                    var l = el[eventID];
                    if (l) {
                        event.removeListener(l);
                    }
                }
            }
        }
    }
};

module.exports = event;

}};
__resources__["/__builtin__/events.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*global module exports require*/
/*jslint white: true, undef: true, nomen: true, bitwise: true, regexp: true, newcap: true*/

/**
 * @namespace
 * Support for listening for and triggering events
 */
var events = {};

/**
 * @private
 * @ignore
 * Returns the event listener property of an object, creating it if it doesn't
 * already exist.
 *
 * @returns {Object}
 */
function getListeners(obj, eventName) {
    if (!obj.js_listeners_) {
        obj.js_listeners_ = {};
    }
    if (!eventName) {
        return obj.js_listeners_;
    }
    if (!obj.js_listeners_[eventName]) {
        obj.js_listeners_[eventName] = {};
    }
    return obj.js_listeners_[eventName];
}

/**
 * @private
 * @ignore
 * Keep track of the next ID for each new EventListener
 */
var eventID = 0;

/**
 * @class
 * Represents an event being listened to. You should not create instances of
 * this directly, it is instead returned by events.addListener
 *
 * @extends Object
 * 
 * @param {Object} source Object to listen to for an event
 * @param {String} eventName Name of the event to listen for
 * @param {Function} handler Callback to fire when the event triggers
 */
events.EventListener = function (source, eventName, handler) {
    /**
     * Object to listen to for an event
     * @type Object 
     */
    this.source = source;
    
    /**
     * Name of the event to listen for
     * @type String
     */
    this.eventName = eventName;

    /**
     * Callback to fire when the event triggers
     * @type Function
     */
    this.handler = handler;

    /**
     * Unique ID number for this instance
     * @type Integer 
     */
    this.id = ++eventID;

    getListeners(source, eventName)[this.id] = this;
};

/**
 * Register an event listener
 *
 * @param {Object} source Object to listen to for an event
 * @param {String|Stringp[} eventName Name or Array of names of the event(s) to listen for
 * @param {Function} handler Callback to fire when the event triggers
 *
 * @returns {events.EventListener|events.EventListener[]} The event listener(s). Pass to removeListener to destroy it.
 */
events.addListener = function (source, eventName, handler) {
    if (eventName instanceof Array) {
        var listeners = [];
        for (var i = 0, len = eventName.length; i < len; i++) {
            listeners.push(new events.EventListener(source, eventName[i], handler));
        }
        return listeners;
    } else {
        return new events.EventListener(source, eventName, handler);
    }
};

/**
 * Trigger an event. All listeners will be notified.
 *
 * @param {Object} source Object to trigger the event on
 * @param {String} eventName Name of the event to trigger
 */
events.trigger = function (source, eventName) {
    var listeners = getListeners(source, eventName),
        args = Array.prototype.slice.call(arguments, 2),
        eventID,
        l;

    for (eventID in listeners) {
        if (listeners.hasOwnProperty(eventID)) {
            l = listeners[eventID];
            if (l) {
                l.handler.apply(undefined, args);
            }
        }
    }
};

/**
 * Remove a previously registered event listener
 *
 * @param {events.EventListener} listener EventListener to remove, as returned by events.addListener
 */
events.removeListener = function (listener) {
    delete getListeners(listener.source, listener.eventName)[listener.eventID];
};

/**
 * Remove a all event listeners for a given event
 *
 * @param {Object} source Object to remove listeners from
 * @param {String} eventName Name of event to remove listeners from
 */
events.clearListeners = function (source, eventName) {
    var listeners = getListeners(source, eventName),
        eventID;


    for (eventID in listeners) {
        if (listeners.hasOwnProperty(eventID)) {
            var l = listeners[eventID];
            if (l) {
                events.removeListener(l);
            }
        }
    }
};

/**
 * Remove all event listeners on an object
 *
 * @param {Object} source Object to remove listeners from
 */
events.clearInstanceListeners = function (source) {
    var listeners = getListeners(source),
        eventID;

    for (var eventName in listeners) {
        if (listeners.hasOwnProperty(eventName)) {
            var el = listeners[eventName];
            for (eventID in el) {
                if (el.hasOwnProperty(eventID)) {
                    var l = el[eventID];
                    if (l) {
                        events.removeListener(l);
                    }
                }
            }
        }
    }
};

module.exports = events;

}};
__resources__["/__builtin__/global.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    events = require('events');


/**
 * @ignore
 */
function getAccessors(obj) {
    if (!obj.js_accessors_) {
        obj.js_accessors_ = {};
    }
    return obj.js_accessors_;
}

/**
 * @ignore
 */
function getBindings(obj) {
    if (!obj.js_bindings_) {
        obj.js_bindings_ = {};
    }
    return obj.js_bindings_;
}

/**
 * @ignore
 */
function addAccessor(obj, key, target, targetKey, noNotify) {
    getAccessors(obj)[key] = {
        key: targetKey,
        target: target
    };

    if (!noNotify) {
        obj.triggerChanged(key);
    }
}


/**
 * @ignore
 */
var objectID = 0;

/**
 * @class
 * A bindable object. Allows observing and binding to its properties.
 */
var BObject = function () {};
BObject.prototype = util.extend(BObject.prototype, /** @lends BObject# */{
    /**
     * Unique ID
     * @type Integer
     */
    _id: 0,
    

    /**
     * The constructor for subclasses. Overwrite this for any initalisation you
     * need to do.
     * @ignore
     */
    init: function () {},

    /**
     * Get a property from the object. Always use this instead of trying to
     * access the property directly. This will ensure all bindings, setters and
     * getters work correctly.
     * 
     * @param {String} key Name of property to get or dot (.) separated path to a property
     * @returns {*} Value of the property
     */
    get: function (key) {
        var next = false
        if (~key.indexOf('.')) {
            var tokens = key.split('.');
            key = tokens.shift();
            next = tokens.join('.');
        }


        var accessor = getAccessors(this)[key],
            val;
        if (accessor) {
            val = accessor.target.get(accessor.key);
        } else {
            // Call getting function
            if (this['get_' + key]) {
                val = this['get_' + key]();
            } else {
                val = this[key];
            }
        }

        if (next) {
            return val.get(next);
        } else {
            return val;
        }
    },


    /**
     * Set a property on the object. Always use this instead of trying to
     * access the property directly. This will ensure all bindings, setters and
     * getters work correctly.
     * 
     * @param {String} key Name of property to get
     * @param {*} value New value for the property
     */
    set: function (key, value) {
        var accessor = getAccessors(this)[key],
            oldVal = this.get(key);


        this.triggerBeforeChanged(key, oldVal);

        if (accessor) {
            accessor.target.set(accessor.key, value);
        } else {

            if (this['set_' + key]) {
                this['set_' + key](value);
            } else {
                this[key] = value;
            }
        }
        this.triggerChanged(key, oldVal);
    },

    /**
     * Set multiple propertys in one go
     *
     * @param {Object} kvp An Object where the key is a property name and the value is the value to assign to the property
     *
     * @example
     * var props = {
     *   monkey: 'ook',
     *   cat: 'meow',
     *   dog: 'woof'
     * };
     * foo.setValues(props);
     * console.log(foo.get('cat')); // Logs 'meow'
     */
    setValues: function (kvp) {
        for (var x in kvp) {
            if (kvp.hasOwnProperty(x)) {
                this.set(x, kvp[x]);
            }
        }
    },

    changed: function (key) {
    },

    /**
     * @private
     */
    notify: function (key, oldVal) {
        var accessor = getAccessors(this)[key];
        if (accessor) {
            accessor.target.notify(accessor.key, oldVal);
        }
    },

    /**
     * @private
     */
    triggerBeforeChanged: function (key, oldVal) {
        events.trigger(this, key.toLowerCase() + '_before_changed', oldVal);
    },

    /**
     * @private
     */
    triggerChanged: function (key, oldVal) {
        events.trigger(this, key.toLowerCase() + '_changed', oldVal);
    },

    /**
     * Bind the value of a property on this object to that of another object so
     * they always have the same value. Setting the value on either object will update
     * the other too.
     *
     * @param {String} key Name of the property on this object that should be bound
     * @param {BOject} target Object to bind to
     * @param {String} [targetKey=key] Key on the target object to bind to
     * @param {Boolean} [noNotify=false] Set to true to prevent this object's property triggering a 'changed' event when adding the binding
     */
    bindTo: function (key, target, targetKey, noNotify) {
        targetKey = targetKey || key;
        var self = this;
        this.unbind(key);

        var oldVal = this.get(key);

        // When bound property changes, trigger a 'changed' event on this one too
        getBindings(this)[key] = events.addListener(target, targetKey.toLowerCase() + '_changed', function (oldVal) {
            self.triggerChanged(key, oldVal);
        });

        addAccessor(this, key, target, targetKey, noNotify);
    },

    /**
     * Remove binding from a property which set setup using BObject#bindTo.
     *
     * @param {String} key Name of the property on this object to unbind
     */
    unbind: function (key) {
        var binding = getBindings(this)[key];
        if (!binding) {
            return;
        }

        delete getBindings(this)[key];
        events.removeListener(binding);
        // Grab current value from bound property
        var val = this.get(key);
        delete getAccessors(this)[key];
        // Set bound value
        this[key] = val;
    },

    /**
     * Remove all bindings on this object
     */
    unbindAll: function () {
        var keys = [],
            bindings = getBindings(this);
        for (var k in bindings) {
            if (bindings.hasOwnProperty(k)) {
                this.unbind(k);
            }
        }
    },

    /**
     * Unique ID for this object
     * @getter id
     * @type Integer
     */
    get_id: function () {
        if (!this._id) {
            this._id = ++objectID;
        }

        return this._id;
    }
});


/**
 * Create a new instance of this object
 * @returns {BObject} New instance of this object
 */
BObject.create = function () {
    var ret = new this();
    ret.init.apply(ret, arguments);
    return ret;
};

/**
 * Create a new subclass by extending this one
 * @returns {Object} A new subclass of this object
 */
BObject.extend = function() {
    var newObj = function() {},
        args = [],
        i,
        x;

    // Copy 'class' methods
    for (x in this) {
        if (this.hasOwnProperty(x)) {
            newObj[x] = this[x];
        }
    }


    // Add given properties to the prototype
    newObj.prototype = util.beget(this.prototype);
    args.push(newObj.prototype);
    for (i = 0; i<arguments.length; i++) {
        args.push(arguments[i]);
    }
    util.extend.apply(null, args);

    newObj.superclass = this.prototype;
    // Create new instance
    return newObj;
};

/**
 * Get a property from the class. Always use this instead of trying to
 * access the property directly. This will ensure all bindings, setters and
 * getters work correctly.
 * 
 * @function
 * @param {String} key Name of property to get
 * @returns {*} Value of the property
 */
BObject.get = BObject.prototype.get;

/**
 * Set a property on the class. Always use this instead of trying to
 * access the property directly. This will ensure all bindings, setters and
 * getters work correctly.
 * 
 * @function
 * @param {String} key Name of property to get
 * @param {*} value New value for the property
 */
BObject.set = BObject.prototype.set;

var BArray = BObject.extend(/** @lends BArray# */{

    /**
     * @constructs 
     * A bindable array. Allows observing for changes made to its contents
     *
     * @extends BObject
     * @param {Array} [array=[]] A normal JS array to use for data
     */
    init: function (array) {
        this.array = array || [];
        this.set('length', this.array.length);
    },

    /**
     * Get an item
     *
     * @param {Integer} i Index to get item from
     * @returns {*} Value stored in the array at index 'i'
     */
    getAt: function (i) {
        return this.array[i];
    },

    /**
     * Set an item -- Overwrites any existing item at index
     *
     * @param {Integer} i Index to set item to
     * @param {*} value Value to assign to index
     */
    setAt: function (i, value) {
        var oldVal = this.array[i];
        this.array[i] = value;

        events.trigger(this, 'set_at', i, oldVal);
    },

    /**
     * Insert a new item into the array without overwriting anything
     *
     * @param {Integer} i Index to insert item at
     * @param {*} value Value to insert
     */
    insertAt: function (i, value) {
        this.array.splice(i, 0, value);
        this.set('length', this.array.length);
        events.trigger(this, 'insert_at', i);
    },

    /**
     * Remove item from the array and return it
     *
     * @param {Integer} i Index to remove
     * @returns {*} Value that was removed
     */
    removeAt: function (i) {
        var oldVal = this.array[i];
        this.array.splice(i, 1);
        this.set('length', this.array.length);
        events.trigger(this, 'remove_at', i, oldVal);

        return oldVal;
    },

    /**
     * Get the internal Javascript Array instance
     *
     * @returns {Array} Internal Javascript Array
     */
    getArray: function () {
        return this.array;
    },

    /**
     * Append a value to the end of the array and return its new length
     *
     * @param {*} value Value to append to the array
     * @returns {Integer} New length of the array
     */
    push: function (value) {
        this.insertAt(this.array.length, value);
        return this.array.length;
    },

    /**
     * Remove value from the end of the array and return it
     *
     * @returns {*} Value that was removed
     */
    pop: function () {
        return this.removeAt(this.array.length - 1);
    }
});

exports.BObject = BObject;
exports.BArray = BArray;

}};
__resources__["/__builtin__/libs/base64.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/**
 * Thin wrapper around JXG's Base64 utils
 */

/** @ignore */
var JXG = require('JXGUtil');

/** @namespace */
var base64 = {
    /**
     * Decode a base64 encoded string into a binary string
     *
     * @param {String} input Base64 encoded data
     * @returns {String} Binary string
     */
    decode: function(input) {
        return JXG.Util.Base64.decode(input);
    },

    /**
     * Decode a base64 encoded string into a byte array
     *
     * @param {String} input Base64 encoded data
     * @returns {Integer[]} Array of bytes
     */
    decodeAsArray: function(input, bytes) {
        bytes = bytes || 1;

        var dec = JXG.Util.Base64.decode(input),
            ar = [], i, j, len;

        for (i = 0, len = dec.length/bytes; i < len; i++){
            ar[i] = 0;
            for (j = bytes-1; j >= 0; --j){
                ar[i] += dec.charCodeAt((i *bytes) +j) << (j *8);
            }
        }
        return ar;
    },

    /**
     * Encode a binary string into base64
     *
     * @param {String} input Binary string
     * @returns {String} Base64 encoded data
     */
    encode: function(input) {
        return JXG.Util.Base64.encode(input);
    }
};

module.exports = base64;

}};
__resources__["/__builtin__/libs/box2d.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
function extend(a, b) {
  for(var c in b) {
    a[c] = b[c]
  }
}
function isInstanceOf(obj, _constructor) {
  while(typeof obj === "object") {
    if(obj.constructor === _constructor) {
      return true
    }
    obj = obj._super
  }
  return false
}
;var b2BoundValues = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2BoundValues.prototype.__constructor = function() {
  this.lowerValues = new Array;
  this.lowerValues[0] = 0;
  this.lowerValues[1] = 0;
  this.upperValues = new Array;
  this.upperValues[0] = 0;
  this.upperValues[1] = 0
};
b2BoundValues.prototype.__varz = function() {
};
b2BoundValues.prototype.lowerValues = null;
b2BoundValues.prototype.upperValues = null;var b2PairManager = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2PairManager.prototype.__constructor = function() {
  this.m_pairs = new Array;
  this.m_pairBuffer = new Array;
  this.m_pairCount = 0;
  this.m_pairBufferCount = 0;
  this.m_freePair = null
};
b2PairManager.prototype.__varz = function() {
};
b2PairManager.prototype.AddPair = function(proxy1, proxy2) {
  var pair = proxy1.pairs[proxy2];
  if(pair != null) {
    return pair
  }
  if(this.m_freePair == null) {
    this.m_freePair = new b2Pair;
    this.m_pairs.push(this.m_freePair)
  }
  pair = this.m_freePair;
  this.m_freePair = pair.next;
  pair.proxy1 = proxy1;
  pair.proxy2 = proxy2;
  pair.status = 0;
  pair.userData = null;
  pair.next = null;
  proxy1.pairs[proxy2] = pair;
  proxy2.pairs[proxy1] = pair;
  ++this.m_pairCount;
  return pair
};
b2PairManager.prototype.RemovePair = function(proxy1, proxy2) {
  var pair = proxy1.pairs[proxy2];
  if(pair == null) {
    return null
  }
  var userData = pair.userData;
  delete proxy1.pairs[proxy2];
  delete proxy2.pairs[proxy1];
  pair.next = this.m_freePair;
  pair.proxy1 = null;
  pair.proxy2 = null;
  pair.userData = null;
  pair.status = 0;
  this.m_freePair = pair;
  --this.m_pairCount;
  return userData
};
b2PairManager.prototype.Find = function(proxy1, proxy2) {
  return proxy1.pairs[proxy2]
};
b2PairManager.prototype.ValidateBuffer = function() {
};
b2PairManager.prototype.ValidateTable = function() {
};
b2PairManager.prototype.Initialize = function(broadPhase) {
  this.m_broadPhase = broadPhase
};
b2PairManager.prototype.AddBufferedPair = function(proxy1, proxy2) {
  var pair = this.AddPair(proxy1, proxy2);
  if(pair.IsBuffered() == false) {
    pair.SetBuffered();
    this.m_pairBuffer[this.m_pairBufferCount] = pair;
    ++this.m_pairBufferCount
  }
  pair.ClearRemoved();
  if(b2BroadPhase.s_validate) {
    this.ValidateBuffer()
  }
};
b2PairManager.prototype.RemoveBufferedPair = function(proxy1, proxy2) {
  var pair = this.Find(proxy1, proxy2);
  if(pair == null) {
    return
  }
  if(pair.IsBuffered() == false) {
    pair.SetBuffered();
    this.m_pairBuffer[this.m_pairBufferCount] = pair;
    ++this.m_pairBufferCount
  }
  pair.SetRemoved();
  if(b2BroadPhase.s_validate) {
    this.ValidateBuffer()
  }
};
b2PairManager.prototype.Commit = function(callback) {
  var i = 0;
  var removeCount = 0;
  for(i = 0;i < this.m_pairBufferCount;++i) {
    var pair = this.m_pairBuffer[i];
    pair.ClearBuffered();
    var proxy1 = pair.proxy1;
    var proxy2 = pair.proxy2;
    if(pair.IsRemoved()) {
    }else {
      if(pair.IsFinal() == false) {
        callback(proxy1.userData, proxy2.userData)
      }
    }
  }
  this.m_pairBufferCount = 0;
  if(b2BroadPhase.s_validate) {
    this.ValidateTable()
  }
};
b2PairManager.prototype.m_broadPhase = null;
b2PairManager.prototype.m_pairs = null;
b2PairManager.prototype.m_freePair = null;
b2PairManager.prototype.m_pairCount = 0;
b2PairManager.prototype.m_pairBuffer = null;
b2PairManager.prototype.m_pairBufferCount = 0;var b2TimeStep = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2TimeStep.prototype.__constructor = function() {
};
b2TimeStep.prototype.__varz = function() {
};
b2TimeStep.prototype.Set = function(step) {
  this.dt = step.dt;
  this.inv_dt = step.inv_dt;
  this.positionIterations = step.positionIterations;
  this.velocityIterations = step.velocityIterations;
  this.warmStarting = step.warmStarting
};
b2TimeStep.prototype.dt = null;
b2TimeStep.prototype.inv_dt = null;
b2TimeStep.prototype.dtRatio = null;
b2TimeStep.prototype.velocityIterations = 0;
b2TimeStep.prototype.positionIterations = 0;
b2TimeStep.prototype.warmStarting = null;var b2Controller = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Controller.prototype.__constructor = function() {
};
b2Controller.prototype.__varz = function() {
};
b2Controller.prototype.Step = function(step) {
};
b2Controller.prototype.Draw = function(debugDraw) {
};
b2Controller.prototype.AddBody = function(body) {
  var edge = new b2ControllerEdge;
  edge.controller = this;
  edge.body = body;
  edge.nextBody = m_bodyList;
  edge.prevBody = null;
  m_bodyList = edge;
  if(edge.nextBody) {
    edge.nextBody.prevBody = edge
  }
  m_bodyCount++;
  edge.nextController = body.m_controllerList;
  edge.prevController = null;
  body.m_controllerList = edge;
  if(edge.nextController) {
    edge.nextController.prevController = edge
  }
  body.m_controllerCount++
};
b2Controller.prototype.RemoveBody = function(body) {
  var edge = body.m_controllerList;
  while(edge && edge.controller != this) {
    edge = edge.nextController
  }
  if(edge.prevBody) {
    edge.prevBody.nextBody = edge.nextBody
  }
  if(edge.nextBody) {
    edge.nextBody.prevBody = edge.prevBody
  }
  if(edge.nextController) {
    edge.nextController.prevController = edge.prevController
  }
  if(edge.prevController) {
    edge.prevController.nextController = edge.nextController
  }
  if(m_bodyList == edge) {
    m_bodyList = edge.nextBody
  }
  if(body.m_controllerList == edge) {
    body.m_controllerList = edge.nextController
  }
  body.m_controllerCount--;
  m_bodyCount--
};
b2Controller.prototype.Clear = function() {
  while(m_bodyList) {
    this.RemoveBody(m_bodyList.body)
  }
};
b2Controller.prototype.GetNext = function() {
  return this.m_next
};
b2Controller.prototype.GetWorld = function() {
  return this.m_world
};
b2Controller.prototype.GetBodyList = function() {
  return m_bodyList
};
b2Controller.prototype.m_next = null;
b2Controller.prototype.m_prev = null;
b2Controller.prototype.m_world = null;var b2GravityController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2GravityController.prototype, b2Controller.prototype);
b2GravityController.prototype._super = b2Controller.prototype;
b2GravityController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2GravityController.prototype.__varz = function() {
};
b2GravityController.prototype.Step = function(step) {
  var i = null;
  var body1 = null;
  var p1 = null;
  var mass1 = 0;
  var j = null;
  var body2 = null;
  var p2 = null;
  var dx = 0;
  var dy = 0;
  var r2 = 0;
  var f = null;
  if(this.invSqr) {
    for(i = m_bodyList;i;i = i.nextBody) {
      body1 = i.body;
      p1 = body1.GetWorldCenter();
      mass1 = body1.GetMass();
      for(j = m_bodyList;j != i;j = j.nextBody) {
        body2 = j.body;
        p2 = body2.GetWorldCenter();
        dx = p2.x - p1.x;
        dy = p2.y - p1.y;
        r2 = dx * dx + dy * dy;
        if(r2 < Number.MIN_VALUE) {
          continue
        }
        f = new b2Vec2(dx, dy);
        f.Multiply(this.G / r2 / Math.sqrt(r2) * mass1 * body2.GetMass());
        if(body1.IsAwake()) {
          body1.ApplyForce(f, p1)
        }
        f.Multiply(-1);
        if(body2.IsAwake()) {
          body2.ApplyForce(f, p2)
        }
      }
    }
  }else {
    for(i = m_bodyList;i;i = i.nextBody) {
      body1 = i.body;
      p1 = body1.GetWorldCenter();
      mass1 = body1.GetMass();
      for(j = m_bodyList;j != i;j = j.nextBody) {
        body2 = j.body;
        p2 = body2.GetWorldCenter();
        dx = p2.x - p1.x;
        dy = p2.y - p1.y;
        r2 = dx * dx + dy * dy;
        if(r2 < Number.MIN_VALUE) {
          continue
        }
        f = new b2Vec2(dx, dy);
        f.Multiply(this.G / r2 * mass1 * body2.GetMass());
        if(body1.IsAwake()) {
          body1.ApplyForce(f, p1)
        }
        f.Multiply(-1);
        if(body2.IsAwake()) {
          body2.ApplyForce(f, p2)
        }
      }
    }
  }
};
b2GravityController.prototype.G = 1;
b2GravityController.prototype.invSqr = true;var b2DestructionListener = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DestructionListener.prototype.__constructor = function() {
};
b2DestructionListener.prototype.__varz = function() {
};
b2DestructionListener.prototype.SayGoodbyeJoint = function(joint) {
};
b2DestructionListener.prototype.SayGoodbyeFixture = function(fixture) {
};var b2ContactEdge = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactEdge.prototype.__constructor = function() {
};
b2ContactEdge.prototype.__varz = function() {
};
b2ContactEdge.prototype.other = null;
b2ContactEdge.prototype.contact = null;
b2ContactEdge.prototype.prev = null;
b2ContactEdge.prototype.next = null;var b2EdgeChainDef = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2EdgeChainDef.prototype.__constructor = function() {
  this.vertexCount = 0;
  this.isALoop = true;
  this.vertices = []
};
b2EdgeChainDef.prototype.__varz = function() {
};
b2EdgeChainDef.prototype.vertices = null;
b2EdgeChainDef.prototype.vertexCount = null;
b2EdgeChainDef.prototype.isALoop = null;var b2Vec2 = function(x_, y_) {
  if(arguments.length == 2) {
    this.x = x_;
    this.y = y_
  }
};
b2Vec2.Make = function(x_, y_) {
  return new b2Vec2(x_, y_)
};
b2Vec2.prototype.SetZero = function() {
  this.x = 0;
  this.y = 0
};
b2Vec2.prototype.Set = function(x_, y_) {
  this.x = x_;
  this.y = y_
};
b2Vec2.prototype.SetV = function(v) {
  this.x = v.x;
  this.y = v.y
};
b2Vec2.prototype.GetNegative = function() {
  return new b2Vec2(-this.x, -this.y)
};
b2Vec2.prototype.NegativeSelf = function() {
  this.x = -this.x;
  this.y = -this.y
};
b2Vec2.prototype.Copy = function() {
  return new b2Vec2(this.x, this.y)
};
b2Vec2.prototype.Add = function(v) {
  this.x += v.x;
  this.y += v.y
};
b2Vec2.prototype.Subtract = function(v) {
  this.x -= v.x;
  this.y -= v.y
};
b2Vec2.prototype.Multiply = function(a) {
  this.x *= a;
  this.y *= a
};
b2Vec2.prototype.MulM = function(A) {
  var tX = this.x;
  this.x = A.col1.x * tX + A.col2.x * this.y;
  this.y = A.col1.y * tX + A.col2.y * this.y
};
b2Vec2.prototype.MulTM = function(A) {
  var tX = b2Math.Dot(this, A.col1);
  this.y = b2Math.Dot(this, A.col2);
  this.x = tX
};
b2Vec2.prototype.CrossVF = function(s) {
  var tX = this.x;
  this.x = s * this.y;
  this.y = -s * tX
};
b2Vec2.prototype.CrossFV = function(s) {
  var tX = this.x;
  this.x = -s * this.y;
  this.y = s * tX
};
b2Vec2.prototype.MinV = function(b) {
  this.x = this.x < b.x ? this.x : b.x;
  this.y = this.y < b.y ? this.y : b.y
};
b2Vec2.prototype.MaxV = function(b) {
  this.x = this.x > b.x ? this.x : b.x;
  this.y = this.y > b.y ? this.y : b.y
};
b2Vec2.prototype.Abs = function() {
  if(this.x < 0) {
    this.x = -this.x
  }
  if(this.y < 0) {
    this.y = -this.y
  }
};
b2Vec2.prototype.Length = function() {
  return Math.sqrt(this.x * this.x + this.y * this.y)
};
b2Vec2.prototype.LengthSquared = function() {
  return this.x * this.x + this.y * this.y
};
b2Vec2.prototype.Normalize = function() {
  var length = Math.sqrt(this.x * this.x + this.y * this.y);
  if(length < Number.MIN_VALUE) {
    return 0
  }
  var invLength = 1 / length;
  this.x *= invLength;
  this.y *= invLength;
  return length
};
b2Vec2.prototype.IsValid = function() {
  return b2Math.IsValid(this.x) && b2Math.IsValid(this.y)
};
b2Vec2.prototype.x = 0;
b2Vec2.prototype.y = 0;var b2Vec3 = function(x, y, z) {
  if(arguments.length == 3) {
    this.x = x;
    this.y = y;
    this.z = z
  }
};
b2Vec3.prototype.SetZero = function() {
  this.x = this.y = this.z = 0
};
b2Vec3.prototype.Set = function(x, y, z) {
  this.x = x;
  this.y = y;
  this.z = z
};
b2Vec3.prototype.SetV = function(v) {
  this.x = v.x;
  this.y = v.y;
  this.z = v.z
};
b2Vec3.prototype.GetNegative = function() {
  return new b2Vec3(-this.x, -this.y, -this.z)
};
b2Vec3.prototype.NegativeSelf = function() {
  this.x = -this.x;
  this.y = -this.y;
  this.z = -this.z
};
b2Vec3.prototype.Copy = function() {
  return new b2Vec3(this.x, this.y, this.z)
};
b2Vec3.prototype.Add = function(v) {
  this.x += v.x;
  this.y += v.y;
  this.z += v.z
};
b2Vec3.prototype.Subtract = function(v) {
  this.x -= v.x;
  this.y -= v.y;
  this.z -= v.z
};
b2Vec3.prototype.Multiply = function(a) {
  this.x *= a;
  this.y *= a;
  this.z *= a
};
b2Vec3.prototype.x = 0;
b2Vec3.prototype.y = 0;
b2Vec3.prototype.z = 0;var b2DistanceProxy = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DistanceProxy.prototype.__constructor = function() {
};
b2DistanceProxy.prototype.__varz = function() {
};
b2DistanceProxy.prototype.Set = function(shape) {
  switch(shape.GetType()) {
    case b2Shape.e_circleShape:
      var circle = shape;
      this.m_vertices = new Array(1);
      this.m_vertices[0] = circle.m_p;
      this.m_count = 1;
      this.m_radius = circle.m_radius;
      break;
    case b2Shape.e_polygonShape:
      var polygon = shape;
      this.m_vertices = polygon.m_vertices;
      this.m_count = polygon.m_vertexCount;
      this.m_radius = polygon.m_radius;
      break;
    default:
      b2Settings.b2Assert(false)
  }
};
b2DistanceProxy.prototype.GetSupport = function(d) {
  var bestIndex = 0;
  var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for(var i = 1;i < this.m_count;++i) {
    var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if(value > bestValue) {
      bestIndex = i;
      bestValue = value
    }
  }
  return bestIndex
};
b2DistanceProxy.prototype.GetSupportVertex = function(d) {
  var bestIndex = 0;
  var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for(var i = 1;i < this.m_count;++i) {
    var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if(value > bestValue) {
      bestIndex = i;
      bestValue = value
    }
  }
  return this.m_vertices[bestIndex]
};
b2DistanceProxy.prototype.GetVertexCount = function() {
  return this.m_count
};
b2DistanceProxy.prototype.GetVertex = function(index) {
  b2Settings.b2Assert(0 <= index && index < this.m_count);
  return this.m_vertices[index]
};
b2DistanceProxy.prototype.m_vertices = null;
b2DistanceProxy.prototype.m_count = 0;
b2DistanceProxy.prototype.m_radius = null;var b2ContactFactory = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactFactory.prototype.__constructor = function() {
};
b2ContactFactory.prototype.__varz = function() {
  this.InitializeRegisters()
};
b2ContactFactory.prototype.AddType = function(createFcn, destroyFcn, type1, type2) {
  this.m_registers[type1][type2].createFcn = createFcn;
  this.m_registers[type1][type2].destroyFcn = destroyFcn;
  this.m_registers[type1][type2].primary = true;
  if(type1 != type2) {
    this.m_registers[type2][type1].createFcn = createFcn;
    this.m_registers[type2][type1].destroyFcn = destroyFcn;
    this.m_registers[type2][type1].primary = false
  }
};
b2ContactFactory.prototype.InitializeRegisters = function() {
  this.m_registers = new Array(b2Shape.e_shapeTypeCount);
  for(var i = 0;i < b2Shape.e_shapeTypeCount;i++) {
    this.m_registers[i] = new Array(b2Shape.e_shapeTypeCount);
    for(var j = 0;j < b2Shape.e_shapeTypeCount;j++) {
      this.m_registers[i][j] = new b2ContactRegister
    }
  }
  this.AddType(b2CircleContact.Create, b2CircleContact.Destroy, b2Shape.e_circleShape, b2Shape.e_circleShape);
  this.AddType(b2PolyAndCircleContact.Create, b2PolyAndCircleContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_circleShape);
  this.AddType(b2PolygonContact.Create, b2PolygonContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_polygonShape);
  this.AddType(b2EdgeAndCircleContact.Create, b2EdgeAndCircleContact.Destroy, b2Shape.e_edgeShape, b2Shape.e_circleShape);
  this.AddType(b2PolyAndEdgeContact.Create, b2PolyAndEdgeContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_edgeShape)
};
b2ContactFactory.prototype.Create = function(fixtureA, fixtureB) {
  var type1 = fixtureA.GetType();
  var type2 = fixtureB.GetType();
  var reg = this.m_registers[type1][type2];
  var c;
  if(reg.pool) {
    c = reg.pool;
    reg.pool = c.m_next;
    reg.poolCount--;
    c.Reset(fixtureA, fixtureB);
    return c
  }
  var createFcn = reg.createFcn;
  if(createFcn != null) {
    if(reg.primary) {
      c = createFcn(this.m_allocator);
      c.Reset(fixtureA, fixtureB);
      return c
    }else {
      c = createFcn(this.m_allocator);
      c.Reset(fixtureB, fixtureA);
      return c
    }
  }else {
    return null
  }
};
b2ContactFactory.prototype.Destroy = function(contact) {
  if(contact.m_manifold.m_pointCount > 0) {
    contact.m_fixtureA.m_body.SetAwake(true);
    contact.m_fixtureB.m_body.SetAwake(true)
  }
  var type1 = contact.m_fixtureA.GetType();
  var type2 = contact.m_fixtureB.GetType();
  var reg = this.m_registers[type1][type2];
  if(true) {
    reg.poolCount++;
    contact.m_next = reg.pool;
    reg.pool = contact
  }
  var destroyFcn = reg.destroyFcn;
  destroyFcn(contact, this.m_allocator)
};
b2ContactFactory.prototype.m_registers = null;
b2ContactFactory.prototype.m_allocator = null;var b2ConstantAccelController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2ConstantAccelController.prototype, b2Controller.prototype);
b2ConstantAccelController.prototype._super = b2Controller.prototype;
b2ConstantAccelController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2ConstantAccelController.prototype.__varz = function() {
  this.A = new b2Vec2(0, 0)
};
b2ConstantAccelController.prototype.Step = function(step) {
  var smallA = new b2Vec2(this.A.x * step.dt, this.A.y * step.dt);
  for(var i = m_bodyList;i;i = i.nextBody) {
    var body = i.body;
    if(!body.IsAwake()) {
      continue
    }
    body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + smallA.x, body.GetLinearVelocity().y + smallA.y))
  }
};
b2ConstantAccelController.prototype.A = new b2Vec2(0, 0);var b2SeparationFunction = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2SeparationFunction.prototype.__constructor = function() {
};
b2SeparationFunction.prototype.__varz = function() {
  this.m_localPoint = new b2Vec2;
  this.m_axis = new b2Vec2
};
b2SeparationFunction.e_points = 1;
b2SeparationFunction.e_faceA = 2;
b2SeparationFunction.e_faceB = 4;
b2SeparationFunction.prototype.Initialize = function(cache, proxyA, transformA, proxyB, transformB) {
  this.m_proxyA = proxyA;
  this.m_proxyB = proxyB;
  var count = cache.count;
  b2Settings.b2Assert(0 < count && count < 3);
  var localPointA;
  var localPointA1;
  var localPointA2;
  var localPointB;
  var localPointB1;
  var localPointB2;
  var pointAX;
  var pointAY;
  var pointBX;
  var pointBY;
  var normalX;
  var normalY;
  var tMat;
  var tVec;
  var s;
  var sgn;
  if(count == 1) {
    this.m_type = b2SeparationFunction.e_points;
    localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
    localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
    tVec = localPointA;
    tMat = transformA.R;
    pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    tVec = localPointB;
    tMat = transformB.R;
    pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    this.m_axis.x = pointBX - pointAX;
    this.m_axis.y = pointBY - pointAY;
    this.m_axis.Normalize()
  }else {
    if(cache.indexB[0] == cache.indexB[1]) {
      this.m_type = b2SeparationFunction.e_faceA;
      localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
      localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
      localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
      this.m_localPoint.x = 0.5 * (localPointA1.x + localPointA2.x);
      this.m_localPoint.y = 0.5 * (localPointA1.y + localPointA2.y);
      this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1);
      this.m_axis.Normalize();
      tVec = this.m_axis;
      tMat = transformA.R;
      normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tVec = this.m_localPoint;
      tMat = transformA.R;
      pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tVec = localPointB;
      tMat = transformB.R;
      pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      s = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
      if(s < 0) {
        this.m_axis.NegativeSelf()
      }
    }else {
      if(cache.indexA[0] == cache.indexA[0]) {
        this.m_type = b2SeparationFunction.e_faceB;
        localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
        localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
        localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
        this.m_localPoint.x = 0.5 * (localPointB1.x + localPointB2.x);
        this.m_localPoint.y = 0.5 * (localPointB1.y + localPointB2.y);
        this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1);
        this.m_axis.Normalize();
        tVec = this.m_axis;
        tMat = transformB.R;
        normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
        normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
        tVec = this.m_localPoint;
        tMat = transformB.R;
        pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tVec = localPointA;
        tMat = transformA.R;
        pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        s = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
        if(s < 0) {
          this.m_axis.NegativeSelf()
        }
      }else {
        localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
        localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
        localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
        localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
        var pA = b2Math.MulX(transformA, localPointA);
        var dA = b2Math.MulMV(transformA.R, b2Math.SubtractVV(localPointA2, localPointA1));
        var pB = b2Math.MulX(transformB, localPointB);
        var dB = b2Math.MulMV(transformB.R, b2Math.SubtractVV(localPointB2, localPointB1));
        var a = dA.x * dA.x + dA.y * dA.y;
        var e = dB.x * dB.x + dB.y * dB.y;
        var r = b2Math.SubtractVV(dB, dA);
        var c = dA.x * r.x + dA.y * r.y;
        var f = dB.x * r.x + dB.y * r.y;
        var b = dA.x * dB.x + dA.y * dB.y;
        var denom = a * e - b * b;
        s = 0;
        if(denom != 0) {
          s = b2Math.Clamp((b * f - c * e) / denom, 0, 1)
        }
        var t = (b * s + f) / e;
        if(t < 0) {
          t = 0;
          s = b2Math.Clamp((b - c) / a, 0, 1)
        }
        localPointA = new b2Vec2;
        localPointA.x = localPointA1.x + s * (localPointA2.x - localPointA1.x);
        localPointA.y = localPointA1.y + s * (localPointA2.y - localPointA1.y);
        localPointB = new b2Vec2;
        localPointB.x = localPointB1.x + s * (localPointB2.x - localPointB1.x);
        localPointB.y = localPointB1.y + s * (localPointB2.y - localPointB1.y);
        if(s == 0 || s == 1) {
          this.m_type = b2SeparationFunction.e_faceB;
          this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1);
          this.m_axis.Normalize();
          this.m_localPoint = localPointB;
          tVec = this.m_axis;
          tMat = transformB.R;
          normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
          normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
          tVec = this.m_localPoint;
          tMat = transformB.R;
          pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          tVec = localPointA;
          tMat = transformA.R;
          pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          sgn = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
          if(s < 0) {
            this.m_axis.NegativeSelf()
          }
        }else {
          this.m_type = b2SeparationFunction.e_faceA;
          this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1);
          this.m_localPoint = localPointA;
          tVec = this.m_axis;
          tMat = transformA.R;
          normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
          normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
          tVec = this.m_localPoint;
          tMat = transformA.R;
          pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          tVec = localPointB;
          tMat = transformB.R;
          pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          sgn = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
          if(s < 0) {
            this.m_axis.NegativeSelf()
          }
        }
      }
    }
  }
};
b2SeparationFunction.prototype.Evaluate = function(transformA, transformB) {
  var axisA;
  var axisB;
  var localPointA;
  var localPointB;
  var pointA;
  var pointB;
  var seperation;
  var normal;
  switch(this.m_type) {
    case b2SeparationFunction.e_points:
      axisA = b2Math.MulTMV(transformA.R, this.m_axis);
      axisB = b2Math.MulTMV(transformB.R, this.m_axis.GetNegative());
      localPointA = this.m_proxyA.GetSupportVertex(axisA);
      localPointB = this.m_proxyB.GetSupportVertex(axisB);
      pointA = b2Math.MulX(transformA, localPointA);
      pointB = b2Math.MulX(transformB, localPointB);
      seperation = (pointB.x - pointA.x) * this.m_axis.x + (pointB.y - pointA.y) * this.m_axis.y;
      return seperation;
    case b2SeparationFunction.e_faceA:
      normal = b2Math.MulMV(transformA.R, this.m_axis);
      pointA = b2Math.MulX(transformA, this.m_localPoint);
      axisB = b2Math.MulTMV(transformB.R, normal.GetNegative());
      localPointB = this.m_proxyB.GetSupportVertex(axisB);
      pointB = b2Math.MulX(transformB, localPointB);
      seperation = (pointB.x - pointA.x) * normal.x + (pointB.y - pointA.y) * normal.y;
      return seperation;
    case b2SeparationFunction.e_faceB:
      normal = b2Math.MulMV(transformB.R, this.m_axis);
      pointB = b2Math.MulX(transformB, this.m_localPoint);
      axisA = b2Math.MulTMV(transformA.R, normal.GetNegative());
      localPointA = this.m_proxyA.GetSupportVertex(axisA);
      pointA = b2Math.MulX(transformA, localPointA);
      seperation = (pointA.x - pointB.x) * normal.x + (pointA.y - pointB.y) * normal.y;
      return seperation;
    default:
      b2Settings.b2Assert(false);
      return 0
  }
};
b2SeparationFunction.prototype.m_proxyA = null;
b2SeparationFunction.prototype.m_proxyB = null;
b2SeparationFunction.prototype.m_type = 0;
b2SeparationFunction.prototype.m_localPoint = new b2Vec2;
b2SeparationFunction.prototype.m_axis = new b2Vec2;var b2DynamicTreePair = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DynamicTreePair.prototype.__constructor = function() {
};
b2DynamicTreePair.prototype.__varz = function() {
};
b2DynamicTreePair.prototype.proxyA = null;
b2DynamicTreePair.prototype.proxyB = null;var b2ContactConstraintPoint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactConstraintPoint.prototype.__constructor = function() {
};
b2ContactConstraintPoint.prototype.__varz = function() {
  this.localPoint = new b2Vec2;
  this.rA = new b2Vec2;
  this.rB = new b2Vec2
};
b2ContactConstraintPoint.prototype.localPoint = new b2Vec2;
b2ContactConstraintPoint.prototype.rA = new b2Vec2;
b2ContactConstraintPoint.prototype.rB = new b2Vec2;
b2ContactConstraintPoint.prototype.normalImpulse = null;
b2ContactConstraintPoint.prototype.tangentImpulse = null;
b2ContactConstraintPoint.prototype.normalMass = null;
b2ContactConstraintPoint.prototype.tangentMass = null;
b2ContactConstraintPoint.prototype.equalizedMass = null;
b2ContactConstraintPoint.prototype.velocityBias = null;var b2ControllerEdge = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ControllerEdge.prototype.__constructor = function() {
};
b2ControllerEdge.prototype.__varz = function() {
};
b2ControllerEdge.prototype.controller = null;
b2ControllerEdge.prototype.body = null;
b2ControllerEdge.prototype.prevBody = null;
b2ControllerEdge.prototype.nextBody = null;
b2ControllerEdge.prototype.prevController = null;
b2ControllerEdge.prototype.nextController = null;var b2DistanceInput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DistanceInput.prototype.__constructor = function() {
};
b2DistanceInput.prototype.__varz = function() {
};
b2DistanceInput.prototype.proxyA = null;
b2DistanceInput.prototype.proxyB = null;
b2DistanceInput.prototype.transformA = null;
b2DistanceInput.prototype.transformB = null;
b2DistanceInput.prototype.useRadii = null;var b2Settings = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Settings.prototype.__constructor = function() {
};
b2Settings.prototype.__varz = function() {
};
b2Settings.b2MixFriction = function(friction1, friction2) {
  return Math.sqrt(friction1 * friction2)
};
b2Settings.b2MixRestitution = function(restitution1, restitution2) {
  return restitution1 > restitution2 ? restitution1 : restitution2
};
b2Settings.b2Assert = function(a) {
  if(!a) {
    throw"Assertion Failed";
  }
};
b2Settings.VERSION = "2.1alpha";
b2Settings.USHRT_MAX = 65535;
b2Settings.b2_pi = Math.PI;
b2Settings.b2_maxManifoldPoints = 2;
b2Settings.b2_aabbExtension = 0.1;
b2Settings.b2_aabbMultiplier = 2;
b2Settings.b2_polygonRadius = 2 * b2Settings.b2_linearSlop;
b2Settings.b2_linearSlop = 0.0050;
b2Settings.b2_angularSlop = 2 / 180 * b2Settings.b2_pi;
b2Settings.b2_toiSlop = 8 * b2Settings.b2_linearSlop;
b2Settings.b2_maxTOIContactsPerIsland = 32;
b2Settings.b2_maxTOIJointsPerIsland = 32;
b2Settings.b2_velocityThreshold = 1;
b2Settings.b2_maxLinearCorrection = 0.2;
b2Settings.b2_maxAngularCorrection = 8 / 180 * b2Settings.b2_pi;
b2Settings.b2_maxTranslation = 2;
b2Settings.b2_maxTranslationSquared = b2Settings.b2_maxTranslation * b2Settings.b2_maxTranslation;
b2Settings.b2_maxRotation = 0.5 * b2Settings.b2_pi;
b2Settings.b2_maxRotationSquared = b2Settings.b2_maxRotation * b2Settings.b2_maxRotation;
b2Settings.b2_contactBaumgarte = 0.2;
b2Settings.b2_timeToSleep = 0.5;
b2Settings.b2_linearSleepTolerance = 0.01;
b2Settings.b2_angularSleepTolerance = 2 / 180 * b2Settings.b2_pi;var b2Proxy = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Proxy.prototype.__constructor = function() {
};
b2Proxy.prototype.__varz = function() {
  this.lowerBounds = new Array(2);
  this.upperBounds = new Array(2);
  this.pairs = new Object
};
b2Proxy.prototype.IsValid = function() {
  return this.overlapCount != b2BroadPhase.b2_invalid
};
b2Proxy.prototype.lowerBounds = new Array(2);
b2Proxy.prototype.upperBounds = new Array(2);
b2Proxy.prototype.overlapCount = 0;
b2Proxy.prototype.timeStamp = 0;
b2Proxy.prototype.pairs = new Object;
b2Proxy.prototype.next = null;
b2Proxy.prototype.userData = null;var b2Point = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Point.prototype.__constructor = function() {
};
b2Point.prototype.__varz = function() {
  this.p = new b2Vec2
};
b2Point.prototype.Support = function(xf, vX, vY) {
  return this.p
};
b2Point.prototype.GetFirstVertex = function(xf) {
  return this.p
};
b2Point.prototype.p = new b2Vec2;var b2WorldManifold = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2WorldManifold.prototype.__constructor = function() {
  this.m_points = new Array(b2Settings.b2_maxManifoldPoints);
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i] = new b2Vec2
  }
};
b2WorldManifold.prototype.__varz = function() {
  this.m_normal = new b2Vec2
};
b2WorldManifold.prototype.Initialize = function(manifold, xfA, radiusA, xfB, radiusB) {
  if(manifold.m_pointCount == 0) {
    return
  }
  var i = 0;
  var tVec;
  var tMat;
  var normalX;
  var normalY;
  var planePointX;
  var planePointY;
  var clipPointX;
  var clipPointY;
  switch(manifold.m_type) {
    case b2Manifold.e_circles:
      tMat = xfA.R;
      tVec = manifold.m_localPoint;
      var pointAX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      var pointAY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = xfB.R;
      tVec = manifold.m_points[0].m_localPoint;
      var pointBX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      var pointBY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      var dX = pointBX - pointAX;
      var dY = pointBY - pointAY;
      var d2 = dX * dX + dY * dY;
      if(d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
        var d = Math.sqrt(d2);
        this.m_normal.x = dX / d;
        this.m_normal.y = dY / d
      }else {
        this.m_normal.x = 1;
        this.m_normal.y = 0
      }
      var cAX = pointAX + radiusA * this.m_normal.x;
      var cAY = pointAY + radiusA * this.m_normal.y;
      var cBX = pointBX - radiusB * this.m_normal.x;
      var cBY = pointBY - radiusB * this.m_normal.y;
      this.m_points[0].x = 0.5 * (cAX + cBX);
      this.m_points[0].y = 0.5 * (cAY + cBY);
      break;
    case b2Manifold.e_faceA:
      tMat = xfA.R;
      tVec = manifold.m_localPlaneNormal;
      normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = xfA.R;
      tVec = manifold.m_localPoint;
      planePointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      planePointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      this.m_normal.x = normalX;
      this.m_normal.y = normalY;
      for(i = 0;i < manifold.m_pointCount;i++) {
        tMat = xfB.R;
        tVec = manifold.m_points[i].m_localPoint;
        clipPointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
        clipPointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
        this.m_points[i].x = clipPointX + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalX;
        this.m_points[i].y = clipPointY + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalY
      }
      break;
    case b2Manifold.e_faceB:
      tMat = xfB.R;
      tVec = manifold.m_localPlaneNormal;
      normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = xfB.R;
      tVec = manifold.m_localPoint;
      planePointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      planePointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      this.m_normal.x = -normalX;
      this.m_normal.y = -normalY;
      for(i = 0;i < manifold.m_pointCount;i++) {
        tMat = xfA.R;
        tVec = manifold.m_points[i].m_localPoint;
        clipPointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
        clipPointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
        this.m_points[i].x = clipPointX + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalX;
        this.m_points[i].y = clipPointY + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalY
      }
      break
  }
};
b2WorldManifold.prototype.m_normal = new b2Vec2;
b2WorldManifold.prototype.m_points = null;var b2RayCastOutput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2RayCastOutput.prototype.__constructor = function() {
};
b2RayCastOutput.prototype.__varz = function() {
  this.normal = new b2Vec2
};
b2RayCastOutput.prototype.normal = new b2Vec2;
b2RayCastOutput.prototype.fraction = null;var b2ConstantForceController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2ConstantForceController.prototype, b2Controller.prototype);
b2ConstantForceController.prototype._super = b2Controller.prototype;
b2ConstantForceController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2ConstantForceController.prototype.__varz = function() {
  this.F = new b2Vec2(0, 0)
};
b2ConstantForceController.prototype.Step = function(step) {
  for(var i = m_bodyList;i;i = i.nextBody) {
    var body = i.body;
    if(!body.IsAwake()) {
      continue
    }
    body.ApplyForce(this.F, body.GetWorldCenter())
  }
};
b2ConstantForceController.prototype.F = new b2Vec2(0, 0);var b2MassData = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2MassData.prototype.__constructor = function() {
};
b2MassData.prototype.__varz = function() {
  this.center = new b2Vec2(0, 0)
};
b2MassData.prototype.mass = 0;
b2MassData.prototype.center = new b2Vec2(0, 0);
b2MassData.prototype.I = 0;var b2DynamicTree = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DynamicTree.prototype.__constructor = function() {
  this.m_root = null;
  this.m_freeList = null;
  this.m_path = 0;
  this.m_insertionCount = 0
};
b2DynamicTree.prototype.__varz = function() {
};
b2DynamicTree.prototype.AllocateNode = function() {
  if(this.m_freeList) {
    var node = this.m_freeList;
    this.m_freeList = node.parent;
    node.parent = null;
    node.child1 = null;
    node.child2 = null;
    return node
  }
  return new b2DynamicTreeNode
};
b2DynamicTree.prototype.FreeNode = function(node) {
  node.parent = this.m_freeList;
  this.m_freeList = node
};
b2DynamicTree.prototype.InsertLeaf = function(leaf) {
  ++this.m_insertionCount;
  if(this.m_root == null) {
    this.m_root = leaf;
    this.m_root.parent = null;
    return
  }
  var center = leaf.aabb.GetCenter();
  var sibling = this.m_root;
  if(sibling.IsLeaf() == false) {
    do {
      var child1 = sibling.child1;
      var child2 = sibling.child2;
      var norm1 = Math.abs((child1.aabb.lowerBound.x + child1.aabb.upperBound.x) / 2 - center.x) + Math.abs((child1.aabb.lowerBound.y + child1.aabb.upperBound.y) / 2 - center.y);
      var norm2 = Math.abs((child2.aabb.lowerBound.x + child2.aabb.upperBound.x) / 2 - center.x) + Math.abs((child2.aabb.lowerBound.y + child2.aabb.upperBound.y) / 2 - center.y);
      if(norm1 < norm2) {
        sibling = child1
      }else {
        sibling = child2
      }
    }while(sibling.IsLeaf() == false)
  }
  var node1 = sibling.parent;
  var node2 = this.AllocateNode();
  node2.parent = node1;
  node2.userData = null;
  node2.aabb.Combine(leaf.aabb, sibling.aabb);
  if(node1) {
    if(sibling.parent.child1 == sibling) {
      node1.child1 = node2
    }else {
      node1.child2 = node2
    }
    node2.child1 = sibling;
    node2.child2 = leaf;
    sibling.parent = node2;
    leaf.parent = node2;
    do {
      if(node1.aabb.Contains(node2.aabb)) {
        break
      }
      node1.aabb.Combine(node1.child1.aabb, node1.child2.aabb);
      node2 = node1;
      node1 = node1.parent
    }while(node1)
  }else {
    node2.child1 = sibling;
    node2.child2 = leaf;
    sibling.parent = node2;
    leaf.parent = node2;
    this.m_root = node2
  }
};
b2DynamicTree.prototype.RemoveLeaf = function(leaf) {
  if(leaf == this.m_root) {
    this.m_root = null;
    return
  }
  var node2 = leaf.parent;
  var node1 = node2.parent;
  var sibling;
  if(node2.child1 == leaf) {
    sibling = node2.child2
  }else {
    sibling = node2.child1
  }
  if(node1) {
    if(node1.child1 == node2) {
      node1.child1 = sibling
    }else {
      node1.child2 = sibling
    }
    sibling.parent = node1;
    this.FreeNode(node2);
    while(node1) {
      var oldAABB = node1.aabb;
      node1.aabb = b2AABB.Combine(node1.child1.aabb, node1.child2.aabb);
      if(oldAABB.Contains(node1.aabb)) {
        break
      }
      node1 = node1.parent
    }
  }else {
    this.m_root = sibling;
    sibling.parent = null;
    this.FreeNode(node2)
  }
};
b2DynamicTree.prototype.CreateProxy = function(aabb, userData) {
  var node = this.AllocateNode();
  var extendX = b2Settings.b2_aabbExtension;
  var extendY = b2Settings.b2_aabbExtension;
  node.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
  node.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
  node.aabb.upperBound.x = aabb.upperBound.x + extendX;
  node.aabb.upperBound.y = aabb.upperBound.y + extendY;
  node.userData = userData;
  this.InsertLeaf(node);
  return node
};
b2DynamicTree.prototype.DestroyProxy = function(proxy) {
  this.RemoveLeaf(proxy);
  this.FreeNode(proxy)
};
b2DynamicTree.prototype.MoveProxy = function(proxy, aabb, displacement) {
  b2Settings.b2Assert(proxy.IsLeaf());
  if(proxy.aabb.Contains(aabb)) {
    return false
  }
  this.RemoveLeaf(proxy);
  var extendX = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.x > 0 ? displacement.x : -displacement.x);
  var extendY = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.y > 0 ? displacement.y : -displacement.y);
  proxy.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
  proxy.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
  proxy.aabb.upperBound.x = aabb.upperBound.x + extendX;
  proxy.aabb.upperBound.y = aabb.upperBound.y + extendY;
  this.InsertLeaf(proxy);
  return true
};
b2DynamicTree.prototype.Rebalance = function(iterations) {
  if(this.m_root == null) {
    return
  }
  for(var i = 0;i < iterations;i++) {
    var node = this.m_root;
    var bit = 0;
    while(node.IsLeaf() == false) {
      node = this.m_path >> bit & 1 ? node.child2 : node.child1;
      bit = bit + 1 & 31
    }
    ++this.m_path;
    this.RemoveLeaf(node);
    this.InsertLeaf(node)
  }
};
b2DynamicTree.prototype.GetFatAABB = function(proxy) {
  return proxy.aabb
};
b2DynamicTree.prototype.GetUserData = function(proxy) {
  return proxy.userData
};
b2DynamicTree.prototype.Query = function(callback, aabb) {
  if(this.m_root == null) {
    return
  }
  var stack = new Array;
  var count = 0;
  stack[count++] = this.m_root;
  while(count > 0) {
    var node = stack[--count];
    if(node.aabb.TestOverlap(aabb)) {
      if(node.IsLeaf()) {
        var proceed = callback(node);
        if(!proceed) {
          return
        }
      }else {
        stack[count++] = node.child1;
        stack[count++] = node.child2
      }
    }
  }
};
b2DynamicTree.prototype.RayCast = function(callback, input) {
  if(this.m_root == null) {
    return
  }
  var p1 = input.p1;
  var p2 = input.p2;
  var r = b2Math.SubtractVV(p1, p2);
  r.Normalize();
  var v = b2Math.CrossFV(1, r);
  var abs_v = b2Math.AbsV(v);
  var maxFraction = input.maxFraction;
  var segmentAABB = new b2AABB;
  var tX;
  var tY;
  tX = p1.x + maxFraction * (p2.x - p1.x);
  tY = p1.y + maxFraction * (p2.y - p1.y);
  segmentAABB.lowerBound.x = Math.min(p1.x, tX);
  segmentAABB.lowerBound.y = Math.min(p1.y, tY);
  segmentAABB.upperBound.x = Math.max(p1.x, tX);
  segmentAABB.upperBound.y = Math.max(p1.y, tY);
  var stack = new Array;
  var count = 0;
  stack[count++] = this.m_root;
  while(count > 0) {
    var node = stack[--count];
    if(node.aabb.TestOverlap(segmentAABB) == false) {
      continue
    }
    var c = node.aabb.GetCenter();
    var h = node.aabb.GetExtents();
    var separation = Math.abs(v.x * (p1.x - c.x) + v.y * (p1.y - c.y)) - abs_v.x * h.x - abs_v.y * h.y;
    if(separation > 0) {
      continue
    }
    if(node.IsLeaf()) {
      var subInput = new b2RayCastInput;
      subInput.p1 = input.p1;
      subInput.p2 = input.p2;
      subInput.maxFraction = input.maxFraction;
      maxFraction = callback(subInput, node);
      if(maxFraction == 0) {
        return
      }
      tX = p1.x + maxFraction * (p2.x - p1.x);
      tY = p1.y + maxFraction * (p2.y - p1.y);
      segmentAABB.lowerBound.x = Math.min(p1.x, tX);
      segmentAABB.lowerBound.y = Math.min(p1.y, tY);
      segmentAABB.upperBound.x = Math.max(p1.x, tX);
      segmentAABB.upperBound.y = Math.max(p1.y, tY)
    }else {
      stack[count++] = node.child1;
      stack[count++] = node.child2
    }
  }
};
b2DynamicTree.prototype.m_root = null;
b2DynamicTree.prototype.m_freeList = null;
b2DynamicTree.prototype.m_path = 0;
b2DynamicTree.prototype.m_insertionCount = 0;var b2JointEdge = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2JointEdge.prototype.__constructor = function() {
};
b2JointEdge.prototype.__varz = function() {
};
b2JointEdge.prototype.other = null;
b2JointEdge.prototype.joint = null;
b2JointEdge.prototype.prev = null;
b2JointEdge.prototype.next = null;var b2RayCastInput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2RayCastInput.prototype.__constructor = function() {
};
b2RayCastInput.prototype.__varz = function() {
  this.p1 = new b2Vec2;
  this.p2 = new b2Vec2
};
b2RayCastInput.prototype.p1 = new b2Vec2;
b2RayCastInput.prototype.p2 = new b2Vec2;
b2RayCastInput.prototype.maxFraction = null;var Features = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
Features.prototype.__constructor = function() {
};
Features.prototype.__varz = function() {
};
Features.prototype.__defineGetter__("referenceEdge", function() {
  return this._referenceEdge
});
Features.prototype.__defineSetter__("referenceEdge", function(value) {
  this._referenceEdge = value;
  this._m_id._key = this._m_id._key & 4294967040 | this._referenceEdge & 255
});
Features.prototype.__defineGetter__("incidentEdge", function() {
  return this._incidentEdge
});
Features.prototype.__defineSetter__("incidentEdge", function(value) {
  this._incidentEdge = value;
  this._m_id._key = this._m_id._key & 4294902015 | this._incidentEdge << 8 & 65280
});
Features.prototype.__defineGetter__("incidentVertex", function() {
  return this._incidentVertex
});
Features.prototype.__defineSetter__("incidentVertex", function(value) {
  this._incidentVertex = value;
  this._m_id._key = this._m_id._key & 4278255615 | this._incidentVertex << 16 & 16711680
});
Features.prototype.__defineGetter__("flip", function() {
  return this._flip
});
Features.prototype.__defineSetter__("flip", function(value) {
  this._flip = value;
  this._m_id._key = this._m_id._key & 16777215 | this._flip << 24 & 4278190080
});
Features.prototype._referenceEdge = 0;
Features.prototype._incidentEdge = 0;
Features.prototype._incidentVertex = 0;
Features.prototype._flip = 0;
Features.prototype._m_id = null;var b2FilterData = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2FilterData.prototype.__constructor = function() {
};
b2FilterData.prototype.__varz = function() {
  this.categoryBits = 1;
  this.maskBits = 65535
};
b2FilterData.prototype.Copy = function() {
  var copy = new b2FilterData;
  copy.categoryBits = this.categoryBits;
  copy.maskBits = this.maskBits;
  copy.groupIndex = this.groupIndex;
  return copy
};
b2FilterData.prototype.categoryBits = 1;
b2FilterData.prototype.maskBits = 65535;
b2FilterData.prototype.groupIndex = 0;var b2AABB = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2AABB.prototype.__constructor = function() {
};
b2AABB.prototype.__varz = function() {
  this.lowerBound = new b2Vec2;
  this.upperBound = new b2Vec2
};
b2AABB.Combine = function(aabb1, aabb2) {
  var aabb = new b2AABB;
  aabb.Combine(aabb1, aabb2);
  return aabb
};
b2AABB.prototype.IsValid = function() {
  var dX = this.upperBound.x - this.lowerBound.x;
  var dY = this.upperBound.y - this.lowerBound.y;
  var valid = dX >= 0 && dY >= 0;
  valid = valid && this.lowerBound.IsValid() && this.upperBound.IsValid();
  return valid
};
b2AABB.prototype.GetCenter = function() {
  return new b2Vec2((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2)
};
b2AABB.prototype.GetExtents = function() {
  return new b2Vec2((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2)
};
b2AABB.prototype.Contains = function(aabb) {
  var result = true && this.lowerBound.x <= aabb.lowerBound.x && this.lowerBound.y <= aabb.lowerBound.y && aabb.upperBound.x <= this.upperBound.x && aabb.upperBound.y <= this.upperBound.y;
  return result
};
b2AABB.prototype.RayCast = function(output, input) {
  var tmin = -Number.MAX_VALUE;
  var tmax = Number.MAX_VALUE;
  var pX = input.p1.x;
  var pY = input.p1.y;
  var dX = input.p2.x - input.p1.x;
  var dY = input.p2.y - input.p1.y;
  var absDX = Math.abs(dX);
  var absDY = Math.abs(dY);
  var normal = output.normal;
  var inv_d;
  var t1;
  var t2;
  var t3;
  var s;
  if(absDX < Number.MIN_VALUE) {
    if(pX < this.lowerBound.x || this.upperBound.x < pX) {
      return false
    }
  }else {
    inv_d = 1 / dX;
    t1 = (this.lowerBound.x - pX) * inv_d;
    t2 = (this.upperBound.x - pX) * inv_d;
    s = -1;
    if(t1 > t2) {
      t3 = t1;
      t1 = t2;
      t2 = t3;
      s = 1
    }
    if(t1 > tmin) {
      normal.x = s;
      normal.y = 0;
      tmin = t1
    }
    tmax = Math.min(tmax, t2);
    if(tmin > tmax) {
      return false
    }
  }
  if(absDY < Number.MIN_VALUE) {
    if(pY < this.lowerBound.y || this.upperBound.y < pY) {
      return false
    }
  }else {
    inv_d = 1 / dY;
    t1 = (this.lowerBound.y - pY) * inv_d;
    t2 = (this.upperBound.y - pY) * inv_d;
    s = -1;
    if(t1 > t2) {
      t3 = t1;
      t1 = t2;
      t2 = t3;
      s = 1
    }
    if(t1 > tmin) {
      normal.y = s;
      normal.x = 0;
      tmin = t1
    }
    tmax = Math.min(tmax, t2);
    if(tmin > tmax) {
      return false
    }
  }
  output.fraction = tmin;
  return true
};
b2AABB.prototype.TestOverlap = function(other) {
  var d1X = other.lowerBound.x - this.upperBound.x;
  var d1Y = other.lowerBound.y - this.upperBound.y;
  var d2X = this.lowerBound.x - other.upperBound.x;
  var d2Y = this.lowerBound.y - other.upperBound.y;
  if(d1X > 0 || d1Y > 0) {
    return false
  }
  if(d2X > 0 || d2Y > 0) {
    return false
  }
  return true
};
b2AABB.prototype.Combine = function(aabb1, aabb2) {
  this.lowerBound.x = Math.min(aabb1.lowerBound.x, aabb2.lowerBound.x);
  this.lowerBound.y = Math.min(aabb1.lowerBound.y, aabb2.lowerBound.y);
  this.upperBound.x = Math.max(aabb1.upperBound.x, aabb2.upperBound.x);
  this.upperBound.y = Math.max(aabb1.upperBound.y, aabb2.upperBound.y)
};
b2AABB.prototype.lowerBound = new b2Vec2;
b2AABB.prototype.upperBound = new b2Vec2;var b2Jacobian = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Jacobian.prototype.__constructor = function() {
};
b2Jacobian.prototype.__varz = function() {
  this.linearA = new b2Vec2;
  this.linearB = new b2Vec2
};
b2Jacobian.prototype.SetZero = function() {
  this.linearA.SetZero();
  this.angularA = 0;
  this.linearB.SetZero();
  this.angularB = 0
};
b2Jacobian.prototype.Set = function(x1, a1, x2, a2) {
  this.linearA.SetV(x1);
  this.angularA = a1;
  this.linearB.SetV(x2);
  this.angularB = a2
};
b2Jacobian.prototype.Compute = function(x1, a1, x2, a2) {
  return this.linearA.x * x1.x + this.linearA.y * x1.y + this.angularA * a1 + (this.linearB.x * x2.x + this.linearB.y * x2.y) + this.angularB * a2
};
b2Jacobian.prototype.linearA = new b2Vec2;
b2Jacobian.prototype.angularA = null;
b2Jacobian.prototype.linearB = new b2Vec2;
b2Jacobian.prototype.angularB = null;var b2Bound = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Bound.prototype.__constructor = function() {
};
b2Bound.prototype.__varz = function() {
};
b2Bound.prototype.IsLower = function() {
  return(this.value & 1) == 0
};
b2Bound.prototype.IsUpper = function() {
  return(this.value & 1) == 1
};
b2Bound.prototype.Swap = function(b) {
  var tempValue = this.value;
  var tempProxy = this.proxy;
  var tempStabbingCount = this.stabbingCount;
  this.value = b.value;
  this.proxy = b.proxy;
  this.stabbingCount = b.stabbingCount;
  b.value = tempValue;
  b.proxy = tempProxy;
  b.stabbingCount = tempStabbingCount
};
b2Bound.prototype.value = 0;
b2Bound.prototype.proxy = null;
b2Bound.prototype.stabbingCount = 0;var b2SimplexVertex = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2SimplexVertex.prototype.__constructor = function() {
};
b2SimplexVertex.prototype.__varz = function() {
};
b2SimplexVertex.prototype.Set = function(other) {
  this.wA.SetV(other.wA);
  this.wB.SetV(other.wB);
  this.w.SetV(other.w);
  this.a = other.a;
  this.indexA = other.indexA;
  this.indexB = other.indexB
};
b2SimplexVertex.prototype.wA = null;
b2SimplexVertex.prototype.wB = null;
b2SimplexVertex.prototype.w = null;
b2SimplexVertex.prototype.a = null;
b2SimplexVertex.prototype.indexA = 0;
b2SimplexVertex.prototype.indexB = 0;var b2Mat22 = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Mat22.prototype.__constructor = function() {
  this.col1.x = this.col2.y = 1
};
b2Mat22.prototype.__varz = function() {
  this.col1 = new b2Vec2;
  this.col2 = new b2Vec2
};
b2Mat22.FromAngle = function(angle) {
  var mat = new b2Mat22;
  mat.Set(angle);
  return mat
};
b2Mat22.FromVV = function(c1, c2) {
  var mat = new b2Mat22;
  mat.SetVV(c1, c2);
  return mat
};
b2Mat22.prototype.Set = function(angle) {
  var c = Math.cos(angle);
  var s = Math.sin(angle);
  this.col1.x = c;
  this.col2.x = -s;
  this.col1.y = s;
  this.col2.y = c
};
b2Mat22.prototype.SetVV = function(c1, c2) {
  this.col1.SetV(c1);
  this.col2.SetV(c2)
};
b2Mat22.prototype.Copy = function() {
  var mat = new b2Mat22;
  mat.SetM(this);
  return mat
};
b2Mat22.prototype.SetM = function(m) {
  this.col1.SetV(m.col1);
  this.col2.SetV(m.col2)
};
b2Mat22.prototype.AddM = function(m) {
  this.col1.x += m.col1.x;
  this.col1.y += m.col1.y;
  this.col2.x += m.col2.x;
  this.col2.y += m.col2.y
};
b2Mat22.prototype.SetIdentity = function() {
  this.col1.x = 1;
  this.col2.x = 0;
  this.col1.y = 0;
  this.col2.y = 1
};
b2Mat22.prototype.SetZero = function() {
  this.col1.x = 0;
  this.col2.x = 0;
  this.col1.y = 0;
  this.col2.y = 0
};
b2Mat22.prototype.GetAngle = function() {
  return Math.atan2(this.col1.y, this.col1.x)
};
b2Mat22.prototype.GetInverse = function(out) {
  var a = this.col1.x;
  var b = this.col2.x;
  var c = this.col1.y;
  var d = this.col2.y;
  var det = a * d - b * c;
  if(det != 0) {
    det = 1 / det
  }
  out.col1.x = det * d;
  out.col2.x = -det * b;
  out.col1.y = -det * c;
  out.col2.y = det * a;
  return out
};
b2Mat22.prototype.Solve = function(out, bX, bY) {
  var a11 = this.col1.x;
  var a12 = this.col2.x;
  var a21 = this.col1.y;
  var a22 = this.col2.y;
  var det = a11 * a22 - a12 * a21;
  if(det != 0) {
    det = 1 / det
  }
  out.x = det * (a22 * bX - a12 * bY);
  out.y = det * (a11 * bY - a21 * bX);
  return out
};
b2Mat22.prototype.Abs = function() {
  this.col1.Abs();
  this.col2.Abs()
};
b2Mat22.prototype.col1 = new b2Vec2;
b2Mat22.prototype.col2 = new b2Vec2;var b2SimplexCache = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2SimplexCache.prototype.__constructor = function() {
};
b2SimplexCache.prototype.__varz = function() {
  this.indexA = new Array(3);
  this.indexB = new Array(3)
};
b2SimplexCache.prototype.metric = null;
b2SimplexCache.prototype.count = 0;
b2SimplexCache.prototype.indexA = new Array(3);
b2SimplexCache.prototype.indexB = new Array(3);var b2Shape = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Shape.prototype.__constructor = function() {
  this.m_type = b2Shape.e_unknownShape;
  this.m_radius = b2Settings.b2_linearSlop
};
b2Shape.prototype.__varz = function() {
};
b2Shape.TestOverlap = function(shape1, transform1, shape2, transform2) {
  var input = new b2DistanceInput;
  input.proxyA = new b2DistanceProxy;
  input.proxyA.Set(shape1);
  input.proxyB = new b2DistanceProxy;
  input.proxyB.Set(shape2);
  input.transformA = transform1;
  input.transformB = transform2;
  input.useRadii = true;
  var simplexCache = new b2SimplexCache;
  simplexCache.count = 0;
  var output = new b2DistanceOutput;
  b2Distance.Distance(output, simplexCache, input);
  return output.distance < 10 * Number.MIN_VALUE
};
b2Shape.e_hitCollide = 1;
b2Shape.e_missCollide = 0;
b2Shape.e_startsInsideCollide = -1;
b2Shape.e_unknownShape = -1;
b2Shape.e_circleShape = 0;
b2Shape.e_polygonShape = 1;
b2Shape.e_edgeShape = 2;
b2Shape.e_shapeTypeCount = 3;
b2Shape.prototype.Copy = function() {
  return null
};
b2Shape.prototype.Set = function(other) {
  this.m_radius = other.m_radius
};
b2Shape.prototype.GetType = function() {
  return this.m_type
};
b2Shape.prototype.TestPoint = function(xf, p) {
  return false
};
b2Shape.prototype.RayCast = function(output, input, transform) {
  return false
};
b2Shape.prototype.ComputeAABB = function(aabb, xf) {
};
b2Shape.prototype.ComputeMass = function(massData, density) {
};
b2Shape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  return 0
};
b2Shape.prototype.m_type = 0;
b2Shape.prototype.m_radius = null;var b2Segment = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Segment.prototype.__constructor = function() {
};
b2Segment.prototype.__varz = function() {
  this.p1 = new b2Vec2;
  this.p2 = new b2Vec2
};
b2Segment.prototype.TestSegment = function(lambda, normal, segment, maxLambda) {
  var s = segment.p1;
  var rX = segment.p2.x - s.x;
  var rY = segment.p2.y - s.y;
  var dX = this.p2.x - this.p1.x;
  var dY = this.p2.y - this.p1.y;
  var nX = dY;
  var nY = -dX;
  var k_slop = 100 * Number.MIN_VALUE;
  var denom = -(rX * nX + rY * nY);
  if(denom > k_slop) {
    var bX = s.x - this.p1.x;
    var bY = s.y - this.p1.y;
    var a = bX * nX + bY * nY;
    if(0 <= a && a <= maxLambda * denom) {
      var mu2 = -rX * bY + rY * bX;
      if(-k_slop * denom <= mu2 && mu2 <= denom * (1 + k_slop)) {
        a /= denom;
        var nLen = Math.sqrt(nX * nX + nY * nY);
        nX /= nLen;
        nY /= nLen;
        lambda[0] = a;
        normal.Set(nX, nY);
        return true
      }
    }
  }
  return false
};
b2Segment.prototype.Extend = function(aabb) {
  this.ExtendForward(aabb);
  this.ExtendBackward(aabb)
};
b2Segment.prototype.ExtendForward = function(aabb) {
  var dX = this.p2.x - this.p1.x;
  var dY = this.p2.y - this.p1.y;
  var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p1.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p1.x) / dX : Number.POSITIVE_INFINITY, dY > 0 ? (aabb.upperBound.y - this.p1.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p1.y) / dY : Number.POSITIVE_INFINITY);
  this.p2.x = this.p1.x + dX * lambda;
  this.p2.y = this.p1.y + dY * lambda
};
b2Segment.prototype.ExtendBackward = function(aabb) {
  var dX = -this.p2.x + this.p1.x;
  var dY = -this.p2.y + this.p1.y;
  var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p2.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p2.x) / dX : Number.POSITIVE_INFINITY, dY > 0 ? (aabb.upperBound.y - this.p2.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p2.y) / dY : Number.POSITIVE_INFINITY);
  this.p1.x = this.p2.x + dX * lambda;
  this.p1.y = this.p2.y + dY * lambda
};
b2Segment.prototype.p1 = new b2Vec2;
b2Segment.prototype.p2 = new b2Vec2;var b2ContactRegister = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactRegister.prototype.__constructor = function() {
};
b2ContactRegister.prototype.__varz = function() {
};
b2ContactRegister.prototype.createFcn = null;
b2ContactRegister.prototype.destroyFcn = null;
b2ContactRegister.prototype.primary = null;
b2ContactRegister.prototype.pool = null;
b2ContactRegister.prototype.poolCount = 0;var b2DebugDraw = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DebugDraw.prototype.__constructor = function() {
  this.m_drawFlags = 0
};
b2DebugDraw.prototype.__varz = function() {
};
b2DebugDraw.e_shapeBit = 1;
b2DebugDraw.e_jointBit = 2;
b2DebugDraw.e_aabbBit = 4;
b2DebugDraw.e_pairBit = 8;
b2DebugDraw.e_centerOfMassBit = 16;
b2DebugDraw.e_controllerBit = 32;
b2DebugDraw.prototype.SetFlags = function(flags) {
  this.m_drawFlags = flags
};
b2DebugDraw.prototype.GetFlags = function() {
  return this.m_drawFlags
};
b2DebugDraw.prototype.AppendFlags = function(flags) {
  this.m_drawFlags |= flags
};
b2DebugDraw.prototype.ClearFlags = function(flags) {
  this.m_drawFlags &= ~flags
};
b2DebugDraw.prototype.SetSprite = function(sprite) {
  this.m_sprite = sprite
};
b2DebugDraw.prototype.GetSprite = function() {
  return this.m_sprite
};
b2DebugDraw.prototype.SetDrawScale = function(drawScale) {
  this.m_drawScale = drawScale
};
b2DebugDraw.prototype.GetDrawScale = function() {
  return this.m_drawScale
};
b2DebugDraw.prototype.SetLineThickness = function(lineThickness) {
  this.m_lineThickness = lineThickness
};
b2DebugDraw.prototype.GetLineThickness = function() {
  return this.m_lineThickness
};
b2DebugDraw.prototype.SetAlpha = function(alpha) {
  this.m_alpha = alpha
};
b2DebugDraw.prototype.GetAlpha = function() {
  return this.m_alpha
};
b2DebugDraw.prototype.SetFillAlpha = function(alpha) {
  this.m_fillAlpha = alpha
};
b2DebugDraw.prototype.GetFillAlpha = function() {
  return this.m_fillAlpha
};
b2DebugDraw.prototype.SetXFormScale = function(xformScale) {
  this.m_xformScale = xformScale
};
b2DebugDraw.prototype.GetXFormScale = function() {
  return this.m_xformScale
};
b2DebugDraw.prototype.Clear = function() {
  this.m_sprite.clearRect(0, 0, this.m_sprite.canvas.width, this.m_sprite.canvas.height)
};
b2DebugDraw.prototype.Y = function(y) {
  return this.m_sprite.canvas.height - y
};
b2DebugDraw.prototype.ToWorldPoint = function(localPoint) {
  return new b2Vec2(localPoint.x / this.m_drawScale, this.Y(localPoint.y) / this.m_drawScale)
};
b2DebugDraw.prototype.ColorStyle = function(color, alpha) {
  return"rgba(" + color.r + ", " + color.g + ", " + color.b + ", " + alpha + ")"
};
b2DebugDraw.prototype.DrawPolygon = function(vertices, vertexCount, color) {
  this.m_sprite.graphics.lineStyle(this.m_lineThickness, color.color, this.m_alpha);
  this.m_sprite.graphics.moveTo(vertices[0].x * this.m_drawScale, vertices[0].y * this.m_drawScale);
  for(var i = 1;i < vertexCount;i++) {
    this.m_sprite.graphics.lineTo(vertices[i].x * this.m_drawScale, vertices[i].y * this.m_drawScale)
  }
  this.m_sprite.graphics.lineTo(vertices[0].x * this.m_drawScale, vertices[0].y * this.m_drawScale)
};
b2DebugDraw.prototype.DrawSolidPolygon = function(vertices, vertexCount, color) {
  this.m_sprite.strokeSyle = this.ColorStyle(color, this.m_alpha);
  this.m_sprite.lineWidth = this.m_lineThickness;
  this.m_sprite.fillStyle = this.ColorStyle(color, this.m_fillAlpha);
  this.m_sprite.beginPath();
  this.m_sprite.moveTo(vertices[0].x * this.m_drawScale, this.Y(vertices[0].y * this.m_drawScale));
  for(var i = 1;i < vertexCount;i++) {
    this.m_sprite.lineTo(vertices[i].x * this.m_drawScale, this.Y(vertices[i].y * this.m_drawScale))
  }
  this.m_sprite.lineTo(vertices[0].x * this.m_drawScale, this.Y(vertices[0].y * this.m_drawScale));
  this.m_sprite.fill();
  this.m_sprite.stroke();
  this.m_sprite.closePath()
};
b2DebugDraw.prototype.DrawCircle = function(center, radius, color) {
  this.m_sprite.graphics.lineStyle(this.m_lineThickness, color.color, this.m_alpha);
  this.m_sprite.graphics.drawCircle(center.x * this.m_drawScale, center.y * this.m_drawScale, radius * this.m_drawScale)
};
b2DebugDraw.prototype.DrawSolidCircle = function(center, radius, axis, color) {
  this.m_sprite.strokeSyle = this.ColorStyle(color, this.m_alpha);
  this.m_sprite.lineWidth = this.m_lineThickness;
  this.m_sprite.fillStyle = this.ColorStyle(color, this.m_fillAlpha);
  this.m_sprite.beginPath();
  this.m_sprite.arc(center.x * this.m_drawScale, this.Y(center.y * this.m_drawScale), radius * this.m_drawScale, 0, Math.PI * 2, true);
  this.m_sprite.fill();
  this.m_sprite.stroke();
  this.m_sprite.closePath()
};
b2DebugDraw.prototype.DrawSegment = function(p1, p2, color) {
  this.m_sprite.lineWidth = this.m_lineThickness;
  this.m_sprite.strokeSyle = this.ColorStyle(color, this.m_alpha);
  this.m_sprite.beginPath();
  this.m_sprite.moveTo(p1.x * this.m_drawScale, this.Y(p1.y * this.m_drawScale));
  this.m_sprite.lineTo(p2.x * this.m_drawScale, this.Y(p2.y * this.m_drawScale));
  this.m_sprite.stroke();
  this.m_sprite.closePath()
};
b2DebugDraw.prototype.DrawTransform = function(xf) {
  this.m_sprite.lineWidth = this.m_lineThickness;
  this.m_sprite.strokeSyle = this.ColorStyle(new b2Color(255, 0, 0), this.m_alpha);
  this.m_sprite.beginPath();
  this.m_sprite.moveTo(xf.position.x * this.m_drawScale, this.Y(xf.position.y * this.m_drawScale));
  this.m_sprite.lineTo((xf.position.x + this.m_xformScale * xf.R.col1.x) * this.m_drawScale, this.Y((xf.position.y + this.m_xformScale * xf.R.col1.y) * this.m_drawScale));
  this.m_sprite.stroke();
  this.m_sprite.closePath();
  this.m_sprite.strokeSyle = this.ColorStyle(new b2Color(0, 255, 0), this.m_alpha);
  this.m_sprite.beginPath();
  this.m_sprite.moveTo(xf.position.x * this.m_drawScale, this.Y(xf.position.y * this.m_drawScale));
  this.m_sprite.lineTo((xf.position.x + this.m_xformScale * xf.R.col2.x) * this.m_drawScale, this.Y((xf.position.y + this.m_xformScale * xf.R.col2.y) * this.m_drawScale));
  this.m_sprite.stroke();
  this.m_sprite.closePath()
};
b2DebugDraw.prototype.m_drawFlags = 0;
b2DebugDraw.prototype.m_sprite = null;
b2DebugDraw.prototype.m_drawScale = 1;
b2DebugDraw.prototype.m_lineThickness = 1;
b2DebugDraw.prototype.m_alpha = 1;
b2DebugDraw.prototype.m_fillAlpha = 1;
b2DebugDraw.prototype.m_xformScale = 1;var b2Sweep = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Sweep.prototype.__constructor = function() {
};
b2Sweep.prototype.__varz = function() {
  this.localCenter = new b2Vec2;
  this.c0 = new b2Vec2;
  this.c = new b2Vec2
};
b2Sweep.prototype.Set = function(other) {
  this.localCenter.SetV(other.localCenter);
  this.c0.SetV(other.c0);
  this.c.SetV(other.c);
  this.a0 = other.a0;
  this.a = other.a;
  this.t0 = other.t0
};
b2Sweep.prototype.Copy = function() {
  var copy = new b2Sweep;
  copy.localCenter.SetV(this.localCenter);
  copy.c0.SetV(this.c0);
  copy.c.SetV(this.c);
  copy.a0 = this.a0;
  copy.a = this.a;
  copy.t0 = this.t0;
  return copy
};
b2Sweep.prototype.GetTransform = function(xf, alpha) {
  xf.position.x = (1 - alpha) * this.c0.x + alpha * this.c.x;
  xf.position.y = (1 - alpha) * this.c0.y + alpha * this.c.y;
  var angle = (1 - alpha) * this.a0 + alpha * this.a;
  xf.R.Set(angle);
  var tMat = xf.R;
  xf.position.x -= tMat.col1.x * this.localCenter.x + tMat.col2.x * this.localCenter.y;
  xf.position.y -= tMat.col1.y * this.localCenter.x + tMat.col2.y * this.localCenter.y
};
b2Sweep.prototype.Advance = function(t) {
  if(this.t0 < t && 1 - this.t0 > Number.MIN_VALUE) {
    var alpha = (t - this.t0) / (1 - this.t0);
    this.c0.x = (1 - alpha) * this.c0.x + alpha * this.c.x;
    this.c0.y = (1 - alpha) * this.c0.y + alpha * this.c.y;
    this.a0 = (1 - alpha) * this.a0 + alpha * this.a;
    this.t0 = t
  }
};
b2Sweep.prototype.localCenter = new b2Vec2;
b2Sweep.prototype.c0 = new b2Vec2;
b2Sweep.prototype.c = new b2Vec2;
b2Sweep.prototype.a0 = null;
b2Sweep.prototype.a = null;
b2Sweep.prototype.t0 = null;var b2DistanceOutput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DistanceOutput.prototype.__constructor = function() {
};
b2DistanceOutput.prototype.__varz = function() {
  this.pointA = new b2Vec2;
  this.pointB = new b2Vec2
};
b2DistanceOutput.prototype.pointA = new b2Vec2;
b2DistanceOutput.prototype.pointB = new b2Vec2;
b2DistanceOutput.prototype.distance = null;
b2DistanceOutput.prototype.iterations = 0;var b2Mat33 = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Mat33.prototype.__constructor = function(c1, c2, c3) {
  if(!c1 && !c2 && !c3) {
    this.col1.SetZero();
    this.col2.SetZero();
    this.col3.SetZero()
  }else {
    this.col1.SetV(c1);
    this.col2.SetV(c2);
    this.col3.SetV(c3)
  }
};
b2Mat33.prototype.__varz = function() {
  this.col1 = new b2Vec3;
  this.col2 = new b2Vec3;
  this.col3 = new b2Vec3
};
b2Mat33.prototype.SetVVV = function(c1, c2, c3) {
  this.col1.SetV(c1);
  this.col2.SetV(c2);
  this.col3.SetV(c3)
};
b2Mat33.prototype.Copy = function() {
  return new b2Mat33(this.col1, this.col2, this.col3)
};
b2Mat33.prototype.SetM = function(m) {
  this.col1.SetV(m.col1);
  this.col2.SetV(m.col2);
  this.col3.SetV(m.col3)
};
b2Mat33.prototype.AddM = function(m) {
  this.col1.x += m.col1.x;
  this.col1.y += m.col1.y;
  this.col1.z += m.col1.z;
  this.col2.x += m.col2.x;
  this.col2.y += m.col2.y;
  this.col2.z += m.col2.z;
  this.col3.x += m.col3.x;
  this.col3.y += m.col3.y;
  this.col3.z += m.col3.z
};
b2Mat33.prototype.SetIdentity = function() {
  this.col1.x = 1;
  this.col2.x = 0;
  this.col3.x = 0;
  this.col1.y = 0;
  this.col2.y = 1;
  this.col3.y = 0;
  this.col1.z = 0;
  this.col2.z = 0;
  this.col3.z = 1
};
b2Mat33.prototype.SetZero = function() {
  this.col1.x = 0;
  this.col2.x = 0;
  this.col3.x = 0;
  this.col1.y = 0;
  this.col2.y = 0;
  this.col3.y = 0;
  this.col1.z = 0;
  this.col2.z = 0;
  this.col3.z = 0
};
b2Mat33.prototype.Solve22 = function(out, bX, bY) {
  var a11 = this.col1.x;
  var a12 = this.col2.x;
  var a21 = this.col1.y;
  var a22 = this.col2.y;
  var det = a11 * a22 - a12 * a21;
  if(det != 0) {
    det = 1 / det
  }
  out.x = det * (a22 * bX - a12 * bY);
  out.y = det * (a11 * bY - a21 * bX);
  return out
};
b2Mat33.prototype.Solve33 = function(out, bX, bY, bZ) {
  var a11 = this.col1.x;
  var a21 = this.col1.y;
  var a31 = this.col1.z;
  var a12 = this.col2.x;
  var a22 = this.col2.y;
  var a32 = this.col2.z;
  var a13 = this.col3.x;
  var a23 = this.col3.y;
  var a33 = this.col3.z;
  var det = a11 * (a22 * a33 - a32 * a23) + a21 * (a32 * a13 - a12 * a33) + a31 * (a12 * a23 - a22 * a13);
  if(det != 0) {
    det = 1 / det
  }
  out.x = det * (bX * (a22 * a33 - a32 * a23) + bY * (a32 * a13 - a12 * a33) + bZ * (a12 * a23 - a22 * a13));
  out.y = det * (a11 * (bY * a33 - bZ * a23) + a21 * (bZ * a13 - bX * a33) + a31 * (bX * a23 - bY * a13));
  out.z = det * (a11 * (a22 * bZ - a32 * bY) + a21 * (a32 * bX - a12 * bZ) + a31 * (a12 * bY - a22 * bX));
  return out
};
b2Mat33.prototype.col1 = new b2Vec3;
b2Mat33.prototype.col2 = new b2Vec3;
b2Mat33.prototype.col3 = new b2Vec3;var b2PositionSolverManifold = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2PositionSolverManifold.prototype.__constructor = function() {
  this.m_normal = new b2Vec2;
  this.m_separations = new Array(b2Settings.b2_maxManifoldPoints);
  this.m_points = new Array(b2Settings.b2_maxManifoldPoints);
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i] = new b2Vec2
  }
};
b2PositionSolverManifold.prototype.__varz = function() {
};
b2PositionSolverManifold.circlePointA = new b2Vec2;
b2PositionSolverManifold.circlePointB = new b2Vec2;
b2PositionSolverManifold.prototype.Initialize = function(cc) {
  b2Settings.b2Assert(cc.pointCount > 0);
  var i = 0;
  var clipPointX;
  var clipPointY;
  var tMat;
  var tVec;
  var planePointX;
  var planePointY;
  switch(cc.type) {
    case b2Manifold.e_circles:
      tMat = cc.bodyA.m_xf.R;
      tVec = cc.localPoint;
      var pointAX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var pointAY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = cc.bodyB.m_xf.R;
      tVec = cc.points[0].localPoint;
      var pointBX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var pointBY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var dX = pointBX - pointAX;
      var dY = pointBY - pointAY;
      var d2 = dX * dX + dY * dY;
      if(d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
        var d = Math.sqrt(d2);
        this.m_normal.x = dX / d;
        this.m_normal.y = dY / d
      }else {
        this.m_normal.x = 1;
        this.m_normal.y = 0
      }
      this.m_points[0].x = 0.5 * (pointAX + pointBX);
      this.m_points[0].y = 0.5 * (pointAY + pointBY);
      this.m_separations[0] = dX * this.m_normal.x + dY * this.m_normal.y - cc.radius;
      break;
    case b2Manifold.e_faceA:
      tMat = cc.bodyA.m_xf.R;
      tVec = cc.localPlaneNormal;
      this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = cc.bodyA.m_xf.R;
      tVec = cc.localPoint;
      planePointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      planePointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = cc.bodyB.m_xf.R;
      for(i = 0;i < cc.pointCount;++i) {
        tVec = cc.points[i].localPoint;
        clipPointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        clipPointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
        this.m_points[i].x = clipPointX;
        this.m_points[i].y = clipPointY
      }
      break;
    case b2Manifold.e_faceB:
      tMat = cc.bodyB.m_xf.R;
      tVec = cc.localPlaneNormal;
      this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = cc.bodyB.m_xf.R;
      tVec = cc.localPoint;
      planePointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      planePointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = cc.bodyA.m_xf.R;
      for(i = 0;i < cc.pointCount;++i) {
        tVec = cc.points[i].localPoint;
        clipPointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        clipPointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
        this.m_points[i].Set(clipPointX, clipPointY)
      }
      this.m_normal.x *= -1;
      this.m_normal.y *= -1;
      break
  }
};
b2PositionSolverManifold.prototype.m_normal = null;
b2PositionSolverManifold.prototype.m_points = null;
b2PositionSolverManifold.prototype.m_separations = null;var b2OBB = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2OBB.prototype.__constructor = function() {
};
b2OBB.prototype.__varz = function() {
  this.R = new b2Mat22;
  this.center = new b2Vec2;
  this.extents = new b2Vec2
};
b2OBB.prototype.R = new b2Mat22;
b2OBB.prototype.center = new b2Vec2;
b2OBB.prototype.extents = new b2Vec2;var b2Pair = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Pair.prototype.__constructor = function() {
};
b2Pair.prototype.__varz = function() {
};
b2Pair.b2_nullProxy = b2Settings.USHRT_MAX;
b2Pair.e_pairBuffered = 1;
b2Pair.e_pairRemoved = 2;
b2Pair.e_pairFinal = 4;
b2Pair.prototype.SetBuffered = function() {
  this.status |= b2Pair.e_pairBuffered
};
b2Pair.prototype.ClearBuffered = function() {
  this.status &= ~b2Pair.e_pairBuffered
};
b2Pair.prototype.IsBuffered = function() {
  return(this.status & b2Pair.e_pairBuffered) == b2Pair.e_pairBuffered
};
b2Pair.prototype.SetRemoved = function() {
  this.status |= b2Pair.e_pairRemoved
};
b2Pair.prototype.ClearRemoved = function() {
  this.status &= ~b2Pair.e_pairRemoved
};
b2Pair.prototype.IsRemoved = function() {
  return(this.status & b2Pair.e_pairRemoved) == b2Pair.e_pairRemoved
};
b2Pair.prototype.SetFinal = function() {
  this.status |= b2Pair.e_pairFinal
};
b2Pair.prototype.IsFinal = function() {
  return(this.status & b2Pair.e_pairFinal) == b2Pair.e_pairFinal
};
b2Pair.prototype.userData = null;
b2Pair.prototype.proxy1 = null;
b2Pair.prototype.proxy2 = null;
b2Pair.prototype.next = null;
b2Pair.prototype.status = 0;var b2FixtureDef = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2FixtureDef.prototype.__constructor = function() {
  this.shape = null;
  this.userData = null;
  this.friction = 0.2;
  this.restitution = 0;
  this.density = 0;
  this.filter.categoryBits = 1;
  this.filter.maskBits = 65535;
  this.filter.groupIndex = 0;
  this.isSensor = false
};
b2FixtureDef.prototype.__varz = function() {
  this.filter = new b2FilterData
};
b2FixtureDef.prototype.shape = null;
b2FixtureDef.prototype.userData = null;
b2FixtureDef.prototype.friction = null;
b2FixtureDef.prototype.restitution = null;
b2FixtureDef.prototype.density = null;
b2FixtureDef.prototype.isSensor = null;
b2FixtureDef.prototype.filter = new b2FilterData;var b2ContactID = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactID.prototype.__constructor = function() {
  this.features._m_id = this
};
b2ContactID.prototype.__varz = function() {
  this.features = new Features
};
b2ContactID.prototype.Set = function(id) {
  key = id._key
};
b2ContactID.prototype.Copy = function() {
  var id = new b2ContactID;
  id.key = key;
  return id
};
b2ContactID.prototype.__defineSetter__("key", function() {
  return this._key
});
b2ContactID.prototype.__defineSetter__("key", function(value) {
  this._key = value;
  this.features._referenceEdge = this._key & 255;
  this.features._incidentEdge = (this._key & 65280) >> 8 & 255;
  this.features._incidentVertex = (this._key & 16711680) >> 16 & 255;
  this.features._flip = (this._key & 4278190080) >> 24 & 255
});
b2ContactID.prototype._key = 0;
b2ContactID.prototype.features = new Features;var b2Transform = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Transform.prototype.__constructor = function(pos, r) {
  if(pos) {
    this.position.SetV(pos);
    this.R.SetM(r)
  }
};
b2Transform.prototype.__varz = function() {
  this.position = new b2Vec2;
  this.R = new b2Mat22
};
b2Transform.prototype.Initialize = function(pos, r) {
  this.position.SetV(pos);
  this.R.SetM(r)
};
b2Transform.prototype.SetIdentity = function() {
  this.position.SetZero();
  this.R.SetIdentity()
};
b2Transform.prototype.Set = function(x) {
  this.position.SetV(x.position);
  this.R.SetM(x.R)
};
b2Transform.prototype.GetAngle = function() {
  return Math.atan2(this.R.col1.y, this.R.col1.x)
};
b2Transform.prototype.position = new b2Vec2;
b2Transform.prototype.R = new b2Mat22;var b2EdgeShape = function() {
  b2Shape.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2EdgeShape.prototype, b2Shape.prototype);
b2EdgeShape.prototype._super = b2Shape.prototype;
b2EdgeShape.prototype.__constructor = function(v1, v2) {
  this._super.__constructor.apply(this, []);
  this.m_type = b2Shape.e_edgeShape;
  this.m_prevEdge = null;
  this.m_nextEdge = null;
  this.m_v1 = v1;
  this.m_v2 = v2;
  this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y);
  this.m_length = this.m_direction.Normalize();
  this.m_normal.Set(this.m_direction.y, -this.m_direction.x);
  this.m_coreV1.Set(-b2Settings.b2_toiSlop * (this.m_normal.x - this.m_direction.x) + this.m_v1.x, -b2Settings.b2_toiSlop * (this.m_normal.y - this.m_direction.y) + this.m_v1.y);
  this.m_coreV2.Set(-b2Settings.b2_toiSlop * (this.m_normal.x + this.m_direction.x) + this.m_v2.x, -b2Settings.b2_toiSlop * (this.m_normal.y + this.m_direction.y) + this.m_v2.y);
  this.m_cornerDir1 = this.m_normal;
  this.m_cornerDir2.Set(-this.m_normal.x, -this.m_normal.y)
};
b2EdgeShape.prototype.__varz = function() {
  this.s_supportVec = new b2Vec2;
  this.m_v1 = new b2Vec2;
  this.m_v2 = new b2Vec2;
  this.m_coreV1 = new b2Vec2;
  this.m_coreV2 = new b2Vec2;
  this.m_normal = new b2Vec2;
  this.m_direction = new b2Vec2;
  this.m_cornerDir1 = new b2Vec2;
  this.m_cornerDir2 = new b2Vec2
};
b2EdgeShape.prototype.SetPrevEdge = function(edge, core, cornerDir, convex) {
  this.m_prevEdge = edge;
  this.m_coreV1 = core;
  this.m_cornerDir1 = cornerDir;
  this.m_cornerConvex1 = convex
};
b2EdgeShape.prototype.SetNextEdge = function(edge, core, cornerDir, convex) {
  this.m_nextEdge = edge;
  this.m_coreV2 = core;
  this.m_cornerDir2 = cornerDir;
  this.m_cornerConvex2 = convex
};
b2EdgeShape.prototype.TestPoint = function(transform, p) {
  return false
};
b2EdgeShape.prototype.RayCast = function(output, input, transform) {
  var tMat;
  var rX = input.p2.x - input.p1.x;
  var rY = input.p2.y - input.p1.y;
  tMat = transform.R;
  var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
  var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
  var nX = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y) - v1Y;
  var nY = -(transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y) - v1X);
  var k_slop = 100 * Number.MIN_VALUE;
  var denom = -(rX * nX + rY * nY);
  if(denom > k_slop) {
    var bX = input.p1.x - v1X;
    var bY = input.p1.y - v1Y;
    var a = bX * nX + bY * nY;
    if(0 <= a && a <= input.maxFraction * denom) {
      var mu2 = -rX * bY + rY * bX;
      if(-k_slop * denom <= mu2 && mu2 <= denom * (1 + k_slop)) {
        a /= denom;
        output.fraction = a;
        var nLen = Math.sqrt(nX * nX + nY * nY);
        output.normal.x = nX / nLen;
        output.normal.y = nY / nLen;
        return true
      }
    }
  }
  return false
};
b2EdgeShape.prototype.ComputeAABB = function(aabb, transform) {
  var tMat = transform.R;
  var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
  var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
  var v2X = transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y);
  var v2Y = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y);
  if(v1X < v2X) {
    aabb.lowerBound.x = v1X;
    aabb.upperBound.x = v2X
  }else {
    aabb.lowerBound.x = v2X;
    aabb.upperBound.x = v1X
  }
  if(v1Y < v2Y) {
    aabb.lowerBound.y = v1Y;
    aabb.upperBound.y = v2Y
  }else {
    aabb.lowerBound.y = v2Y;
    aabb.upperBound.y = v1Y
  }
};
b2EdgeShape.prototype.ComputeMass = function(massData, density) {
  massData.mass = 0;
  massData.center.SetV(this.m_v1);
  massData.I = 0
};
b2EdgeShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  var v0 = new b2Vec2(normal.x * offset, normal.y * offset);
  var v1 = b2Math.MulX(xf, this.m_v1);
  var v2 = b2Math.MulX(xf, this.m_v2);
  var d1 = b2Math.Dot(normal, v1) - offset;
  var d2 = b2Math.Dot(normal, v2) - offset;
  if(d1 > 0) {
    if(d2 > 0) {
      return 0
    }else {
      v1.x = -d2 / (d1 - d2) * v1.x + d1 / (d1 - d2) * v2.x;
      v1.y = -d2 / (d1 - d2) * v1.y + d1 / (d1 - d2) * v2.y
    }
  }else {
    if(d2 > 0) {
      v2.x = -d2 / (d1 - d2) * v1.x + d1 / (d1 - d2) * v2.x;
      v2.y = -d2 / (d1 - d2) * v1.y + d1 / (d1 - d2) * v2.y
    }else {
    }
  }
  c.x = (v0.x + v1.x + v2.x) / 3;
  c.y = (v0.y + v1.y + v2.y) / 3;
  return 0.5 * ((v1.x - v0.x) * (v2.y - v0.y) - (v1.y - v0.y) * (v2.x - v0.x))
};
b2EdgeShape.prototype.GetLength = function() {
  return this.m_length
};
b2EdgeShape.prototype.GetVertex1 = function() {
  return this.m_v1
};
b2EdgeShape.prototype.GetVertex2 = function() {
  return this.m_v2
};
b2EdgeShape.prototype.GetCoreVertex1 = function() {
  return this.m_coreV1
};
b2EdgeShape.prototype.GetCoreVertex2 = function() {
  return this.m_coreV2
};
b2EdgeShape.prototype.GetNormalVector = function() {
  return this.m_normal
};
b2EdgeShape.prototype.GetDirectionVector = function() {
  return this.m_direction
};
b2EdgeShape.prototype.GetCorner1Vector = function() {
  return this.m_cornerDir1
};
b2EdgeShape.prototype.GetCorner2Vector = function() {
  return this.m_cornerDir2
};
b2EdgeShape.prototype.Corner1IsConvex = function() {
  return this.m_cornerConvex1
};
b2EdgeShape.prototype.Corner2IsConvex = function() {
  return this.m_cornerConvex2
};
b2EdgeShape.prototype.GetFirstVertex = function(xf) {
  var tMat = xf.R;
  return new b2Vec2(xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y), xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y))
};
b2EdgeShape.prototype.GetNextEdge = function() {
  return this.m_nextEdge
};
b2EdgeShape.prototype.GetPrevEdge = function() {
  return this.m_prevEdge
};
b2EdgeShape.prototype.Support = function(xf, dX, dY) {
  var tMat = xf.R;
  var v1X = xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y);
  var v1Y = xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y);
  var v2X = xf.position.x + (tMat.col1.x * this.m_coreV2.x + tMat.col2.x * this.m_coreV2.y);
  var v2Y = xf.position.y + (tMat.col1.y * this.m_coreV2.x + tMat.col2.y * this.m_coreV2.y);
  if(v1X * dX + v1Y * dY > v2X * dX + v2Y * dY) {
    this.s_supportVec.x = v1X;
    this.s_supportVec.y = v1Y
  }else {
    this.s_supportVec.x = v2X;
    this.s_supportVec.y = v2Y
  }
  return this.s_supportVec
};
b2EdgeShape.prototype.s_supportVec = new b2Vec2;
b2EdgeShape.prototype.m_v1 = new b2Vec2;
b2EdgeShape.prototype.m_v2 = new b2Vec2;
b2EdgeShape.prototype.m_coreV1 = new b2Vec2;
b2EdgeShape.prototype.m_coreV2 = new b2Vec2;
b2EdgeShape.prototype.m_length = null;
b2EdgeShape.prototype.m_normal = new b2Vec2;
b2EdgeShape.prototype.m_direction = new b2Vec2;
b2EdgeShape.prototype.m_cornerDir1 = new b2Vec2;
b2EdgeShape.prototype.m_cornerDir2 = new b2Vec2;
b2EdgeShape.prototype.m_cornerConvex1 = null;
b2EdgeShape.prototype.m_cornerConvex2 = null;
b2EdgeShape.prototype.m_nextEdge = null;
b2EdgeShape.prototype.m_prevEdge = null;var b2BuoyancyController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2BuoyancyController.prototype, b2Controller.prototype);
b2BuoyancyController.prototype._super = b2Controller.prototype;
b2BuoyancyController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2BuoyancyController.prototype.__varz = function() {
  this.normal = new b2Vec2(0, -1);
  this.velocity = new b2Vec2(0, 0)
};
b2BuoyancyController.prototype.Step = function(step) {
  if(!m_bodyList) {
    return
  }
  if(this.useWorldGravity) {
    this.gravity = this.GetWorld().GetGravity().Copy()
  }
  for(var i = m_bodyList;i;i = i.nextBody) {
    var body = i.body;
    if(body.IsAwake() == false) {
      continue
    }
    var areac = new b2Vec2;
    var massc = new b2Vec2;
    var area = 0;
    var mass = 0;
    for(var fixture = body.GetFixtureList();fixture;fixture = fixture.GetNext()) {
      var sc = new b2Vec2;
      var sarea = fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, body.GetTransform(), sc);
      area += sarea;
      areac.x += sarea * sc.x;
      areac.y += sarea * sc.y;
      var shapeDensity;
      if(this.useDensity) {
        shapeDensity = 1
      }else {
        shapeDensity = 1
      }
      mass += sarea * shapeDensity;
      massc.x += sarea * sc.x * shapeDensity;
      massc.y += sarea * sc.y * shapeDensity
    }
    areac.x /= area;
    areac.y /= area;
    massc.x /= mass;
    massc.y /= mass;
    if(area < Number.MIN_VALUE) {
      continue
    }
    var buoyancyForce = this.gravity.GetNegative();
    buoyancyForce.Multiply(this.density * area);
    body.ApplyForce(buoyancyForce, massc);
    var dragForce = body.GetLinearVelocityFromWorldPoint(areac);
    dragForce.Subtract(this.velocity);
    dragForce.Multiply(-this.linearDrag * area);
    body.ApplyForce(dragForce, areac);
    body.ApplyTorque(-body.GetInertia() / body.GetMass() * area * body.GetAngularVelocity() * this.angularDrag)
  }
};
b2BuoyancyController.prototype.Draw = function(debugDraw) {
  var r = 1E3;
  var p1 = new b2Vec2;
  var p2 = new b2Vec2;
  p1.x = this.normal.x * this.offset + this.normal.y * r;
  p1.y = this.normal.y * this.offset - this.normal.x * r;
  p2.x = this.normal.x * this.offset - this.normal.y * r;
  p2.y = this.normal.y * this.offset + this.normal.x * r;
  var color = new b2Color(0, 0, 1);
  debugDraw.DrawSegment(p1, p2, color)
};
b2BuoyancyController.prototype.normal = new b2Vec2(0, -1);
b2BuoyancyController.prototype.offset = 0;
b2BuoyancyController.prototype.density = 0;
b2BuoyancyController.prototype.velocity = new b2Vec2(0, 0);
b2BuoyancyController.prototype.linearDrag = 2;
b2BuoyancyController.prototype.angularDrag = 1;
b2BuoyancyController.prototype.useDensity = false;
b2BuoyancyController.prototype.useWorldGravity = true;
b2BuoyancyController.prototype.gravity = null;var b2Body = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Body.prototype.__constructor = function(bd, world) {
  this.m_flags = 0;
  if(bd.bullet) {
    this.m_flags |= b2Body.e_bulletFlag
  }
  if(bd.fixedRotation) {
    this.m_flags |= b2Body.e_fixedRotationFlag
  }
  if(bd.allowSleep) {
    this.m_flags |= b2Body.e_allowSleepFlag
  }
  if(bd.awake) {
    this.m_flags |= b2Body.e_awakeFlag
  }
  if(bd.active) {
    this.m_flags |= b2Body.e_activeFlag
  }
  this.m_world = world;
  this.m_xf.position.SetV(bd.position);
  this.m_xf.R.Set(bd.angle);
  this.m_sweep.localCenter.SetZero();
  this.m_sweep.t0 = 1;
  this.m_sweep.a0 = this.m_sweep.a = bd.angle;
  var tMat = this.m_xf.R;
  var tVec = this.m_sweep.localCenter;
  this.m_sweep.c.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
  this.m_sweep.c.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
  this.m_sweep.c.x += this.m_xf.position.x;
  this.m_sweep.c.y += this.m_xf.position.y;
  this.m_sweep.c0.SetV(this.m_sweep.c);
  this.m_jointList = null;
  this.m_controllerList = null;
  this.m_contactList = null;
  this.m_controllerCount = 0;
  this.m_prev = null;
  this.m_next = null;
  this.m_linearVelocity.SetV(bd.linearVelocity);
  this.m_angularVelocity = bd.angularVelocity;
  this.m_linearDamping = bd.linearDamping;
  this.m_angularDamping = bd.angularDamping;
  this.m_force.Set(0, 0);
  this.m_torque = 0;
  this.m_sleepTime = 0;
  this.m_type = bd.type;
  if(this.m_type == b2Body.b2_dynamicBody) {
    this.m_mass = 1;
    this.m_invMass = 1
  }else {
    this.m_mass = 0;
    this.m_invMass = 0
  }
  this.m_I = 0;
  this.m_invI = 0;
  this.m_inertiaScale = bd.inertiaScale;
  this.m_userData = bd.userData;
  this.m_fixtureList = null;
  this.m_fixtureCount = 0
};
b2Body.prototype.__varz = function() {
  this.m_xf = new b2Transform;
  this.m_sweep = new b2Sweep;
  this.m_linearVelocity = new b2Vec2;
  this.m_force = new b2Vec2
};
b2Body.b2_staticBody = 0;
b2Body.b2_kinematicBody = 1;
b2Body.b2_dynamicBody = 2;
b2Body.s_xf1 = new b2Transform;
b2Body.e_islandFlag = 1;
b2Body.e_awakeFlag = 2;
b2Body.e_allowSleepFlag = 4;
b2Body.e_bulletFlag = 8;
b2Body.e_fixedRotationFlag = 16;
b2Body.e_activeFlag = 32;
b2Body.prototype.connectEdges = function(s1, s2, angle1) {
  var angle2 = Math.atan2(s2.GetDirectionVector().y, s2.GetDirectionVector().x);
  var coreOffset = Math.tan((angle2 - angle1) * 0.5);
  var core = b2Math.MulFV(coreOffset, s2.GetDirectionVector());
  core = b2Math.SubtractVV(core, s2.GetNormalVector());
  core = b2Math.MulFV(b2Settings.b2_toiSlop, core);
  core = b2Math.AddVV(core, s2.GetVertex1());
  var cornerDir = b2Math.AddVV(s1.GetDirectionVector(), s2.GetDirectionVector());
  cornerDir.Normalize();
  var convex = b2Math.Dot(s1.GetDirectionVector(), s2.GetNormalVector()) > 0;
  s1.SetNextEdge(s2, core, cornerDir, convex);
  s2.SetPrevEdge(s1, core, cornerDir, convex);
  return angle2
};
b2Body.prototype.SynchronizeFixtures = function() {
  var xf1 = b2Body.s_xf1;
  xf1.R.Set(this.m_sweep.a0);
  var tMat = xf1.R;
  var tVec = this.m_sweep.localCenter;
  xf1.position.x = this.m_sweep.c0.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  xf1.position.y = this.m_sweep.c0.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var f;
  var broadPhase = this.m_world.m_contactManager.m_broadPhase;
  for(f = this.m_fixtureList;f;f = f.m_next) {
    f.Synchronize(broadPhase, xf1, this.m_xf)
  }
};
b2Body.prototype.SynchronizeTransform = function() {
  this.m_xf.R.Set(this.m_sweep.a);
  var tMat = this.m_xf.R;
  var tVec = this.m_sweep.localCenter;
  this.m_xf.position.x = this.m_sweep.c.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  this.m_xf.position.y = this.m_sweep.c.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y)
};
b2Body.prototype.ShouldCollide = function(other) {
  if(this.m_type != b2Body.b2_dynamicBody && other.m_type != b2Body.b2_dynamicBody) {
    return false
  }
  for(var jn = this.m_jointList;jn;jn = jn.next) {
    if(jn.other == other) {
      if(jn.joint.m_collideConnected == false) {
        return false
      }
    }
  }
  return true
};
b2Body.prototype.Advance = function(t) {
  this.m_sweep.Advance(t);
  this.m_sweep.c.SetV(this.m_sweep.c0);
  this.m_sweep.a = this.m_sweep.a0;
  this.SynchronizeTransform()
};
b2Body.prototype.CreateFixture = function(def) {
  if(this.m_world.IsLocked() == true) {
    return null
  }
  var fixture = new b2Fixture;
  fixture.Create(this, this.m_xf, def);
  if(this.m_flags & b2Body.e_activeFlag) {
    var broadPhase = this.m_world.m_contactManager.m_broadPhase;
    fixture.CreateProxy(broadPhase, this.m_xf)
  }
  fixture.m_next = this.m_fixtureList;
  this.m_fixtureList = fixture;
  ++this.m_fixtureCount;
  fixture.m_body = this;
  if(fixture.m_density > 0) {
    this.ResetMassData()
  }
  this.m_world.m_flags |= b2World.e_newFixture;
  return fixture
};
b2Body.prototype.CreateFixture2 = function(shape, density) {
  var def = new b2FixtureDef;
  def.shape = shape;
  def.density = density;
  return this.CreateFixture(def)
};
b2Body.prototype.DestroyFixture = function(fixture) {
  if(this.m_world.IsLocked() == true) {
    return
  }
  var node = this.m_fixtureList;
  var ppF = null;
  var found = false;
  while(node != null) {
    if(node == fixture) {
      if(ppF) {
        ppF.m_next = fixture.m_next
      }else {
        this.m_fixtureList = fixture.m_next
      }
      found = true;
      break
    }
    ppF = node;
    node = node.m_next
  }
  var edge = this.m_contactList;
  while(edge) {
    var c = edge.contact;
    edge = edge.next;
    var fixtureA = c.GetFixtureA();
    var fixtureB = c.GetFixtureB();
    if(fixture == fixtureA || fixture == fixtureB) {
      this.m_world.m_contactManager.Destroy(c)
    }
  }
  if(this.m_flags & b2Body.e_activeFlag) {
    var broadPhase = this.m_world.m_contactManager.m_broadPhase;
    fixture.DestroyProxy(broadPhase)
  }else {
  }
  fixture.Destroy();
  fixture.m_body = null;
  fixture.m_next = null;
  --this.m_fixtureCount;
  this.ResetMassData()
};
b2Body.prototype.SetPositionAndAngle = function(position, angle) {
  var f;
  if(this.m_world.IsLocked() == true) {
    return
  }
  this.m_xf.R.Set(angle);
  this.m_xf.position.SetV(position);
  var tMat = this.m_xf.R;
  var tVec = this.m_sweep.localCenter;
  this.m_sweep.c.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
  this.m_sweep.c.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
  this.m_sweep.c.x += this.m_xf.position.x;
  this.m_sweep.c.y += this.m_xf.position.y;
  this.m_sweep.c0.SetV(this.m_sweep.c);
  this.m_sweep.a0 = this.m_sweep.a = angle;
  var broadPhase = this.m_world.m_contactManager.m_broadPhase;
  for(f = this.m_fixtureList;f;f = f.m_next) {
    f.Synchronize(broadPhase, this.m_xf, this.m_xf)
  }
  this.m_world.m_contactManager.FindNewContacts()
};
b2Body.prototype.SetTransform = function(xf) {
  this.SetPositionAndAngle(xf.position, xf.GetAngle())
};
b2Body.prototype.GetTransform = function() {
  return this.m_xf
};
b2Body.prototype.GetPosition = function() {
  return this.m_xf.position
};
b2Body.prototype.SetPosition = function(position) {
  this.SetPositionAndAngle(position, this.GetAngle())
};
b2Body.prototype.GetAngle = function() {
  return this.m_sweep.a
};
b2Body.prototype.SetAngle = function(angle) {
  this.SetPositionAndAngle(this.GetPosition(), angle)
};
b2Body.prototype.GetWorldCenter = function() {
  return this.m_sweep.c
};
b2Body.prototype.GetLocalCenter = function() {
  return this.m_sweep.localCenter
};
b2Body.prototype.SetLinearVelocity = function(v) {
  if(this.m_type == b2Body.b2_staticBody) {
    return
  }
  this.m_linearVelocity.SetV(v)
};
b2Body.prototype.GetLinearVelocity = function() {
  return this.m_linearVelocity
};
b2Body.prototype.SetAngularVelocity = function(omega) {
  if(this.m_type == b2Body.b2_staticBody) {
    return
  }
  this.m_angularVelocity = omega
};
b2Body.prototype.GetAngularVelocity = function() {
  return this.m_angularVelocity
};
b2Body.prototype.GetDefinition = function() {
  var bd = new b2BodyDef;
  bd.type = this.GetType();
  bd.allowSleep = (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
  bd.angle = this.GetAngle();
  bd.angularDamping = this.m_angularDamping;
  bd.angularVelocity = this.m_angularVelocity;
  bd.fixedRotation = (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
  bd.bullet = (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
  bd.awake = (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
  bd.linearDamping = this.m_linearDamping;
  bd.linearVelocity.SetV(this.GetLinearVelocity());
  bd.position = this.GetPosition();
  bd.userData = this.GetUserData();
  return bd
};
b2Body.prototype.ApplyForce = function(force, point) {
  if(this.m_type != b2Body.b2_dynamicBody) {
    return
  }
  if(this.IsAwake() == false) {
    this.SetAwake(true)
  }
  this.m_force.x += force.x;
  this.m_force.y += force.y;
  this.m_torque += (point.x - this.m_sweep.c.x) * force.y - (point.y - this.m_sweep.c.y) * force.x
};
b2Body.prototype.ApplyTorque = function(torque) {
  if(this.m_type != b2Body.b2_dynamicBody) {
    return
  }
  if(this.IsAwake() == false) {
    this.SetAwake(true)
  }
  this.m_torque += torque
};
b2Body.prototype.ApplyImpulse = function(impulse, point) {
  if(this.m_type != b2Body.b2_dynamicBody) {
    return
  }
  if(this.IsAwake() == false) {
    this.SetAwake(true)
  }
  this.m_linearVelocity.x += this.m_invMass * impulse.x;
  this.m_linearVelocity.y += this.m_invMass * impulse.y;
  this.m_angularVelocity += this.m_invI * ((point.x - this.m_sweep.c.x) * impulse.y - (point.y - this.m_sweep.c.y) * impulse.x)
};
b2Body.prototype.Split = function(callback) {
  var linearVelocity = this.GetLinearVelocity().Copy();
  var angularVelocity = this.GetAngularVelocity();
  var center = this.GetWorldCenter();
  var body1 = this;
  var body2 = this.m_world.CreateBody(this.GetDefinition());
  var prev;
  for(var f = body1.m_fixtureList;f;) {
    if(callback(f)) {
      var next = f.m_next;
      if(prev) {
        prev.m_next = next
      }else {
        body1.m_fixtureList = next
      }
      body1.m_fixtureCount--;
      f.m_next = body2.m_fixtureList;
      body2.m_fixtureList = f;
      body2.m_fixtureCount++;
      f.m_body = body2;
      f = next
    }else {
      prev = f;
      f = f.m_next
    }
  }
  body1.ResetMassData();
  body2.ResetMassData();
  var center1 = body1.GetWorldCenter();
  var center2 = body2.GetWorldCenter();
  var velocity1 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center1, center)));
  var velocity2 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center2, center)));
  body1.SetLinearVelocity(velocity1);
  body2.SetLinearVelocity(velocity2);
  body1.SetAngularVelocity(angularVelocity);
  body2.SetAngularVelocity(angularVelocity);
  body1.SynchronizeFixtures();
  body2.SynchronizeFixtures();
  return body2
};
b2Body.prototype.Merge = function(other) {
  var f;
  for(f = other.m_fixtureList;f;) {
    var next = f.m_next;
    other.m_fixtureCount--;
    f.m_next = this.m_fixtureList;
    this.m_fixtureList = f;
    this.m_fixtureCount++;
    f.m_body = body2;
    f = next
  }
  body1.m_fixtureCount = 0;
  var body1 = this;
  var body2 = other;
  var center1 = body1.GetWorldCenter();
  var center2 = body2.GetWorldCenter();
  var velocity1 = body1.GetLinearVelocity().Copy();
  var velocity2 = body2.GetLinearVelocity().Copy();
  var angular1 = body1.GetAngularVelocity();
  var angular = body2.GetAngularVelocity();
  body1.ResetMassData();
  this.SynchronizeFixtures()
};
b2Body.prototype.GetMass = function() {
  return this.m_mass
};
b2Body.prototype.GetInertia = function() {
  return this.m_I
};
b2Body.prototype.GetMassData = function(data) {
  data.mass = this.m_mass;
  data.I = this.m_I;
  data.center.SetV(this.m_sweep.localCenter)
};
b2Body.prototype.SetMassData = function(massData) {
  b2Settings.b2Assert(this.m_world.IsLocked() == false);
  if(this.m_world.IsLocked() == true) {
    return
  }
  if(this.m_type != b2Body.b2_dynamicBody) {
    return
  }
  this.m_invMass = 0;
  this.m_I = 0;
  this.m_invI = 0;
  this.m_mass = massData.mass;
  if(this.m_mass <= 0) {
    this.m_mass = 1
  }
  this.m_invMass = 1 / this.m_mass;
  if(massData.I > 0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
    this.m_I = massData.I - this.m_mass * (massData.center.x * massData.center.x + massData.center.y * massData.center.y);
    this.m_invI = 1 / this.m_I
  }
  var oldCenter = this.m_sweep.c.Copy();
  this.m_sweep.localCenter.SetV(massData.center);
  this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
  this.m_sweep.c.SetV(this.m_sweep.c0);
  this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - oldCenter.y);
  this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - oldCenter.x)
};
b2Body.prototype.ResetMassData = function() {
  this.m_mass = 0;
  this.m_invMass = 0;
  this.m_I = 0;
  this.m_invI = 0;
  this.m_sweep.localCenter.SetZero();
  if(this.m_type == b2Body.b2_staticBody || this.m_type == b2Body.b2_kinematicBody) {
    return
  }
  var center = b2Vec2.Make(0, 0);
  for(var f = this.m_fixtureList;f;f = f.m_next) {
    if(f.m_density == 0) {
      continue
    }
    var massData = f.GetMassData();
    this.m_mass += massData.mass;
    center.x += massData.center.x * massData.mass;
    center.y += massData.center.y * massData.mass;
    this.m_I += massData.I
  }
  if(this.m_mass > 0) {
    this.m_invMass = 1 / this.m_mass;
    center.x *= this.m_invMass;
    center.y *= this.m_invMass
  }else {
    this.m_mass = 1;
    this.m_invMass = 1
  }
  if(this.m_I > 0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
    this.m_I -= this.m_mass * (center.x * center.x + center.y * center.y);
    this.m_I *= this.m_inertiaScale;
    b2Settings.b2Assert(this.m_I > 0);
    this.m_invI = 1 / this.m_I
  }else {
    this.m_I = 0;
    this.m_invI = 0
  }
  var oldCenter = this.m_sweep.c.Copy();
  this.m_sweep.localCenter.SetV(center);
  this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
  this.m_sweep.c.SetV(this.m_sweep.c0);
  this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - oldCenter.y);
  this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - oldCenter.x)
};
b2Body.prototype.GetWorldPoint = function(localPoint) {
  var A = this.m_xf.R;
  var u = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
  u.x += this.m_xf.position.x;
  u.y += this.m_xf.position.y;
  return u
};
b2Body.prototype.GetWorldVector = function(localVector) {
  return b2Math.MulMV(this.m_xf.R, localVector)
};
b2Body.prototype.GetLocalPoint = function(worldPoint) {
  return b2Math.MulXT(this.m_xf, worldPoint)
};
b2Body.prototype.GetLocalVector = function(worldVector) {
  return b2Math.MulTMV(this.m_xf.R, worldVector)
};
b2Body.prototype.GetLinearVelocityFromWorldPoint = function(worldPoint) {
  return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x))
};
b2Body.prototype.GetLinearVelocityFromLocalPoint = function(localPoint) {
  var A = this.m_xf.R;
  var worldPoint = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
  worldPoint.x += this.m_xf.position.x;
  worldPoint.y += this.m_xf.position.y;
  return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x))
};
b2Body.prototype.GetLinearDamping = function() {
  return this.m_linearDamping
};
b2Body.prototype.SetLinearDamping = function(linearDamping) {
  this.m_linearDamping = linearDamping
};
b2Body.prototype.GetAngularDamping = function() {
  return this.m_angularDamping
};
b2Body.prototype.SetAngularDamping = function(angularDamping) {
  this.m_angularDamping = angularDamping
};
b2Body.prototype.SetType = function(type) {
  if(this.m_type == type) {
    return
  }
  this.m_type = type;
  this.ResetMassData();
  if(this.m_type == b2Body.b2_staticBody) {
    this.m_linearVelocity.SetZero();
    this.m_angularVelocity = 0
  }
  this.SetAwake(true);
  this.m_force.SetZero();
  this.m_torque = 0;
  for(var ce = this.m_contactList;ce;ce = ce.next) {
    ce.contact.FlagForFiltering()
  }
};
b2Body.prototype.GetType = function() {
  return this.m_type
};
b2Body.prototype.SetBullet = function(flag) {
  if(flag) {
    this.m_flags |= b2Body.e_bulletFlag
  }else {
    this.m_flags &= ~b2Body.e_bulletFlag
  }
};
b2Body.prototype.IsBullet = function() {
  return(this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag
};
b2Body.prototype.SetSleepingAllowed = function(flag) {
  if(flag) {
    this.m_flags |= b2Body.e_allowSleepFlag
  }else {
    this.m_flags &= ~b2Body.e_allowSleepFlag;
    this.SetAwake(true)
  }
};
b2Body.prototype.SetAwake = function(flag) {
  if(flag) {
    this.m_flags |= b2Body.e_awakeFlag;
    this.m_sleepTime = 0
  }else {
    this.m_flags &= ~b2Body.e_awakeFlag;
    this.m_sleepTime = 0;
    this.m_linearVelocity.SetZero();
    this.m_angularVelocity = 0;
    this.m_force.SetZero();
    this.m_torque = 0
  }
};
b2Body.prototype.IsAwake = function() {
  return(this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag
};
b2Body.prototype.SetFixedRotation = function(fixed) {
  if(fixed) {
    this.m_flags |= b2Body.e_fixedRotationFlag
  }else {
    this.m_flags &= ~b2Body.e_fixedRotationFlag
  }
  this.ResetMassData()
};
b2Body.prototype.IsFixedRotation = function() {
  return(this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag
};
b2Body.prototype.SetActive = function(flag) {
  if(flag == this.IsActive()) {
    return
  }
  var broadPhase;
  var f;
  if(flag) {
    this.m_flags |= b2Body.e_activeFlag;
    broadPhase = this.m_world.m_contactManager.m_broadPhase;
    for(f = this.m_fixtureList;f;f = f.m_next) {
      f.CreateProxy(broadPhase, this.m_xf)
    }
  }else {
    this.m_flags &= ~b2Body.e_activeFlag;
    broadPhase = this.m_world.m_contactManager.m_broadPhase;
    for(f = this.m_fixtureList;f;f = f.m_next) {
      f.DestroyProxy(broadPhase)
    }
    var ce = this.m_contactList;
    while(ce) {
      var ce0 = ce;
      ce = ce.next;
      this.m_world.m_contactManager.Destroy(ce0.contact)
    }
    this.m_contactList = null
  }
};
b2Body.prototype.IsActive = function() {
  return(this.m_flags & b2Body.e_activeFlag) == b2Body.e_activeFlag
};
b2Body.prototype.IsSleepingAllowed = function() {
  return(this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag
};
b2Body.prototype.GetFixtureList = function() {
  return this.m_fixtureList
};
b2Body.prototype.GetJointList = function() {
  return this.m_jointList
};
b2Body.prototype.GetControllerList = function() {
  return this.m_controllerList
};
b2Body.prototype.GetContactList = function() {
  return this.m_contactList
};
b2Body.prototype.GetNext = function() {
  return this.m_next
};
b2Body.prototype.GetUserData = function() {
  return this.m_userData
};
b2Body.prototype.SetUserData = function(data) {
  this.m_userData = data
};
b2Body.prototype.GetWorld = function() {
  return this.m_world
};
b2Body.prototype.m_flags = 0;
b2Body.prototype.m_type = 0;
b2Body.prototype.m_islandIndex = 0;
b2Body.prototype.m_xf = new b2Transform;
b2Body.prototype.m_sweep = new b2Sweep;
b2Body.prototype.m_linearVelocity = new b2Vec2;
b2Body.prototype.m_angularVelocity = null;
b2Body.prototype.m_force = new b2Vec2;
b2Body.prototype.m_torque = null;
b2Body.prototype.m_world = null;
b2Body.prototype.m_prev = null;
b2Body.prototype.m_next = null;
b2Body.prototype.m_fixtureList = null;
b2Body.prototype.m_fixtureCount = 0;
b2Body.prototype.m_controllerList = null;
b2Body.prototype.m_controllerCount = 0;
b2Body.prototype.m_jointList = null;
b2Body.prototype.m_contactList = null;
b2Body.prototype.m_mass = null;
b2Body.prototype.m_invMass = null;
b2Body.prototype.m_I = null;
b2Body.prototype.m_invI = null;
b2Body.prototype.m_inertiaScale = null;
b2Body.prototype.m_linearDamping = null;
b2Body.prototype.m_angularDamping = null;
b2Body.prototype.m_sleepTime = null;
b2Body.prototype.m_userData = null;var b2ContactImpulse = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactImpulse.prototype.__constructor = function() {
};
b2ContactImpulse.prototype.__varz = function() {
  this.normalImpulses = new Array(b2Settings.b2_maxManifoldPoints);
  this.tangentImpulses = new Array(b2Settings.b2_maxManifoldPoints)
};
b2ContactImpulse.prototype.normalImpulses = new Array(b2Settings.b2_maxManifoldPoints);
b2ContactImpulse.prototype.tangentImpulses = new Array(b2Settings.b2_maxManifoldPoints);var b2TensorDampingController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2TensorDampingController.prototype, b2Controller.prototype);
b2TensorDampingController.prototype._super = b2Controller.prototype;
b2TensorDampingController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2TensorDampingController.prototype.__varz = function() {
  this.T = new b2Mat22
};
b2TensorDampingController.prototype.SetAxisAligned = function(xDamping, yDamping) {
  this.T.col1.x = -xDamping;
  this.T.col1.y = 0;
  this.T.col2.x = 0;
  this.T.col2.y = -yDamping;
  if(xDamping > 0 || yDamping > 0) {
    this.maxTimestep = 1 / Math.max(xDamping, yDamping)
  }else {
    this.maxTimestep = 0
  }
};
b2TensorDampingController.prototype.Step = function(step) {
  var timestep = step.dt;
  if(timestep <= Number.MIN_VALUE) {
    return
  }
  if(timestep > this.maxTimestep && this.maxTimestep > 0) {
    timestep = this.maxTimestep
  }
  for(var i = m_bodyList;i;i = i.nextBody) {
    var body = i.body;
    if(!body.IsAwake()) {
      continue
    }
    var damping = body.GetWorldVector(b2Math.MulMV(this.T, body.GetLocalVector(body.GetLinearVelocity())));
    body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + damping.x * timestep, body.GetLinearVelocity().y + damping.y * timestep))
  }
};
b2TensorDampingController.prototype.T = new b2Mat22;
b2TensorDampingController.prototype.maxTimestep = 0;var b2ManifoldPoint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ManifoldPoint.prototype.__constructor = function() {
  this.Reset()
};
b2ManifoldPoint.prototype.__varz = function() {
  this.m_localPoint = new b2Vec2;
  this.m_id = new b2ContactID
};
b2ManifoldPoint.prototype.Reset = function() {
  this.m_localPoint.SetZero();
  this.m_normalImpulse = 0;
  this.m_tangentImpulse = 0;
  this.m_id.key = 0
};
b2ManifoldPoint.prototype.Set = function(m) {
  this.m_localPoint.SetV(m.m_localPoint);
  this.m_normalImpulse = m.m_normalImpulse;
  this.m_tangentImpulse = m.m_tangentImpulse;
  this.m_id.Set(m.m_id)
};
b2ManifoldPoint.prototype.m_localPoint = new b2Vec2;
b2ManifoldPoint.prototype.m_normalImpulse = null;
b2ManifoldPoint.prototype.m_tangentImpulse = null;
b2ManifoldPoint.prototype.m_id = new b2ContactID;var b2PolygonShape = function() {
  b2Shape.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PolygonShape.prototype, b2Shape.prototype);
b2PolygonShape.prototype._super = b2Shape.prototype;
b2PolygonShape.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.m_type = b2Shape.e_polygonShape;
  this.m_centroid = new b2Vec2;
  this.m_vertices = new Array;
  this.m_normals = new Array
};
b2PolygonShape.prototype.__varz = function() {
};
b2PolygonShape.AsArray = function(vertices, vertexCount) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsArray(vertices, vertexCount);
  return polygonShape
};
b2PolygonShape.AsVector = function(vertices, vertexCount) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsVector(vertices, vertexCount);
  return polygonShape
};
b2PolygonShape.AsBox = function(hx, hy) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsBox(hx, hy);
  return polygonShape
};
b2PolygonShape.AsOrientedBox = function(hx, hy, center, angle) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsOrientedBox(hx, hy, center, angle);
  return polygonShape
};
b2PolygonShape.AsEdge = function(v1, v2) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsEdge(v1, v2);
  return polygonShape
};
b2PolygonShape.ComputeCentroid = function(vs, count) {
  var c = new b2Vec2;
  var area = 0;
  var p1X = 0;
  var p1Y = 0;
  var inv3 = 1 / 3;
  for(var i = 0;i < count;++i) {
    var p2 = vs[i];
    var p3 = i + 1 < count ? vs[parseInt(i + 1)] : vs[0];
    var e1X = p2.x - p1X;
    var e1Y = p2.y - p1Y;
    var e2X = p3.x - p1X;
    var e2Y = p3.y - p1Y;
    var D = e1X * e2Y - e1Y * e2X;
    var triangleArea = 0.5 * D;
    area += triangleArea;
    c.x += triangleArea * inv3 * (p1X + p2.x + p3.x);
    c.y += triangleArea * inv3 * (p1Y + p2.y + p3.y)
  }
  c.x *= 1 / area;
  c.y *= 1 / area;
  return c
};
b2PolygonShape.ComputeOBB = function(obb, vs, count) {
  var i = 0;
  var p = new Array(count + 1);
  for(i = 0;i < count;++i) {
    p[i] = vs[i]
  }
  p[count] = p[0];
  var minArea = Number.MAX_VALUE;
  for(i = 1;i <= count;++i) {
    var root = p[parseInt(i - 1)];
    var uxX = p[i].x - root.x;
    var uxY = p[i].y - root.y;
    var length = Math.sqrt(uxX * uxX + uxY * uxY);
    uxX /= length;
    uxY /= length;
    var uyX = -uxY;
    var uyY = uxX;
    var lowerX = Number.MAX_VALUE;
    var lowerY = Number.MAX_VALUE;
    var upperX = -Number.MAX_VALUE;
    var upperY = -Number.MAX_VALUE;
    for(var j = 0;j < count;++j) {
      var dX = p[j].x - root.x;
      var dY = p[j].y - root.y;
      var rX = uxX * dX + uxY * dY;
      var rY = uyX * dX + uyY * dY;
      if(rX < lowerX) {
        lowerX = rX
      }
      if(rY < lowerY) {
        lowerY = rY
      }
      if(rX > upperX) {
        upperX = rX
      }
      if(rY > upperY) {
        upperY = rY
      }
    }
    var area = (upperX - lowerX) * (upperY - lowerY);
    if(area < 0.95 * minArea) {
      minArea = area;
      obb.R.col1.x = uxX;
      obb.R.col1.y = uxY;
      obb.R.col2.x = uyX;
      obb.R.col2.y = uyY;
      var centerX = 0.5 * (lowerX + upperX);
      var centerY = 0.5 * (lowerY + upperY);
      var tMat = obb.R;
      obb.center.x = root.x + (tMat.col1.x * centerX + tMat.col2.x * centerY);
      obb.center.y = root.y + (tMat.col1.y * centerX + tMat.col2.y * centerY);
      obb.extents.x = 0.5 * (upperX - lowerX);
      obb.extents.y = 0.5 * (upperY - lowerY)
    }
  }
};
b2PolygonShape.s_mat = new b2Mat22;
b2PolygonShape.prototype.Validate = function() {
  return false
};
b2PolygonShape.prototype.Reserve = function(count) {
  for(var i = this.m_vertices.length;i < count;i++) {
    this.m_vertices[i] = new b2Vec2;
    this.m_normals[i] = new b2Vec2
  }
};
b2PolygonShape.prototype.Copy = function() {
  var s = new b2PolygonShape;
  s.Set(this);
  return s
};
b2PolygonShape.prototype.Set = function(other) {
  this._super.Set.apply(this, [other]);
  if(isInstanceOf(other, b2PolygonShape)) {
    var other2 = other;
    this.m_centroid.SetV(other2.m_centroid);
    this.m_vertexCount = other2.m_vertexCount;
    this.Reserve(this.m_vertexCount);
    for(var i = 0;i < this.m_vertexCount;i++) {
      this.m_vertices[i].SetV(other2.m_vertices[i]);
      this.m_normals[i].SetV(other2.m_normals[i])
    }
  }
};
b2PolygonShape.prototype.SetAsArray = function(vertices, vertexCount) {
  var v = new Array;
  for(var i = 0, tVec = null;i < vertices.length, tVec = vertices[i];i++) {
    v.push(tVec)
  }
  this.SetAsVector(v, vertexCount)
};
b2PolygonShape.prototype.SetAsVector = function(vertices, vertexCount) {
  if(typeof vertexCount == "undefined") {
    vertexCount = vertices.length
  }
  b2Settings.b2Assert(2 <= vertexCount);
  this.m_vertexCount = vertexCount;
  this.Reserve(vertexCount);
  var i = 0;
  for(i = 0;i < this.m_vertexCount;i++) {
    this.m_vertices[i].SetV(vertices[i])
  }
  for(i = 0;i < this.m_vertexCount;++i) {
    var i1 = i;
    var i2 = i + 1 < this.m_vertexCount ? i + 1 : 0;
    var edge = b2Math.SubtractVV(this.m_vertices[i2], this.m_vertices[i1]);
    b2Settings.b2Assert(edge.LengthSquared() > Number.MIN_VALUE);
    this.m_normals[i].SetV(b2Math.CrossVF(edge, 1));
    this.m_normals[i].Normalize()
  }
  this.m_centroid = b2PolygonShape.ComputeCentroid(this.m_vertices, this.m_vertexCount)
};
b2PolygonShape.prototype.SetAsBox = function(hx, hy) {
  this.m_vertexCount = 4;
  this.Reserve(4);
  this.m_vertices[0].Set(-hx, -hy);
  this.m_vertices[1].Set(hx, -hy);
  this.m_vertices[2].Set(hx, hy);
  this.m_vertices[3].Set(-hx, hy);
  this.m_normals[0].Set(0, -1);
  this.m_normals[1].Set(1, 0);
  this.m_normals[2].Set(0, 1);
  this.m_normals[3].Set(-1, 0);
  this.m_centroid.SetZero()
};
b2PolygonShape.prototype.SetAsOrientedBox = function(hx, hy, center, angle) {
  this.m_vertexCount = 4;
  this.Reserve(4);
  this.m_vertices[0].Set(-hx, -hy);
  this.m_vertices[1].Set(hx, -hy);
  this.m_vertices[2].Set(hx, hy);
  this.m_vertices[3].Set(-hx, hy);
  this.m_normals[0].Set(0, -1);
  this.m_normals[1].Set(1, 0);
  this.m_normals[2].Set(0, 1);
  this.m_normals[3].Set(-1, 0);
  this.m_centroid = center;
  var xf = new b2Transform;
  xf.position = center;
  xf.R.Set(angle);
  for(var i = 0;i < this.m_vertexCount;++i) {
    this.m_vertices[i] = b2Math.MulX(xf, this.m_vertices[i]);
    this.m_normals[i] = b2Math.MulMV(xf.R, this.m_normals[i])
  }
};
b2PolygonShape.prototype.SetAsEdge = function(v1, v2) {
  this.m_vertexCount = 2;
  this.Reserve(2);
  this.m_vertices[0].SetV(v1);
  this.m_vertices[1].SetV(v2);
  this.m_centroid.x = 0.5 * (v1.x + v2.x);
  this.m_centroid.y = 0.5 * (v1.y + v2.y);
  this.m_normals[0] = b2Math.CrossVF(b2Math.SubtractVV(v2, v1), 1);
  this.m_normals[0].Normalize();
  this.m_normals[1].x = -this.m_normals[0].x;
  this.m_normals[1].y = -this.m_normals[0].y
};
b2PolygonShape.prototype.TestPoint = function(xf, p) {
  var tVec;
  var tMat = xf.R;
  var tX = p.x - xf.position.x;
  var tY = p.y - xf.position.y;
  var pLocalX = tX * tMat.col1.x + tY * tMat.col1.y;
  var pLocalY = tX * tMat.col2.x + tY * tMat.col2.y;
  for(var i = 0;i < this.m_vertexCount;++i) {
    tVec = this.m_vertices[i];
    tX = pLocalX - tVec.x;
    tY = pLocalY - tVec.y;
    tVec = this.m_normals[i];
    var dot = tVec.x * tX + tVec.y * tY;
    if(dot > 0) {
      return false
    }
  }
  return true
};
b2PolygonShape.prototype.RayCast = function(output, input, transform) {
  var lower = 0;
  var upper = input.maxFraction;
  var tX;
  var tY;
  var tMat;
  var tVec;
  tX = input.p1.x - transform.position.x;
  tY = input.p1.y - transform.position.y;
  tMat = transform.R;
  var p1X = tX * tMat.col1.x + tY * tMat.col1.y;
  var p1Y = tX * tMat.col2.x + tY * tMat.col2.y;
  tX = input.p2.x - transform.position.x;
  tY = input.p2.y - transform.position.y;
  tMat = transform.R;
  var p2X = tX * tMat.col1.x + tY * tMat.col1.y;
  var p2Y = tX * tMat.col2.x + tY * tMat.col2.y;
  var dX = p2X - p1X;
  var dY = p2Y - p1Y;
  var index = -1;
  for(var i = 0;i < this.m_vertexCount;++i) {
    tVec = this.m_vertices[i];
    tX = tVec.x - p1X;
    tY = tVec.y - p1Y;
    tVec = this.m_normals[i];
    var numerator = tVec.x * tX + tVec.y * tY;
    var denominator = tVec.x * dX + tVec.y * dY;
    if(denominator == 0) {
      if(numerator < 0) {
        return false
      }
    }else {
      if(denominator < 0 && numerator < lower * denominator) {
        lower = numerator / denominator;
        index = i
      }else {
        if(denominator > 0 && numerator < upper * denominator) {
          upper = numerator / denominator
        }
      }
    }
    if(upper < lower - Number.MIN_VALUE) {
      return false
    }
  }
  if(index >= 0) {
    output.fraction = lower;
    tMat = transform.R;
    tVec = this.m_normals[index];
    output.normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
    output.normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
    return true
  }
  return false
};
b2PolygonShape.prototype.ComputeAABB = function(aabb, xf) {
  var tMat = xf.R;
  var tVec = this.m_vertices[0];
  var lowerX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var lowerY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var upperX = lowerX;
  var upperY = lowerY;
  for(var i = 1;i < this.m_vertexCount;++i) {
    tVec = this.m_vertices[i];
    var vX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    var vY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    lowerX = lowerX < vX ? lowerX : vX;
    lowerY = lowerY < vY ? lowerY : vY;
    upperX = upperX > vX ? upperX : vX;
    upperY = upperY > vY ? upperY : vY
  }
  aabb.lowerBound.x = lowerX - this.m_radius;
  aabb.lowerBound.y = lowerY - this.m_radius;
  aabb.upperBound.x = upperX + this.m_radius;
  aabb.upperBound.y = upperY + this.m_radius
};
b2PolygonShape.prototype.ComputeMass = function(massData, density) {
  if(this.m_vertexCount == 2) {
    massData.center.x = 0.5 * (this.m_vertices[0].x + this.m_vertices[1].x);
    massData.center.y = 0.5 * (this.m_vertices[0].y + this.m_vertices[1].y);
    massData.mass = 0;
    massData.I = 0;
    return
  }
  var centerX = 0;
  var centerY = 0;
  var area = 0;
  var I = 0;
  var p1X = 0;
  var p1Y = 0;
  var k_inv3 = 1 / 3;
  for(var i = 0;i < this.m_vertexCount;++i) {
    var p2 = this.m_vertices[i];
    var p3 = i + 1 < this.m_vertexCount ? this.m_vertices[parseInt(i + 1)] : this.m_vertices[0];
    var e1X = p2.x - p1X;
    var e1Y = p2.y - p1Y;
    var e2X = p3.x - p1X;
    var e2Y = p3.y - p1Y;
    var D = e1X * e2Y - e1Y * e2X;
    var triangleArea = 0.5 * D;
    area += triangleArea;
    centerX += triangleArea * k_inv3 * (p1X + p2.x + p3.x);
    centerY += triangleArea * k_inv3 * (p1Y + p2.y + p3.y);
    var px = p1X;
    var py = p1Y;
    var ex1 = e1X;
    var ey1 = e1Y;
    var ex2 = e2X;
    var ey2 = e2Y;
    var intx2 = k_inv3 * (0.25 * (ex1 * ex1 + ex2 * ex1 + ex2 * ex2) + (px * ex1 + px * ex2)) + 0.5 * px * px;
    var inty2 = k_inv3 * (0.25 * (ey1 * ey1 + ey2 * ey1 + ey2 * ey2) + (py * ey1 + py * ey2)) + 0.5 * py * py;
    I += D * (intx2 + inty2)
  }
  massData.mass = density * area;
  centerX *= 1 / area;
  centerY *= 1 / area;
  massData.center.Set(centerX, centerY);
  massData.I = density * I
};
b2PolygonShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  var normalL = b2Math.MulTMV(xf.R, normal);
  var offsetL = offset - b2Math.Dot(normal, xf.position);
  var depths = new Array;
  var diveCount = 0;
  var intoIndex = -1;
  var outoIndex = -1;
  var lastSubmerged = false;
  var i = 0;
  for(i = 0;i < this.m_vertexCount;++i) {
    depths[i] = b2Math.Dot(normalL, this.m_vertices[i]) - offsetL;
    var isSubmerged = depths[i] < -Number.MIN_VALUE;
    if(i > 0) {
      if(isSubmerged) {
        if(!lastSubmerged) {
          intoIndex = i - 1;
          diveCount++
        }
      }else {
        if(lastSubmerged) {
          outoIndex = i - 1;
          diveCount++
        }
      }
    }
    lastSubmerged = isSubmerged
  }
  switch(diveCount) {
    case 0:
      if(lastSubmerged) {
        var md = new b2MassData;
        this.ComputeMass(md, 1);
        c.SetV(b2Math.MulX(xf, md.center));
        return md.mass
      }else {
        return 0
      }
      break;
    case 1:
      if(intoIndex == -1) {
        intoIndex = this.m_vertexCount - 1
      }else {
        outoIndex = this.m_vertexCount - 1
      }
      break
  }
  var intoIndex2 = (intoIndex + 1) % this.m_vertexCount;
  var outoIndex2 = (outoIndex + 1) % this.m_vertexCount;
  var intoLamdda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);
  var outoLamdda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);
  var intoVec = new b2Vec2(this.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda, this.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);
  var outoVec = new b2Vec2(this.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda, this.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);
  var area = 0;
  var center = new b2Vec2;
  var p2 = this.m_vertices[intoIndex2];
  var p3;
  i = intoIndex2;
  while(i != outoIndex2) {
    i = (i + 1) % this.m_vertexCount;
    if(i == outoIndex2) {
      p3 = outoVec
    }else {
      p3 = this.m_vertices[i]
    }
    var triangleArea = 0.5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));
    area += triangleArea;
    center.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;
    center.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;
    p2 = p3
  }
  center.Multiply(1 / area);
  c.SetV(b2Math.MulX(xf, center));
  return area
};
b2PolygonShape.prototype.GetVertexCount = function() {
  return this.m_vertexCount
};
b2PolygonShape.prototype.GetVertices = function() {
  return this.m_vertices
};
b2PolygonShape.prototype.GetNormals = function() {
  return this.m_normals
};
b2PolygonShape.prototype.GetSupport = function(d) {
  var bestIndex = 0;
  var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for(var i = 1;i < this.m_vertexCount;++i) {
    var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if(value > bestValue) {
      bestIndex = i;
      bestValue = value
    }
  }
  return bestIndex
};
b2PolygonShape.prototype.GetSupportVertex = function(d) {
  var bestIndex = 0;
  var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for(var i = 1;i < this.m_vertexCount;++i) {
    var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if(value > bestValue) {
      bestIndex = i;
      bestValue = value
    }
  }
  return this.m_vertices[bestIndex]
};
b2PolygonShape.prototype.m_centroid = null;
b2PolygonShape.prototype.m_vertices = null;
b2PolygonShape.prototype.m_normals = null;
b2PolygonShape.prototype.m_vertexCount = 0;var b2Fixture = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Fixture.prototype.__constructor = function() {
  this.m_aabb = new b2AABB;
  this.m_userData = null;
  this.m_body = null;
  this.m_next = null;
  this.m_shape = null;
  this.m_density = 0;
  this.m_friction = 0;
  this.m_restitution = 0
};
b2Fixture.prototype.__varz = function() {
  this.m_filter = new b2FilterData
};
b2Fixture.prototype.Create = function(body, xf, def) {
  this.m_userData = def.userData;
  this.m_friction = def.friction;
  this.m_restitution = def.restitution;
  this.m_body = body;
  this.m_next = null;
  this.m_filter = def.filter.Copy();
  this.m_isSensor = def.isSensor;
  this.m_shape = def.shape.Copy();
  this.m_density = def.density
};
b2Fixture.prototype.Destroy = function() {
  this.m_shape = null
};
b2Fixture.prototype.CreateProxy = function(broadPhase, xf) {
  this.m_shape.ComputeAABB(this.m_aabb, xf);
  this.m_proxy = broadPhase.CreateProxy(this.m_aabb, this)
};
b2Fixture.prototype.DestroyProxy = function(broadPhase) {
  if(this.m_proxy == null) {
    return
  }
  broadPhase.DestroyProxy(this.m_proxy);
  this.m_proxy = null
};
b2Fixture.prototype.Synchronize = function(broadPhase, transform1, transform2) {
  if(!this.m_proxy) {
    return
  }
  var aabb1 = new b2AABB;
  var aabb2 = new b2AABB;
  this.m_shape.ComputeAABB(aabb1, transform1);
  this.m_shape.ComputeAABB(aabb2, transform2);
  this.m_aabb.Combine(aabb1, aabb2);
  var displacement = b2Math.SubtractVV(transform2.position, transform1.position);
  broadPhase.MoveProxy(this.m_proxy, this.m_aabb, displacement)
};
b2Fixture.prototype.GetType = function() {
  return this.m_shape.GetType()
};
b2Fixture.prototype.GetShape = function() {
  return this.m_shape
};
b2Fixture.prototype.SetSensor = function(sensor) {
  if(this.m_isSensor == sensor) {
    return
  }
  this.m_isSensor = sensor;
  if(this.m_body == null) {
    return
  }
  var edge = this.m_body.GetContactList();
  while(edge) {
    var contact = edge.contact;
    var fixtureA = contact.GetFixtureA();
    var fixtureB = contact.GetFixtureB();
    if(fixtureA == this || fixtureB == this) {
      contact.SetSensor(fixtureA.IsSensor() || fixtureB.IsSensor())
    }
    edge = edge.next
  }
};
b2Fixture.prototype.IsSensor = function() {
  return this.m_isSensor
};
b2Fixture.prototype.SetFilterData = function(filter) {
  this.m_filter = filter.Copy();
  if(this.m_body) {
    return
  }
  var edge = this.m_body.GetContactList();
  while(edge) {
    var contact = edge.contact;
    var fixtureA = contact.GetFixtureA();
    var fixtureB = contact.GetFixtureB();
    if(fixtureA == this || fixtureB == this) {
      contact.FlagForFiltering()
    }
    edge = edge.next
  }
};
b2Fixture.prototype.GetFilterData = function() {
  return this.m_filter.Copy()
};
b2Fixture.prototype.GetBody = function() {
  return this.m_body
};
b2Fixture.prototype.GetNext = function() {
  return this.m_next
};
b2Fixture.prototype.GetUserData = function() {
  return this.m_userData
};
b2Fixture.prototype.SetUserData = function(data) {
  this.m_userData = data
};
b2Fixture.prototype.TestPoint = function(p) {
  return this.m_shape.TestPoint(this.m_body.GetTransform(), p)
};
b2Fixture.prototype.RayCast = function(output, input) {
  return this.m_shape.RayCast(output, input, this.m_body.GetTransform())
};
b2Fixture.prototype.GetMassData = function(massData) {
  if(massData == null) {
    massData = new b2MassData
  }
  this.m_shape.ComputeMass(massData, this.m_density);
  return massData
};
b2Fixture.prototype.SetDensity = function(density) {
  this.m_density = density
};
b2Fixture.prototype.GetDensity = function() {
  return this.m_density
};
b2Fixture.prototype.GetFriction = function() {
  return this.m_friction
};
b2Fixture.prototype.SetFriction = function(friction) {
  this.m_friction = friction
};
b2Fixture.prototype.GetRestitution = function() {
  return this.m_restitution
};
b2Fixture.prototype.SetRestitution = function(restitution) {
  this.m_restitution = restitution
};
b2Fixture.prototype.GetAABB = function() {
  return this.m_aabb
};
b2Fixture.prototype.m_massData = null;
b2Fixture.prototype.m_aabb = null;
b2Fixture.prototype.m_density = null;
b2Fixture.prototype.m_next = null;
b2Fixture.prototype.m_body = null;
b2Fixture.prototype.m_shape = null;
b2Fixture.prototype.m_friction = null;
b2Fixture.prototype.m_restitution = null;
b2Fixture.prototype.m_proxy = null;
b2Fixture.prototype.m_filter = new b2FilterData;
b2Fixture.prototype.m_isSensor = null;
b2Fixture.prototype.m_userData = null;var b2DynamicTreeNode = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DynamicTreeNode.prototype.__constructor = function() {
};
b2DynamicTreeNode.prototype.__varz = function() {
  this.aabb = new b2AABB
};
b2DynamicTreeNode.prototype.IsLeaf = function() {
  return this.child1 == null
};
b2DynamicTreeNode.prototype.userData = null;
b2DynamicTreeNode.prototype.aabb = new b2AABB;
b2DynamicTreeNode.prototype.parent = null;
b2DynamicTreeNode.prototype.child1 = null;
b2DynamicTreeNode.prototype.child2 = null;var b2BodyDef = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2BodyDef.prototype.__constructor = function() {
  this.userData = null;
  this.position.Set(0, 0);
  this.angle = 0;
  this.linearVelocity.Set(0, 0);
  this.angularVelocity = 0;
  this.linearDamping = 0;
  this.angularDamping = 0;
  this.allowSleep = true;
  this.awake = true;
  this.fixedRotation = false;
  this.bullet = false;
  this.type = b2Body.b2_staticBody;
  this.active = true;
  this.inertiaScale = 1
};
b2BodyDef.prototype.__varz = function() {
  this.position = new b2Vec2;
  this.linearVelocity = new b2Vec2
};
b2BodyDef.prototype.type = 0;
b2BodyDef.prototype.position = new b2Vec2;
b2BodyDef.prototype.angle = null;
b2BodyDef.prototype.linearVelocity = new b2Vec2;
b2BodyDef.prototype.angularVelocity = null;
b2BodyDef.prototype.linearDamping = null;
b2BodyDef.prototype.angularDamping = null;
b2BodyDef.prototype.allowSleep = null;
b2BodyDef.prototype.awake = null;
b2BodyDef.prototype.fixedRotation = null;
b2BodyDef.prototype.bullet = null;
b2BodyDef.prototype.active = null;
b2BodyDef.prototype.userData = null;
b2BodyDef.prototype.inertiaScale = null;var b2DynamicTreeBroadPhase = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DynamicTreeBroadPhase.prototype.__constructor = function() {
};
b2DynamicTreeBroadPhase.prototype.__varz = function() {
  this.m_tree = new b2DynamicTree;
  this.m_moveBuffer = new Array;
  this.m_pairBuffer = new Array
};
b2DynamicTreeBroadPhase.prototype.BufferMove = function(proxy) {
  this.m_moveBuffer[this.m_moveBuffer.length] = proxy
};
b2DynamicTreeBroadPhase.prototype.UnBufferMove = function(proxy) {
  var i = this.m_moveBuffer.indexOf(proxy);
  this.m_moveBuffer.splice(i, 1)
};
b2DynamicTreeBroadPhase.prototype.ComparePairs = function(pair1, pair2) {
  return 0
};
b2DynamicTreeBroadPhase.prototype.CreateProxy = function(aabb, userData) {
  var proxy = this.m_tree.CreateProxy(aabb, userData);
  ++this.m_proxyCount;
  this.BufferMove(proxy);
  return proxy
};
b2DynamicTreeBroadPhase.prototype.DestroyProxy = function(proxy) {
  this.UnBufferMove(proxy);
  --this.m_proxyCount;
  this.m_tree.DestroyProxy(proxy)
};
b2DynamicTreeBroadPhase.prototype.MoveProxy = function(proxy, aabb, displacement) {
  var buffer = this.m_tree.MoveProxy(proxy, aabb, displacement);
  if(buffer) {
    this.BufferMove(proxy)
  }
};
b2DynamicTreeBroadPhase.prototype.TestOverlap = function(proxyA, proxyB) {
  var aabbA = this.m_tree.GetFatAABB(proxyA);
  var aabbB = this.m_tree.GetFatAABB(proxyB);
  return aabbA.TestOverlap(aabbB)
};
b2DynamicTreeBroadPhase.prototype.GetUserData = function(proxy) {
  return this.m_tree.GetUserData(proxy)
};
b2DynamicTreeBroadPhase.prototype.GetFatAABB = function(proxy) {
  return this.m_tree.GetFatAABB(proxy)
};
b2DynamicTreeBroadPhase.prototype.GetProxyCount = function() {
  return this.m_proxyCount
};
b2DynamicTreeBroadPhase.prototype.UpdatePairs = function(callback) {
  this.m_pairCount = 0;
  for(var i = 0, queryProxy = null;i < this.m_moveBuffer.length, queryProxy = this.m_moveBuffer[i];i++) {
    var that = this;
    function QueryCallback(proxy) {
      if(proxy == queryProxy) {
        return true
      }
      if(that.m_pairCount == that.m_pairBuffer.length) {
        that.m_pairBuffer[that.m_pairCount] = new b2DynamicTreePair
      }
      var pair = that.m_pairBuffer[that.m_pairCount];
      pair.proxyA = proxy < queryProxy ? proxy : queryProxy;
      pair.proxyB = proxy >= queryProxy ? proxy : queryProxy;
      ++that.m_pairCount;
      return true
    }
    var fatAABB = this.m_tree.GetFatAABB(queryProxy);
    this.m_tree.Query(QueryCallback, fatAABB)
  }
  this.m_moveBuffer.length = 0;
  for(var i = 0;i < this.m_pairCount;) {
    var primaryPair = this.m_pairBuffer[i];
    var userDataA = this.m_tree.GetUserData(primaryPair.proxyA);
    var userDataB = this.m_tree.GetUserData(primaryPair.proxyB);
    callback(userDataA, userDataB);
    ++i;
    while(i < this.m_pairCount) {
      var pair = this.m_pairBuffer[i];
      if(pair.proxyA != primaryPair.proxyA || pair.proxyB != primaryPair.proxyB) {
        break
      }
      ++i
    }
  }
};
b2DynamicTreeBroadPhase.prototype.Query = function(callback, aabb) {
  this.m_tree.Query(callback, aabb)
};
b2DynamicTreeBroadPhase.prototype.RayCast = function(callback, input) {
  this.m_tree.RayCast(callback, input)
};
b2DynamicTreeBroadPhase.prototype.Validate = function() {
};
b2DynamicTreeBroadPhase.prototype.Rebalance = function(iterations) {
  this.m_tree.Rebalance(iterations)
};
b2DynamicTreeBroadPhase.prototype.m_tree = new b2DynamicTree;
b2DynamicTreeBroadPhase.prototype.m_proxyCount = 0;
b2DynamicTreeBroadPhase.prototype.m_moveBuffer = new Array;
b2DynamicTreeBroadPhase.prototype.m_pairBuffer = new Array;
b2DynamicTreeBroadPhase.prototype.m_pairCount = 0;var b2BroadPhase = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2BroadPhase.prototype.__constructor = function(worldAABB) {
  var i = 0;
  this.m_pairManager.Initialize(this);
  this.m_worldAABB = worldAABB;
  this.m_proxyCount = 0;
  this.m_bounds = new Array;
  for(i = 0;i < 2;i++) {
    this.m_bounds[i] = new Array
  }
  var dX = worldAABB.upperBound.x - worldAABB.lowerBound.x;
  var dY = worldAABB.upperBound.y - worldAABB.lowerBound.y;
  this.m_quantizationFactor.x = b2Settings.USHRT_MAX / dX;
  this.m_quantizationFactor.y = b2Settings.USHRT_MAX / dY;
  this.m_timeStamp = 1;
  this.m_queryResultCount = 0
};
b2BroadPhase.prototype.__varz = function() {
  this.m_pairManager = new b2PairManager;
  this.m_proxyPool = new Array;
  this.m_querySortKeys = new Array;
  this.m_queryResults = new Array;
  this.m_quantizationFactor = new b2Vec2
};
b2BroadPhase.BinarySearch = function(bounds, count, value) {
  var low = 0;
  var high = count - 1;
  while(low <= high) {
    var mid = Math.round((low + high) / 2);
    var bound = bounds[mid];
    if(bound.value > value) {
      high = mid - 1
    }else {
      if(bound.value < value) {
        low = mid + 1
      }else {
        return parseInt(mid)
      }
    }
  }
  return parseInt(low)
};
b2BroadPhase.s_validate = false;
b2BroadPhase.b2_invalid = b2Settings.USHRT_MAX;
b2BroadPhase.b2_nullEdge = b2Settings.USHRT_MAX;
b2BroadPhase.prototype.ComputeBounds = function(lowerValues, upperValues, aabb) {
  var minVertexX = aabb.lowerBound.x;
  var minVertexY = aabb.lowerBound.y;
  minVertexX = b2Math.Min(minVertexX, this.m_worldAABB.upperBound.x);
  minVertexY = b2Math.Min(minVertexY, this.m_worldAABB.upperBound.y);
  minVertexX = b2Math.Max(minVertexX, this.m_worldAABB.lowerBound.x);
  minVertexY = b2Math.Max(minVertexY, this.m_worldAABB.lowerBound.y);
  var maxVertexX = aabb.upperBound.x;
  var maxVertexY = aabb.upperBound.y;
  maxVertexX = b2Math.Min(maxVertexX, this.m_worldAABB.upperBound.x);
  maxVertexY = b2Math.Min(maxVertexY, this.m_worldAABB.upperBound.y);
  maxVertexX = b2Math.Max(maxVertexX, this.m_worldAABB.lowerBound.x);
  maxVertexY = b2Math.Max(maxVertexY, this.m_worldAABB.lowerBound.y);
  lowerValues[0] = parseInt(this.m_quantizationFactor.x * (minVertexX - this.m_worldAABB.lowerBound.x)) & b2Settings.USHRT_MAX - 1;
  upperValues[0] = parseInt(this.m_quantizationFactor.x * (maxVertexX - this.m_worldAABB.lowerBound.x)) % 65535 | 1;
  lowerValues[1] = parseInt(this.m_quantizationFactor.y * (minVertexY - this.m_worldAABB.lowerBound.y)) & b2Settings.USHRT_MAX - 1;
  upperValues[1] = parseInt(this.m_quantizationFactor.y * (maxVertexY - this.m_worldAABB.lowerBound.y)) % 65535 | 1
};
b2BroadPhase.prototype.TestOverlapValidate = function(p1, p2) {
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var bound1 = bounds[p1.lowerBounds[axis]];
    var bound2 = bounds[p2.upperBounds[axis]];
    if(bound1.value > bound2.value) {
      return false
    }
    bound1 = bounds[p1.upperBounds[axis]];
    bound2 = bounds[p2.lowerBounds[axis]];
    if(bound1.value < bound2.value) {
      return false
    }
  }
  return true
};
b2BroadPhase.prototype.QueryAxis = function(lowerQueryOut, upperQueryOut, lowerValue, upperValue, bounds, boundCount, axis) {
  var lowerQuery = b2BroadPhase.BinarySearch(bounds, boundCount, lowerValue);
  var upperQuery = b2BroadPhase.BinarySearch(bounds, boundCount, upperValue);
  var bound;
  for(var j = lowerQuery;j < upperQuery;++j) {
    bound = bounds[j];
    if(bound.IsLower()) {
      this.IncrementOverlapCount(bound.proxy)
    }
  }
  if(lowerQuery > 0) {
    var i = lowerQuery - 1;
    bound = bounds[i];
    var s = bound.stabbingCount;
    while(s) {
      bound = bounds[i];
      if(bound.IsLower()) {
        var proxy = bound.proxy;
        if(lowerQuery <= proxy.upperBounds[axis]) {
          this.IncrementOverlapCount(bound.proxy);
          --s
        }
      }
      --i
    }
  }
  lowerQueryOut[0] = lowerQuery;
  upperQueryOut[0] = upperQuery
};
b2BroadPhase.prototype.IncrementOverlapCount = function(proxy) {
  if(proxy.timeStamp < this.m_timeStamp) {
    proxy.timeStamp = this.m_timeStamp;
    proxy.overlapCount = 1
  }else {
    proxy.overlapCount = 2;
    this.m_queryResults[this.m_queryResultCount] = proxy;
    ++this.m_queryResultCount
  }
};
b2BroadPhase.prototype.IncrementTimeStamp = function() {
  if(this.m_timeStamp == b2Settings.USHRT_MAX) {
    for(var i = 0;i < this.m_proxyPool.length;++i) {
      this.m_proxyPool[i].timeStamp = 0
    }
    this.m_timeStamp = 1
  }else {
    ++this.m_timeStamp
  }
};
b2BroadPhase.prototype.InRange = function(aabb) {
  var dX;
  var dY;
  var d2X;
  var d2Y;
  dX = aabb.lowerBound.x;
  dY = aabb.lowerBound.y;
  dX -= this.m_worldAABB.upperBound.x;
  dY -= this.m_worldAABB.upperBound.y;
  d2X = this.m_worldAABB.lowerBound.x;
  d2Y = this.m_worldAABB.lowerBound.y;
  d2X -= aabb.upperBound.x;
  d2Y -= aabb.upperBound.y;
  dX = b2Math.Max(dX, d2X);
  dY = b2Math.Max(dY, d2Y);
  return b2Math.Max(dX, dY) < 0
};
b2BroadPhase.prototype.CreateProxy = function(aabb, userData) {
  var index = 0;
  var proxy;
  var i = 0;
  var j = 0;
  if(!this.m_freeProxy) {
    this.m_freeProxy = this.m_proxyPool[this.m_proxyCount] = new b2Proxy;
    this.m_freeProxy.next = null;
    this.m_freeProxy.timeStamp = 0;
    this.m_freeProxy.overlapCount = b2BroadPhase.b2_invalid;
    this.m_freeProxy.userData = null;
    for(i = 0;i < 2;i++) {
      j = this.m_proxyCount * 2;
      this.m_bounds[i][j++] = new b2Bound;
      this.m_bounds[i][j] = new b2Bound
    }
  }
  proxy = this.m_freeProxy;
  this.m_freeProxy = proxy.next;
  proxy.overlapCount = 0;
  proxy.userData = userData;
  var boundCount = 2 * this.m_proxyCount;
  var lowerValues = new Array;
  var upperValues = new Array;
  this.ComputeBounds(lowerValues, upperValues, aabb);
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var lowerIndex = 0;
    var upperIndex = 0;
    var lowerIndexOut = new Array;
    lowerIndexOut.push(lowerIndex);
    var upperIndexOut = new Array;
    upperIndexOut.push(upperIndex);
    this.QueryAxis(lowerIndexOut, upperIndexOut, lowerValues[axis], upperValues[axis], bounds, boundCount, axis);
    lowerIndex = lowerIndexOut[0];
    upperIndex = upperIndexOut[0];
    bounds.splice(upperIndex, 0, bounds[bounds.length - 1]);
    bounds.length--;
    bounds.splice(lowerIndex, 0, bounds[bounds.length - 1]);
    bounds.length--;
    ++upperIndex;
    var tBound1 = bounds[lowerIndex];
    var tBound2 = bounds[upperIndex];
    tBound1.value = lowerValues[axis];
    tBound1.proxy = proxy;
    tBound2.value = upperValues[axis];
    tBound2.proxy = proxy;
    var tBoundAS3 = bounds[parseInt(lowerIndex - 1)];
    tBound1.stabbingCount = lowerIndex == 0 ? 0 : tBoundAS3.stabbingCount;
    tBoundAS3 = bounds[parseInt(upperIndex - 1)];
    tBound2.stabbingCount = tBoundAS3.stabbingCount;
    for(index = lowerIndex;index < upperIndex;++index) {
      tBoundAS3 = bounds[index];
      tBoundAS3.stabbingCount++
    }
    for(index = lowerIndex;index < boundCount + 2;++index) {
      tBound1 = bounds[index];
      var proxy2 = tBound1.proxy;
      if(tBound1.IsLower()) {
        proxy2.lowerBounds[axis] = index
      }else {
        proxy2.upperBounds[axis] = index
      }
    }
  }
  ++this.m_proxyCount;
  for(i = 0;i < this.m_queryResultCount;++i) {
    this.m_pairManager.AddBufferedPair(proxy, this.m_queryResults[i])
  }
  this.m_queryResultCount = 0;
  this.IncrementTimeStamp();
  return proxy
};
b2BroadPhase.prototype.DestroyProxy = function(proxy_) {
  var proxy = proxy_;
  var tBound1;
  var tBound2;
  var boundCount = 2 * this.m_proxyCount;
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var lowerIndex = proxy.lowerBounds[axis];
    var upperIndex = proxy.upperBounds[axis];
    tBound1 = bounds[lowerIndex];
    var lowerValue = tBound1.value;
    tBound2 = bounds[upperIndex];
    var upperValue = tBound2.value;
    bounds.splice(upperIndex, 1);
    bounds.splice(lowerIndex, 1);
    bounds.push(tBound1);
    bounds.push(tBound2);
    var tEnd = boundCount - 2;
    for(var index = lowerIndex;index < tEnd;++index) {
      tBound1 = bounds[index];
      var proxy2 = tBound1.proxy;
      if(tBound1.IsLower()) {
        proxy2.lowerBounds[axis] = index
      }else {
        proxy2.upperBounds[axis] = index
      }
    }
    tEnd = upperIndex - 1;
    for(var index2 = lowerIndex;index2 < tEnd;++index2) {
      tBound1 = bounds[index2];
      tBound1.stabbingCount--
    }
    var ignore = new Array;
    this.QueryAxis(ignore, ignore, lowerValue, upperValue, bounds, boundCount - 2, axis)
  }
  for(var i = 0;i < this.m_queryResultCount;++i) {
    this.m_pairManager.RemoveBufferedPair(proxy, this.m_queryResults[i])
  }
  this.m_queryResultCount = 0;
  this.IncrementTimeStamp();
  proxy.userData = null;
  proxy.overlapCount = b2BroadPhase.b2_invalid;
  proxy.lowerBounds[0] = b2BroadPhase.b2_invalid;
  proxy.lowerBounds[1] = b2BroadPhase.b2_invalid;
  proxy.upperBounds[0] = b2BroadPhase.b2_invalid;
  proxy.upperBounds[1] = b2BroadPhase.b2_invalid;
  proxy.next = this.m_freeProxy;
  this.m_freeProxy = proxy;
  --this.m_proxyCount
};
b2BroadPhase.prototype.MoveProxy = function(proxy_, aabb, displacement) {
  var proxy = proxy_;
  var as3arr;
  var as3int = 0;
  var axis = 0;
  var index = 0;
  var bound;
  var prevBound;
  var nextBound;
  var nextProxyId = 0;
  var nextProxy;
  if(proxy == null) {
    return
  }
  if(aabb.IsValid() == false) {
    return
  }
  var boundCount = 2 * this.m_proxyCount;
  var newValues = new b2BoundValues;
  this.ComputeBounds(newValues.lowerValues, newValues.upperValues, aabb);
  var oldValues = new b2BoundValues;
  for(axis = 0;axis < 2;++axis) {
    bound = this.m_bounds[axis][proxy.lowerBounds[axis]];
    oldValues.lowerValues[axis] = bound.value;
    bound = this.m_bounds[axis][proxy.upperBounds[axis]];
    oldValues.upperValues[axis] = bound.value
  }
  for(axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var lowerIndex = proxy.lowerBounds[axis];
    var upperIndex = proxy.upperBounds[axis];
    var lowerValue = newValues.lowerValues[axis];
    var upperValue = newValues.upperValues[axis];
    bound = bounds[lowerIndex];
    var deltaLower = lowerValue - bound.value;
    bound.value = lowerValue;
    bound = bounds[upperIndex];
    var deltaUpper = upperValue - bound.value;
    bound.value = upperValue;
    if(deltaLower < 0) {
      index = lowerIndex;
      while(index > 0 && lowerValue < bounds[parseInt(index - 1)].value) {
        bound = bounds[index];
        prevBound = bounds[parseInt(index - 1)];
        var prevProxy = prevBound.proxy;
        prevBound.stabbingCount++;
        if(prevBound.IsUpper() == true) {
          if(this.TestOverlapBound(newValues, prevProxy)) {
            this.m_pairManager.AddBufferedPair(proxy, prevProxy)
          }
          as3arr = prevProxy.upperBounds;
          as3int = as3arr[axis];
          as3int++;
          as3arr[axis] = as3int;
          bound.stabbingCount++
        }else {
          as3arr = prevProxy.lowerBounds;
          as3int = as3arr[axis];
          as3int++;
          as3arr[axis] = as3int;
          bound.stabbingCount--
        }
        as3arr = proxy.lowerBounds;
        as3int = as3arr[axis];
        as3int--;
        as3arr[axis] = as3int;
        bound.Swap(prevBound);
        --index
      }
    }
    if(deltaUpper > 0) {
      index = upperIndex;
      while(index < boundCount - 1 && bounds[parseInt(index + 1)].value <= upperValue) {
        bound = bounds[index];
        nextBound = bounds[parseInt(index + 1)];
        nextProxy = nextBound.proxy;
        nextBound.stabbingCount++;
        if(nextBound.IsLower() == true) {
          if(this.TestOverlapBound(newValues, nextProxy)) {
            this.m_pairManager.AddBufferedPair(proxy, nextProxy)
          }
          as3arr = nextProxy.lowerBounds;
          as3int = as3arr[axis];
          as3int--;
          as3arr[axis] = as3int;
          bound.stabbingCount++
        }else {
          as3arr = nextProxy.upperBounds;
          as3int = as3arr[axis];
          as3int--;
          as3arr[axis] = as3int;
          bound.stabbingCount--
        }
        as3arr = proxy.upperBounds;
        as3int = as3arr[axis];
        as3int++;
        as3arr[axis] = as3int;
        bound.Swap(nextBound);
        index++
      }
    }
    if(deltaLower > 0) {
      index = lowerIndex;
      while(index < boundCount - 1 && bounds[parseInt(index + 1)].value <= lowerValue) {
        bound = bounds[index];
        nextBound = bounds[parseInt(index + 1)];
        nextProxy = nextBound.proxy;
        nextBound.stabbingCount--;
        if(nextBound.IsUpper()) {
          if(this.TestOverlapBound(oldValues, nextProxy)) {
            this.m_pairManager.RemoveBufferedPair(proxy, nextProxy)
          }
          as3arr = nextProxy.upperBounds;
          as3int = as3arr[axis];
          as3int--;
          as3arr[axis] = as3int;
          bound.stabbingCount--
        }else {
          as3arr = nextProxy.lowerBounds;
          as3int = as3arr[axis];
          as3int--;
          as3arr[axis] = as3int;
          bound.stabbingCount++
        }
        as3arr = proxy.lowerBounds;
        as3int = as3arr[axis];
        as3int++;
        as3arr[axis] = as3int;
        bound.Swap(nextBound);
        index++
      }
    }
    if(deltaUpper < 0) {
      index = upperIndex;
      while(index > 0 && upperValue < bounds[parseInt(index - 1)].value) {
        bound = bounds[index];
        prevBound = bounds[parseInt(index - 1)];
        prevProxy = prevBound.proxy;
        prevBound.stabbingCount--;
        if(prevBound.IsLower() == true) {
          if(this.TestOverlapBound(oldValues, prevProxy)) {
            this.m_pairManager.RemoveBufferedPair(proxy, prevProxy)
          }
          as3arr = prevProxy.lowerBounds;
          as3int = as3arr[axis];
          as3int++;
          as3arr[axis] = as3int;
          bound.stabbingCount--
        }else {
          as3arr = prevProxy.upperBounds;
          as3int = as3arr[axis];
          as3int++;
          as3arr[axis] = as3int;
          bound.stabbingCount++
        }
        as3arr = proxy.upperBounds;
        as3int = as3arr[axis];
        as3int--;
        as3arr[axis] = as3int;
        bound.Swap(prevBound);
        index--
      }
    }
  }
};
b2BroadPhase.prototype.UpdatePairs = function(callback) {
  this.m_pairManager.Commit(callback)
};
b2BroadPhase.prototype.TestOverlap = function(proxyA, proxyB) {
  var proxyA_ = proxyA;
  var proxyB_ = proxyB;
  if(proxyA_.lowerBounds[0] > proxyB_.upperBounds[0]) {
    return false
  }
  if(proxyB_.lowerBounds[0] > proxyA_.upperBounds[0]) {
    return false
  }
  if(proxyA_.lowerBounds[1] > proxyB_.upperBounds[1]) {
    return false
  }
  if(proxyB_.lowerBounds[1] > proxyA_.upperBounds[1]) {
    return false
  }
  return true
};
b2BroadPhase.prototype.GetUserData = function(proxy) {
  return proxy.userData
};
b2BroadPhase.prototype.GetFatAABB = function(proxy_) {
  var aabb = new b2AABB;
  var proxy = proxy_;
  aabb.lowerBound.x = this.m_worldAABB.lowerBound.x + this.m_bounds[0][proxy.lowerBounds[0]].value / this.m_quantizationFactor.x;
  aabb.lowerBound.y = this.m_worldAABB.lowerBound.y + this.m_bounds[1][proxy.lowerBounds[1]].value / this.m_quantizationFactor.y;
  aabb.upperBound.x = this.m_worldAABB.lowerBound.x + this.m_bounds[0][proxy.upperBounds[0]].value / this.m_quantizationFactor.x;
  aabb.upperBound.y = this.m_worldAABB.lowerBound.y + this.m_bounds[1][proxy.upperBounds[1]].value / this.m_quantizationFactor.y;
  return aabb
};
b2BroadPhase.prototype.GetProxyCount = function() {
  return this.m_proxyCount
};
b2BroadPhase.prototype.Query = function(callback, aabb) {
  var lowerValues = new Array;
  var upperValues = new Array;
  this.ComputeBounds(lowerValues, upperValues, aabb);
  var lowerIndex = 0;
  var upperIndex = 0;
  var lowerIndexOut = new Array;
  lowerIndexOut.push(lowerIndex);
  var upperIndexOut = new Array;
  upperIndexOut.push(upperIndex);
  this.QueryAxis(lowerIndexOut, upperIndexOut, lowerValues[0], upperValues[0], this.m_bounds[0], 2 * this.m_proxyCount, 0);
  this.QueryAxis(lowerIndexOut, upperIndexOut, lowerValues[1], upperValues[1], this.m_bounds[1], 2 * this.m_proxyCount, 1);
  for(var i = 0;i < this.m_queryResultCount;++i) {
    var proxy = this.m_queryResults[i];
    if(!callback(proxy)) {
      break
    }
  }
  this.m_queryResultCount = 0;
  this.IncrementTimeStamp()
};
b2BroadPhase.prototype.Validate = function() {
  var pair;
  var proxy1;
  var proxy2;
  var overlap;
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var boundCount = 2 * this.m_proxyCount;
    var stabbingCount = 0;
    for(var i = 0;i < boundCount;++i) {
      var bound = bounds[i];
      if(bound.IsLower() == true) {
        stabbingCount++
      }else {
        stabbingCount--
      }
    }
  }
};
b2BroadPhase.prototype.Rebalance = function(iterations) {
};
b2BroadPhase.prototype.RayCast = function(callback, input) {
  var subInput = new b2RayCastInput;
  subInput.p1.SetV(input.p1);
  subInput.p2.SetV(input.p2);
  subInput.maxFraction = input.maxFraction;
  var dx = (input.p2.x - input.p1.x) * this.m_quantizationFactor.x;
  var dy = (input.p2.y - input.p1.y) * this.m_quantizationFactor.y;
  var sx = dx < -Number.MIN_VALUE ? -1 : dx > Number.MIN_VALUE ? 1 : 0;
  var sy = dy < -Number.MIN_VALUE ? -1 : dy > Number.MIN_VALUE ? 1 : 0;
  var p1x = this.m_quantizationFactor.x * (input.p1.x - this.m_worldAABB.lowerBound.x);
  var p1y = this.m_quantizationFactor.y * (input.p1.y - this.m_worldAABB.lowerBound.y);
  var startValues = new Array;
  var startValues2 = new Array;
  startValues[0] = parseInt(p1x) & b2Settings.USHRT_MAX - 1;
  startValues[1] = parseInt(p1y) & b2Settings.USHRT_MAX - 1;
  startValues2[0] = startValues[0] + 1;
  startValues2[1] = startValues[1] + 1;
  var startIndices = new Array;
  var xIndex = 0;
  var yIndex = 0;
  var proxy;
  var lowerIndex = 0;
  var upperIndex = 0;
  var lowerIndexOut = new Array;
  lowerIndexOut.push(lowerIndex);
  var upperIndexOut = new Array;
  upperIndexOut.push(upperIndex);
  this.QueryAxis(lowerIndexOut, upperIndexOut, startValues[0], startValues2[0], this.m_bounds[0], 2 * this.m_proxyCount, 0);
  if(sx >= 0) {
    xIndex = upperIndexOut[0] - 1
  }else {
    xIndex = lowerIndexOut[0]
  }
  this.QueryAxis(lowerIndexOut, upperIndexOut, startValues[1], startValues2[1], this.m_bounds[1], 2 * this.m_proxyCount, 1);
  if(sy >= 0) {
    yIndex = upperIndexOut[0] - 1
  }else {
    yIndex = lowerIndexOut[0]
  }
  for(var i = 0;i < this.m_queryResultCount;i++) {
    subInput.maxFraction = callback(this.m_queryResults[i], subInput)
  }
  for(;;) {
    var xProgress = 0;
    var yProgress = 0;
    xIndex += sx >= 0 ? 1 : -1;
    if(xIndex < 0 || xIndex >= this.m_proxyCount * 2) {
      break
    }
    if(sx != 0) {
      xProgress = (this.m_bounds[0][xIndex].value - p1x) / dx
    }
    yIndex += sy >= 0 ? 1 : -1;
    if(yIndex < 0 || yIndex >= this.m_proxyCount * 2) {
      break
    }
    if(sy != 0) {
      yProgress = (this.m_bounds[1][yIndex].value - p1y) / dy
    }
    for(;;) {
      if(sy == 0 || sx != 0 && xProgress < yProgress) {
        if(xProgress > subInput.maxFraction) {
          break
        }
        if(sx > 0 ? this.m_bounds[0][xIndex].IsLower() : this.m_bounds[0][xIndex].IsUpper()) {
          proxy = this.m_bounds[0][xIndex].proxy;
          if(sy >= 0) {
            if(proxy.lowerBounds[1] <= yIndex - 1 && proxy.upperBounds[1] >= yIndex) {
              subInput.maxFraction = callback(proxy, subInput)
            }
          }else {
            if(proxy.lowerBounds[1] <= yIndex && proxy.upperBounds[1] >= yIndex + 1) {
              subInput.maxFraction = callback(proxy, subInput)
            }
          }
        }
        if(subInput.maxFraction == 0) {
          break
        }
        if(sx > 0) {
          xIndex++;
          if(xIndex == this.m_proxyCount * 2) {
            break
          }
        }else {
          xIndex--;
          if(xIndex < 0) {
            break
          }
        }
        xProgress = (this.m_bounds[0][xIndex].value - p1x) / dx
      }else {
        if(yProgress > subInput.maxFraction) {
          break
        }
        if(sy > 0 ? this.m_bounds[1][yIndex].IsLower() : this.m_bounds[1][yIndex].IsUpper()) {
          proxy = this.m_bounds[1][yIndex].proxy;
          if(sx >= 0) {
            if(proxy.lowerBounds[0] <= xIndex - 1 && proxy.upperBounds[0] >= xIndex) {
              subInput.maxFraction = callback(proxy, subInput)
            }
          }else {
            if(proxy.lowerBounds[0] <= xIndex && proxy.upperBounds[0] >= xIndex + 1) {
              subInput.maxFraction = callback(proxy, subInput)
            }
          }
        }
        if(subInput.maxFraction == 0) {
          break
        }
        if(sy > 0) {
          yIndex++;
          if(yIndex == this.m_proxyCount * 2) {
            break
          }
        }else {
          yIndex--;
          if(yIndex < 0) {
            break
          }
        }
        yProgress = (this.m_bounds[1][yIndex].value - p1y) / dy
      }
    }
    break
  }
  this.m_queryResultCount = 0;
  this.IncrementTimeStamp();
  return
};
b2BroadPhase.prototype.TestOverlapBound = function(b, p) {
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var bound = bounds[p.upperBounds[axis]];
    if(b.lowerValues[axis] > bound.value) {
      return false
    }
    bound = bounds[p.lowerBounds[axis]];
    if(b.upperValues[axis] < bound.value) {
      return false
    }
  }
  return true
};
b2BroadPhase.prototype.m_pairManager = new b2PairManager;
b2BroadPhase.prototype.m_proxyPool = new Array;
b2BroadPhase.prototype.m_freeProxy = null;
b2BroadPhase.prototype.m_bounds = null;
b2BroadPhase.prototype.m_querySortKeys = new Array;
b2BroadPhase.prototype.m_queryResults = new Array;
b2BroadPhase.prototype.m_queryResultCount = 0;
b2BroadPhase.prototype.m_worldAABB = null;
b2BroadPhase.prototype.m_quantizationFactor = new b2Vec2;
b2BroadPhase.prototype.m_proxyCount = 0;
b2BroadPhase.prototype.m_timeStamp = 0;var b2Manifold = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Manifold.prototype.__constructor = function() {
  this.m_points = new Array(b2Settings.b2_maxManifoldPoints);
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i] = new b2ManifoldPoint
  }
  this.m_localPlaneNormal = new b2Vec2;
  this.m_localPoint = new b2Vec2
};
b2Manifold.prototype.__varz = function() {
};
b2Manifold.e_circles = 1;
b2Manifold.e_faceA = 2;
b2Manifold.e_faceB = 4;
b2Manifold.prototype.Reset = function() {
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i].Reset()
  }
  this.m_localPlaneNormal.SetZero();
  this.m_localPoint.SetZero();
  this.m_type = 0;
  this.m_pointCount = 0
};
b2Manifold.prototype.Set = function(m) {
  this.m_pointCount = m.m_pointCount;
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i].Set(m.m_points[i])
  }
  this.m_localPlaneNormal.SetV(m.m_localPlaneNormal);
  this.m_localPoint.SetV(m.m_localPoint);
  this.m_type = m.m_type
};
b2Manifold.prototype.Copy = function() {
  var copy = new b2Manifold;
  copy.Set(this);
  return copy
};
b2Manifold.prototype.m_points = null;
b2Manifold.prototype.m_localPlaneNormal = null;
b2Manifold.prototype.m_localPoint = null;
b2Manifold.prototype.m_type = 0;
b2Manifold.prototype.m_pointCount = 0;var b2CircleShape = function() {
  b2Shape.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2CircleShape.prototype, b2Shape.prototype);
b2CircleShape.prototype._super = b2Shape.prototype;
b2CircleShape.prototype.__constructor = function(radius) {
  this._super.__constructor.apply(this, []);
  this.m_type = b2Shape.e_circleShape;
  this.m_radius = radius
};
b2CircleShape.prototype.__varz = function() {
  this.m_p = new b2Vec2
};
b2CircleShape.prototype.Copy = function() {
  var s = new b2CircleShape;
  s.Set(this);
  return s
};
b2CircleShape.prototype.Set = function(other) {
  this._super.Set.apply(this, [other]);
  if(isInstanceOf(other, b2CircleShape)) {
    var other2 = other;
    this.m_p.SetV(other2.m_p)
  }
};
b2CircleShape.prototype.TestPoint = function(transform, p) {
  var tMat = transform.R;
  var dX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
  var dY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
  dX = p.x - dX;
  dY = p.y - dY;
  return dX * dX + dY * dY <= this.m_radius * this.m_radius
};
b2CircleShape.prototype.RayCast = function(output, input, transform) {
  var tMat = transform.R;
  var positionX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
  var positionY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
  var sX = input.p1.x - positionX;
  var sY = input.p1.y - positionY;
  var b = sX * sX + sY * sY - this.m_radius * this.m_radius;
  var rX = input.p2.x - input.p1.x;
  var rY = input.p2.y - input.p1.y;
  var c = sX * rX + sY * rY;
  var rr = rX * rX + rY * rY;
  var sigma = c * c - rr * b;
  if(sigma < 0 || rr < Number.MIN_VALUE) {
    return false
  }
  var a = -(c + Math.sqrt(sigma));
  if(0 <= a && a <= input.maxFraction * rr) {
    a /= rr;
    output.fraction = a;
    output.normal.x = sX + a * rX;
    output.normal.y = sY + a * rY;
    output.normal.Normalize();
    return true
  }
  return false
};
b2CircleShape.prototype.ComputeAABB = function(aabb, transform) {
  var tMat = transform.R;
  var pX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
  var pY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
  aabb.lowerBound.Set(pX - this.m_radius, pY - this.m_radius);
  aabb.upperBound.Set(pX + this.m_radius, pY + this.m_radius)
};
b2CircleShape.prototype.ComputeMass = function(massData, density) {
  massData.mass = density * b2Settings.b2_pi * this.m_radius * this.m_radius;
  massData.center.SetV(this.m_p);
  massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y))
};
b2CircleShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  var p = b2Math.MulX(xf, this.m_p);
  var l = -(b2Math.Dot(normal, p) - offset);
  if(l < -this.m_radius + Number.MIN_VALUE) {
    return 0
  }
  if(l > this.m_radius) {
    c.SetV(p);
    return Math.PI * this.m_radius * this.m_radius
  }
  var r2 = this.m_radius * this.m_radius;
  var l2 = l * l;
  var area = r2 * (Math.asin(l / this.m_radius) + Math.PI / 2) + l * Math.sqrt(r2 - l2);
  var com = -2 / 3 * Math.pow(r2 - l2, 1.5) / area;
  c.x = p.x + normal.x * com;
  c.y = p.y + normal.y * com;
  return area
};
b2CircleShape.prototype.GetLocalPosition = function() {
  return this.m_p
};
b2CircleShape.prototype.SetLocalPosition = function(position) {
  this.m_p.SetV(position)
};
b2CircleShape.prototype.GetRadius = function() {
  return this.m_radius
};
b2CircleShape.prototype.SetRadius = function(radius) {
  this.m_radius = radius
};
b2CircleShape.prototype.m_p = new b2Vec2;var b2Joint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Joint.prototype.__constructor = function(def) {
  b2Settings.b2Assert(def.bodyA != def.bodyB);
  this.m_type = def.type;
  this.m_prev = null;
  this.m_next = null;
  this.m_bodyA = def.bodyA;
  this.m_bodyB = def.bodyB;
  this.m_collideConnected = def.collideConnected;
  this.m_islandFlag = false;
  this.m_userData = def.userData
};
b2Joint.prototype.__varz = function() {
  this.m_edgeA = new b2JointEdge;
  this.m_edgeB = new b2JointEdge;
  this.m_localCenterA = new b2Vec2;
  this.m_localCenterB = new b2Vec2
};
b2Joint.Create = function(def, allocator) {
  var joint = null;
  switch(def.type) {
    case b2Joint.e_distanceJoint:
      joint = new b2DistanceJoint(def);
      break;
    case b2Joint.e_mouseJoint:
      joint = new b2MouseJoint(def);
      break;
    case b2Joint.e_prismaticJoint:
      joint = new b2PrismaticJoint(def);
      break;
    case b2Joint.e_revoluteJoint:
      joint = new b2RevoluteJoint(def);
      break;
    case b2Joint.e_pulleyJoint:
      joint = new b2PulleyJoint(def);
      break;
    case b2Joint.e_gearJoint:
      joint = new b2GearJoint(def);
      break;
    case b2Joint.e_lineJoint:
      joint = new b2LineJoint(def);
      break;
    case b2Joint.e_weldJoint:
      joint = new b2WeldJoint(def);
      break;
    case b2Joint.e_frictionJoint:
      joint = new b2FrictionJoint(def);
      break;
    default:
      break
  }
  return joint
};
b2Joint.Destroy = function(joint, allocator) {
};
b2Joint.e_unknownJoint = 0;
b2Joint.e_revoluteJoint = 1;
b2Joint.e_prismaticJoint = 2;
b2Joint.e_distanceJoint = 3;
b2Joint.e_pulleyJoint = 4;
b2Joint.e_mouseJoint = 5;
b2Joint.e_gearJoint = 6;
b2Joint.e_lineJoint = 7;
b2Joint.e_weldJoint = 8;
b2Joint.e_frictionJoint = 9;
b2Joint.e_inactiveLimit = 0;
b2Joint.e_atLowerLimit = 1;
b2Joint.e_atUpperLimit = 2;
b2Joint.e_equalLimits = 3;
b2Joint.prototype.InitVelocityConstraints = function(step) {
};
b2Joint.prototype.SolveVelocityConstraints = function(step) {
};
b2Joint.prototype.FinalizeVelocityConstraints = function() {
};
b2Joint.prototype.SolvePositionConstraints = function(baumgarte) {
  return false
};
b2Joint.prototype.GetType = function() {
  return this.m_type
};
b2Joint.prototype.GetAnchorA = function() {
  return null
};
b2Joint.prototype.GetAnchorB = function() {
  return null
};
b2Joint.prototype.GetReactionForce = function(inv_dt) {
  return null
};
b2Joint.prototype.GetReactionTorque = function(inv_dt) {
  return 0
};
b2Joint.prototype.GetBodyA = function() {
  return this.m_bodyA
};
b2Joint.prototype.GetBodyB = function() {
  return this.m_bodyB
};
b2Joint.prototype.GetNext = function() {
  return this.m_next
};
b2Joint.prototype.GetUserData = function() {
  return this.m_userData
};
b2Joint.prototype.SetUserData = function(data) {
  this.m_userData = data
};
b2Joint.prototype.IsActive = function() {
  return this.m_bodyA.IsActive() && this.m_bodyB.IsActive()
};
b2Joint.prototype.m_type = 0;
b2Joint.prototype.m_prev = null;
b2Joint.prototype.m_next = null;
b2Joint.prototype.m_edgeA = new b2JointEdge;
b2Joint.prototype.m_edgeB = new b2JointEdge;
b2Joint.prototype.m_bodyA = null;
b2Joint.prototype.m_bodyB = null;
b2Joint.prototype.m_islandFlag = null;
b2Joint.prototype.m_collideConnected = null;
b2Joint.prototype.m_userData = null;
b2Joint.prototype.m_localCenterA = new b2Vec2;
b2Joint.prototype.m_localCenterB = new b2Vec2;
b2Joint.prototype.m_invMassA = null;
b2Joint.prototype.m_invMassB = null;
b2Joint.prototype.m_invIA = null;
b2Joint.prototype.m_invIB = null;var b2LineJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2LineJoint.prototype, b2Joint.prototype);
b2LineJoint.prototype._super = b2Joint.prototype;
b2LineJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var tMat;
  var tX;
  var tY;
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_localXAxis1.SetV(def.localAxisA);
  this.m_localYAxis1.x = -this.m_localXAxis1.y;
  this.m_localYAxis1.y = this.m_localXAxis1.x;
  this.m_impulse.SetZero();
  this.m_motorMass = 0;
  this.m_motorImpulse = 0;
  this.m_lowerTranslation = def.lowerTranslation;
  this.m_upperTranslation = def.upperTranslation;
  this.m_maxMotorForce = def.maxMotorForce;
  this.m_motorSpeed = def.motorSpeed;
  this.m_enableLimit = def.enableLimit;
  this.m_enableMotor = def.enableMotor;
  this.m_limitState = b2Joint.e_inactiveLimit;
  this.m_axis.SetZero();
  this.m_perp.SetZero()
};
b2LineJoint.prototype.__varz = function() {
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_localXAxis1 = new b2Vec2;
  this.m_localYAxis1 = new b2Vec2;
  this.m_axis = new b2Vec2;
  this.m_perp = new b2Vec2;
  this.m_K = new b2Mat22;
  this.m_impulse = new b2Vec2
};
b2LineJoint.prototype.InitVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var tX;
  this.m_localCenterA.SetV(bA.GetLocalCenter());
  this.m_localCenterB.SetV(bB.GetLocalCenter());
  var xf1 = bA.GetTransform();
  var xf2 = bB.GetTransform();
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
  var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
  var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  this.m_invMassA = bA.m_invMass;
  this.m_invMassB = bB.m_invMass;
  this.m_invIA = bA.m_invI;
  this.m_invIB = bB.m_invI;
  this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
  this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
  this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
  this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
  this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1 / this.m_motorMass : 0;
  this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
  this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
  this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
  var m1 = this.m_invMassA;
  var m2 = this.m_invMassB;
  var i1 = this.m_invIA;
  var i2 = this.m_invIB;
  this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
  this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
  this.m_K.col2.x = this.m_K.col1.y;
  this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
  if(this.m_enableLimit) {
    var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
    if(b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
      this.m_limitState = b2Joint.e_equalLimits
    }else {
      if(jointTransition <= this.m_lowerTranslation) {
        if(this.m_limitState != b2Joint.e_atLowerLimit) {
          this.m_limitState = b2Joint.e_atLowerLimit;
          this.m_impulse.y = 0
        }
      }else {
        if(jointTransition >= this.m_upperTranslation) {
          if(this.m_limitState != b2Joint.e_atUpperLimit) {
            this.m_limitState = b2Joint.e_atUpperLimit;
            this.m_impulse.y = 0
          }
        }else {
          this.m_limitState = b2Joint.e_inactiveLimit;
          this.m_impulse.y = 0
        }
      }
    }
  }else {
    this.m_limitState = b2Joint.e_inactiveLimit
  }
  if(this.m_enableMotor == false) {
    this.m_motorImpulse = 0
  }
  if(step.warmStarting) {
    this.m_impulse.x *= step.dtRatio;
    this.m_impulse.y *= step.dtRatio;
    this.m_motorImpulse *= step.dtRatio;
    var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x;
    var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y;
    var L1 = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1;
    var L2 = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2;
    bA.m_linearVelocity.x -= this.m_invMassA * PX;
    bA.m_linearVelocity.y -= this.m_invMassA * PY;
    bA.m_angularVelocity -= this.m_invIA * L1;
    bB.m_linearVelocity.x += this.m_invMassB * PX;
    bB.m_linearVelocity.y += this.m_invMassB * PY;
    bB.m_angularVelocity += this.m_invIB * L2
  }else {
    this.m_impulse.SetZero();
    this.m_motorImpulse = 0
  }
};
b2LineJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var v1 = bA.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var v2 = bB.m_linearVelocity;
  var w2 = bB.m_angularVelocity;
  var PX;
  var PY;
  var L1;
  var L2;
  if(this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
    var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
    var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
    var oldImpulse = this.m_motorImpulse;
    var maxImpulse = step.dt * this.m_maxMotorForce;
    this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
    impulse = this.m_motorImpulse - oldImpulse;
    PX = impulse * this.m_axis.x;
    PY = impulse * this.m_axis.y;
    L1 = impulse * this.m_a1;
    L2 = impulse * this.m_a2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }
  var Cdot1 = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
  if(this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
    var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
    var f1 = this.m_impulse.Copy();
    var df = this.m_K.Solve(new b2Vec2, -Cdot1, -Cdot2);
    this.m_impulse.Add(df);
    if(this.m_limitState == b2Joint.e_atLowerLimit) {
      this.m_impulse.y = b2Math.Max(this.m_impulse.y, 0)
    }else {
      if(this.m_limitState == b2Joint.e_atUpperLimit) {
        this.m_impulse.y = b2Math.Min(this.m_impulse.y, 0)
      }
    }
    var b = -Cdot1 - (this.m_impulse.y - f1.y) * this.m_K.col2.x;
    var f2r;
    if(this.m_K.col1.x != 0) {
      f2r = b / this.m_K.col1.x + f1.x
    }else {
      f2r = f1.x
    }
    this.m_impulse.x = f2r;
    df.x = this.m_impulse.x - f1.x;
    df.y = this.m_impulse.y - f1.y;
    PX = df.x * this.m_perp.x + df.y * this.m_axis.x;
    PY = df.x * this.m_perp.y + df.y * this.m_axis.y;
    L1 = df.x * this.m_s1 + df.y * this.m_a1;
    L2 = df.x * this.m_s2 + df.y * this.m_a2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }else {
    var df2;
    if(this.m_K.col1.x != 0) {
      df2 = -Cdot1 / this.m_K.col1.x
    }else {
      df2 = 0
    }
    this.m_impulse.x += df2;
    PX = df2 * this.m_perp.x;
    PY = df2 * this.m_perp.y;
    L1 = df2 * this.m_s1;
    L2 = df2 * this.m_s2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }
  bA.m_linearVelocity.SetV(v1);
  bA.m_angularVelocity = w1;
  bB.m_linearVelocity.SetV(v2);
  bB.m_angularVelocity = w2
};
b2LineJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var limitC;
  var oldLimitImpulse;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var c1 = bA.m_sweep.c;
  var a1 = bA.m_sweep.a;
  var c2 = bB.m_sweep.c;
  var a2 = bB.m_sweep.a;
  var tMat;
  var tX;
  var m1;
  var m2;
  var i1;
  var i2;
  var linearError = 0;
  var angularError = 0;
  var active = false;
  var C2 = 0;
  var R1 = b2Mat22.FromAngle(a1);
  var R2 = b2Mat22.FromAngle(a2);
  tMat = R1;
  var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
  var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = R2;
  var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
  var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = c2.x + r2X - c1.x - r1X;
  var dY = c2.y + r2Y - c1.y - r1Y;
  if(this.m_enableLimit) {
    this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
    this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
    this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
    var translation = this.m_axis.x * dX + this.m_axis.y * dY;
    if(b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
      C2 = b2Math.Clamp(translation, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection);
      linearError = b2Math.Abs(translation);
      active = true
    }else {
      if(translation <= this.m_lowerTranslation) {
        C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
        linearError = this.m_lowerTranslation - translation;
        active = true
      }else {
        if(translation >= this.m_upperTranslation) {
          C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0, b2Settings.b2_maxLinearCorrection);
          linearError = translation - this.m_upperTranslation;
          active = true
        }
      }
    }
  }
  this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
  this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
  this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
  var impulse = new b2Vec2;
  var C1 = this.m_perp.x * dX + this.m_perp.y * dY;
  linearError = b2Math.Max(linearError, b2Math.Abs(C1));
  angularError = 0;
  if(active) {
    m1 = this.m_invMassA;
    m2 = this.m_invMassB;
    i1 = this.m_invIA;
    i2 = this.m_invIB;
    this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
    this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
    this.m_K.col2.x = this.m_K.col1.y;
    this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
    this.m_K.Solve(impulse, -C1, -C2)
  }else {
    m1 = this.m_invMassA;
    m2 = this.m_invMassB;
    i1 = this.m_invIA;
    i2 = this.m_invIB;
    var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
    var impulse1;
    if(k11 != 0) {
      impulse1 = -C1 / k11
    }else {
      impulse1 = 0
    }
    impulse.x = impulse1;
    impulse.y = 0
  }
  var PX = impulse.x * this.m_perp.x + impulse.y * this.m_axis.x;
  var PY = impulse.x * this.m_perp.y + impulse.y * this.m_axis.y;
  var L1 = impulse.x * this.m_s1 + impulse.y * this.m_a1;
  var L2 = impulse.x * this.m_s2 + impulse.y * this.m_a2;
  c1.x -= this.m_invMassA * PX;
  c1.y -= this.m_invMassA * PY;
  a1 -= this.m_invIA * L1;
  c2.x += this.m_invMassB * PX;
  c2.y += this.m_invMassB * PY;
  a2 += this.m_invIB * L2;
  bA.m_sweep.a = a1;
  bB.m_sweep.a = a2;
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
};
b2LineJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2LineJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2LineJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y))
};
b2LineJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.y
};
b2LineJoint.prototype.GetJointTranslation = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var p1 = bA.GetWorldPoint(this.m_localAnchor1);
  var p2 = bB.GetWorldPoint(this.m_localAnchor2);
  var dX = p2.x - p1.x;
  var dY = p2.y - p1.y;
  var axis = bA.GetWorldVector(this.m_localXAxis1);
  var translation = axis.x * dX + axis.y * dY;
  return translation
};
b2LineJoint.prototype.GetJointSpeed = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var p1X = bA.m_sweep.c.x + r1X;
  var p1Y = bA.m_sweep.c.y + r1Y;
  var p2X = bB.m_sweep.c.x + r2X;
  var p2Y = bB.m_sweep.c.y + r2Y;
  var dX = p2X - p1X;
  var dY = p2Y - p1Y;
  var axis = bA.GetWorldVector(this.m_localXAxis1);
  var v1 = bA.m_linearVelocity;
  var v2 = bB.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var w2 = bB.m_angularVelocity;
  var speed = dX * -w1 * axis.y + dY * w1 * axis.x + (axis.x * (v2.x + -w2 * r2Y - v1.x - -w1 * r1Y) + axis.y * (v2.y + w2 * r2X - v1.y - w1 * r1X));
  return speed
};
b2LineJoint.prototype.IsLimitEnabled = function() {
  return this.m_enableLimit
};
b2LineJoint.prototype.EnableLimit = function(flag) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_enableLimit = flag
};
b2LineJoint.prototype.GetLowerLimit = function() {
  return this.m_lowerTranslation
};
b2LineJoint.prototype.GetUpperLimit = function() {
  return this.m_upperTranslation
};
b2LineJoint.prototype.SetLimits = function(lower, upper) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_lowerTranslation = lower;
  this.m_upperTranslation = upper
};
b2LineJoint.prototype.IsMotorEnabled = function() {
  return this.m_enableMotor
};
b2LineJoint.prototype.EnableMotor = function(flag) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_enableMotor = flag
};
b2LineJoint.prototype.SetMotorSpeed = function(speed) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_motorSpeed = speed
};
b2LineJoint.prototype.GetMotorSpeed = function() {
  return this.m_motorSpeed
};
b2LineJoint.prototype.SetMaxMotorForce = function(force) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_maxMotorForce = force
};
b2LineJoint.prototype.GetMaxMotorForce = function() {
  return this.m_maxMotorForce
};
b2LineJoint.prototype.GetMotorForce = function() {
  return this.m_motorImpulse
};
b2LineJoint.prototype.m_localAnchor1 = new b2Vec2;
b2LineJoint.prototype.m_localAnchor2 = new b2Vec2;
b2LineJoint.prototype.m_localXAxis1 = new b2Vec2;
b2LineJoint.prototype.m_localYAxis1 = new b2Vec2;
b2LineJoint.prototype.m_axis = new b2Vec2;
b2LineJoint.prototype.m_perp = new b2Vec2;
b2LineJoint.prototype.m_s1 = null;
b2LineJoint.prototype.m_s2 = null;
b2LineJoint.prototype.m_a1 = null;
b2LineJoint.prototype.m_a2 = null;
b2LineJoint.prototype.m_K = new b2Mat22;
b2LineJoint.prototype.m_impulse = new b2Vec2;
b2LineJoint.prototype.m_motorMass = null;
b2LineJoint.prototype.m_motorImpulse = null;
b2LineJoint.prototype.m_lowerTranslation = null;
b2LineJoint.prototype.m_upperTranslation = null;
b2LineJoint.prototype.m_maxMotorForce = null;
b2LineJoint.prototype.m_motorSpeed = null;
b2LineJoint.prototype.m_enableLimit = null;
b2LineJoint.prototype.m_enableMotor = null;
b2LineJoint.prototype.m_limitState = 0;var b2ContactSolver = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactSolver.prototype.__constructor = function() {
};
b2ContactSolver.prototype.__varz = function() {
  this.m_step = new b2TimeStep;
  this.m_constraints = new Array
};
b2ContactSolver.s_worldManifold = new b2WorldManifold;
b2ContactSolver.s_psm = new b2PositionSolverManifold;
b2ContactSolver.prototype.Initialize = function(step, contacts, contactCount, allocator) {
  var contact;
  this.m_step.Set(step);
  this.m_allocator = allocator;
  var i = 0;
  var tVec;
  var tMat;
  this.m_constraintCount = contactCount;
  while(this.m_constraints.length < this.m_constraintCount) {
    this.m_constraints[this.m_constraints.length] = new b2ContactConstraint
  }
  for(i = 0;i < contactCount;++i) {
    contact = contacts[i];
    var fixtureA = contact.m_fixtureA;
    var fixtureB = contact.m_fixtureB;
    var shapeA = fixtureA.m_shape;
    var shapeB = fixtureB.m_shape;
    var radiusA = shapeA.m_radius;
    var radiusB = shapeB.m_radius;
    var bodyA = fixtureA.m_body;
    var bodyB = fixtureB.m_body;
    var manifold = contact.GetManifold();
    var friction = b2Settings.b2MixFriction(fixtureA.GetFriction(), fixtureB.GetFriction());
    var restitution = b2Settings.b2MixRestitution(fixtureA.GetRestitution(), fixtureB.GetRestitution());
    var vAX = bodyA.m_linearVelocity.x;
    var vAY = bodyA.m_linearVelocity.y;
    var vBX = bodyB.m_linearVelocity.x;
    var vBY = bodyB.m_linearVelocity.y;
    var wA = bodyA.m_angularVelocity;
    var wB = bodyB.m_angularVelocity;
    b2Settings.b2Assert(manifold.m_pointCount > 0);
    b2ContactSolver.s_worldManifold.Initialize(manifold, bodyA.m_xf, radiusA, bodyB.m_xf, radiusB);
    var normalX = b2ContactSolver.s_worldManifold.m_normal.x;
    var normalY = b2ContactSolver.s_worldManifold.m_normal.y;
    var cc = this.m_constraints[i];
    cc.bodyA = bodyA;
    cc.bodyB = bodyB;
    cc.manifold = manifold;
    cc.normal.x = normalX;
    cc.normal.y = normalY;
    cc.pointCount = manifold.m_pointCount;
    cc.friction = friction;
    cc.restitution = restitution;
    cc.localPlaneNormal.x = manifold.m_localPlaneNormal.x;
    cc.localPlaneNormal.y = manifold.m_localPlaneNormal.y;
    cc.localPoint.x = manifold.m_localPoint.x;
    cc.localPoint.y = manifold.m_localPoint.y;
    cc.radius = radiusA + radiusB;
    cc.type = manifold.m_type;
    for(var k = 0;k < cc.pointCount;++k) {
      var cp = manifold.m_points[k];
      var ccp = cc.points[k];
      ccp.normalImpulse = cp.m_normalImpulse;
      ccp.tangentImpulse = cp.m_tangentImpulse;
      ccp.localPoint.SetV(cp.m_localPoint);
      var rAX = ccp.rA.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyA.m_sweep.c.x;
      var rAY = ccp.rA.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyA.m_sweep.c.y;
      var rBX = ccp.rB.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyB.m_sweep.c.x;
      var rBY = ccp.rB.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyB.m_sweep.c.y;
      var rnA = rAX * normalY - rAY * normalX;
      var rnB = rBX * normalY - rBY * normalX;
      rnA *= rnA;
      rnB *= rnB;
      var kNormal = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rnA + bodyB.m_invI * rnB;
      ccp.normalMass = 1 / kNormal;
      var kEqualized = bodyA.m_mass * bodyA.m_invMass + bodyB.m_mass * bodyB.m_invMass;
      kEqualized += bodyA.m_mass * bodyA.m_invI * rnA + bodyB.m_mass * bodyB.m_invI * rnB;
      ccp.equalizedMass = 1 / kEqualized;
      var tangentX = normalY;
      var tangentY = -normalX;
      var rtA = rAX * tangentY - rAY * tangentX;
      var rtB = rBX * tangentY - rBY * tangentX;
      rtA *= rtA;
      rtB *= rtB;
      var kTangent = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rtA + bodyB.m_invI * rtB;
      ccp.tangentMass = 1 / kTangent;
      ccp.velocityBias = 0;
      var tX = vBX + -wB * rBY - vAX - -wA * rAY;
      var tY = vBY + wB * rBX - vAY - wA * rAX;
      var vRel = cc.normal.x * tX + cc.normal.y * tY;
      if(vRel < -b2Settings.b2_velocityThreshold) {
        ccp.velocityBias += -cc.restitution * vRel
      }
    }
    if(cc.pointCount == 2) {
      var ccp1 = cc.points[0];
      var ccp2 = cc.points[1];
      var invMassA = bodyA.m_invMass;
      var invIA = bodyA.m_invI;
      var invMassB = bodyB.m_invMass;
      var invIB = bodyB.m_invI;
      var rn1A = ccp1.rA.x * normalY - ccp1.rA.y * normalX;
      var rn1B = ccp1.rB.x * normalY - ccp1.rB.y * normalX;
      var rn2A = ccp2.rA.x * normalY - ccp2.rA.y * normalX;
      var rn2B = ccp2.rB.x * normalY - ccp2.rB.y * normalX;
      var k11 = invMassA + invMassB + invIA * rn1A * rn1A + invIB * rn1B * rn1B;
      var k22 = invMassA + invMassB + invIA * rn2A * rn2A + invIB * rn2B * rn2B;
      var k12 = invMassA + invMassB + invIA * rn1A * rn2A + invIB * rn1B * rn2B;
      var k_maxConditionNumber = 100;
      if(k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
        cc.K.col1.Set(k11, k12);
        cc.K.col2.Set(k12, k22);
        cc.K.GetInverse(cc.normalMass)
      }else {
        cc.pointCount = 1
      }
    }
  }
};
b2ContactSolver.prototype.InitVelocityConstraints = function(step) {
  var tVec;
  var tVec2;
  var tMat;
  for(var i = 0;i < this.m_constraintCount;++i) {
    var c = this.m_constraints[i];
    var bodyA = c.bodyA;
    var bodyB = c.bodyB;
    var invMassA = bodyA.m_invMass;
    var invIA = bodyA.m_invI;
    var invMassB = bodyB.m_invMass;
    var invIB = bodyB.m_invI;
    var normalX = c.normal.x;
    var normalY = c.normal.y;
    var tangentX = normalY;
    var tangentY = -normalX;
    var tX;
    var j = 0;
    var tCount = 0;
    if(step.warmStarting) {
      tCount = c.pointCount;
      for(j = 0;j < tCount;++j) {
        var ccp = c.points[j];
        ccp.normalImpulse *= step.dtRatio;
        ccp.tangentImpulse *= step.dtRatio;
        var PX = ccp.normalImpulse * normalX + ccp.tangentImpulse * tangentX;
        var PY = ccp.normalImpulse * normalY + ccp.tangentImpulse * tangentY;
        bodyA.m_angularVelocity -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
        bodyA.m_linearVelocity.x -= invMassA * PX;
        bodyA.m_linearVelocity.y -= invMassA * PY;
        bodyB.m_angularVelocity += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
        bodyB.m_linearVelocity.x += invMassB * PX;
        bodyB.m_linearVelocity.y += invMassB * PY
      }
    }else {
      tCount = c.pointCount;
      for(j = 0;j < tCount;++j) {
        var ccp2 = c.points[j];
        ccp2.normalImpulse = 0;
        ccp2.tangentImpulse = 0
      }
    }
  }
};
b2ContactSolver.prototype.SolveVelocityConstraints = function() {
  var j = 0;
  var ccp;
  var rAX;
  var rAY;
  var rBX;
  var rBY;
  var dvX;
  var dvY;
  var vn;
  var vt;
  var lambda;
  var maxFriction;
  var newImpulse;
  var PX;
  var PY;
  var dX;
  var dY;
  var P1X;
  var P1Y;
  var P2X;
  var P2Y;
  var tMat;
  var tVec;
  for(var i = 0;i < this.m_constraintCount;++i) {
    var c = this.m_constraints[i];
    var bodyA = c.bodyA;
    var bodyB = c.bodyB;
    var wA = bodyA.m_angularVelocity;
    var wB = bodyB.m_angularVelocity;
    var vA = bodyA.m_linearVelocity;
    var vB = bodyB.m_linearVelocity;
    var invMassA = bodyA.m_invMass;
    var invIA = bodyA.m_invI;
    var invMassB = bodyB.m_invMass;
    var invIB = bodyB.m_invI;
    var normalX = c.normal.x;
    var normalY = c.normal.y;
    var tangentX = normalY;
    var tangentY = -normalX;
    var friction = c.friction;
    var tX;
    for(j = 0;j < c.pointCount;j++) {
      ccp = c.points[j];
      dvX = vB.x - wB * ccp.rB.y - vA.x + wA * ccp.rA.y;
      dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
      vt = dvX * tangentX + dvY * tangentY;
      lambda = ccp.tangentMass * -vt;
      maxFriction = friction * ccp.normalImpulse;
      newImpulse = b2Math.Clamp(ccp.tangentImpulse + lambda, -maxFriction, maxFriction);
      lambda = newImpulse - ccp.tangentImpulse;
      PX = lambda * tangentX;
      PY = lambda * tangentY;
      vA.x -= invMassA * PX;
      vA.y -= invMassA * PY;
      wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
      vB.x += invMassB * PX;
      vB.y += invMassB * PY;
      wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
      ccp.tangentImpulse = newImpulse
    }
    var tCount = c.pointCount;
    if(c.pointCount == 1) {
      ccp = c.points[0];
      dvX = vB.x + -wB * ccp.rB.y - vA.x - -wA * ccp.rA.y;
      dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
      vn = dvX * normalX + dvY * normalY;
      lambda = -ccp.normalMass * (vn - ccp.velocityBias);
      newImpulse = ccp.normalImpulse + lambda;
      newImpulse = newImpulse > 0 ? newImpulse : 0;
      lambda = newImpulse - ccp.normalImpulse;
      PX = lambda * normalX;
      PY = lambda * normalY;
      vA.x -= invMassA * PX;
      vA.y -= invMassA * PY;
      wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
      vB.x += invMassB * PX;
      vB.y += invMassB * PY;
      wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
      ccp.normalImpulse = newImpulse
    }else {
      var cp1 = c.points[0];
      var cp2 = c.points[1];
      var aX = cp1.normalImpulse;
      var aY = cp2.normalImpulse;
      var dv1X = vB.x - wB * cp1.rB.y - vA.x + wA * cp1.rA.y;
      var dv1Y = vB.y + wB * cp1.rB.x - vA.y - wA * cp1.rA.x;
      var dv2X = vB.x - wB * cp2.rB.y - vA.x + wA * cp2.rA.y;
      var dv2Y = vB.y + wB * cp2.rB.x - vA.y - wA * cp2.rA.x;
      var vn1 = dv1X * normalX + dv1Y * normalY;
      var vn2 = dv2X * normalX + dv2Y * normalY;
      var bX = vn1 - cp1.velocityBias;
      var bY = vn2 - cp2.velocityBias;
      tMat = c.K;
      bX -= tMat.col1.x * aX + tMat.col2.x * aY;
      bY -= tMat.col1.y * aX + tMat.col2.y * aY;
      var k_errorTol = 0.0010;
      for(;;) {
        tMat = c.normalMass;
        var xX = -(tMat.col1.x * bX + tMat.col2.x * bY);
        var xY = -(tMat.col1.y * bX + tMat.col2.y * bY);
        if(xX >= 0 && xY >= 0) {
          dX = xX - aX;
          dY = xY - aY;
          P1X = dX * normalX;
          P1Y = dX * normalY;
          P2X = dY * normalX;
          P2Y = dY * normalY;
          vA.x -= invMassA * (P1X + P2X);
          vA.y -= invMassA * (P1Y + P2Y);
          wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
          vB.x += invMassB * (P1X + P2X);
          vB.y += invMassB * (P1Y + P2Y);
          wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
          cp1.normalImpulse = xX;
          cp2.normalImpulse = xY;
          break
        }
        xX = -cp1.normalMass * bX;
        xY = 0;
        vn1 = 0;
        vn2 = c.K.col1.y * xX + bY;
        if(xX >= 0 && vn2 >= 0) {
          dX = xX - aX;
          dY = xY - aY;
          P1X = dX * normalX;
          P1Y = dX * normalY;
          P2X = dY * normalX;
          P2Y = dY * normalY;
          vA.x -= invMassA * (P1X + P2X);
          vA.y -= invMassA * (P1Y + P2Y);
          wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
          vB.x += invMassB * (P1X + P2X);
          vB.y += invMassB * (P1Y + P2Y);
          wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
          cp1.normalImpulse = xX;
          cp2.normalImpulse = xY;
          break
        }
        xX = 0;
        xY = -cp2.normalMass * bY;
        vn1 = c.K.col2.x * xY + bX;
        vn2 = 0;
        if(xY >= 0 && vn1 >= 0) {
          dX = xX - aX;
          dY = xY - aY;
          P1X = dX * normalX;
          P1Y = dX * normalY;
          P2X = dY * normalX;
          P2Y = dY * normalY;
          vA.x -= invMassA * (P1X + P2X);
          vA.y -= invMassA * (P1Y + P2Y);
          wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
          vB.x += invMassB * (P1X + P2X);
          vB.y += invMassB * (P1Y + P2Y);
          wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
          cp1.normalImpulse = xX;
          cp2.normalImpulse = xY;
          break
        }
        xX = 0;
        xY = 0;
        vn1 = bX;
        vn2 = bY;
        if(vn1 >= 0 && vn2 >= 0) {
          dX = xX - aX;
          dY = xY - aY;
          P1X = dX * normalX;
          P1Y = dX * normalY;
          P2X = dY * normalX;
          P2Y = dY * normalY;
          vA.x -= invMassA * (P1X + P2X);
          vA.y -= invMassA * (P1Y + P2Y);
          wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
          vB.x += invMassB * (P1X + P2X);
          vB.y += invMassB * (P1Y + P2Y);
          wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
          cp1.normalImpulse = xX;
          cp2.normalImpulse = xY;
          break
        }
        break
      }
    }
    bodyA.m_angularVelocity = wA;
    bodyB.m_angularVelocity = wB
  }
};
b2ContactSolver.prototype.FinalizeVelocityConstraints = function() {
  for(var i = 0;i < this.m_constraintCount;++i) {
    var c = this.m_constraints[i];
    var m = c.manifold;
    for(var j = 0;j < c.pointCount;++j) {
      var point1 = m.m_points[j];
      var point2 = c.points[j];
      point1.m_normalImpulse = point2.normalImpulse;
      point1.m_tangentImpulse = point2.tangentImpulse
    }
  }
};
b2ContactSolver.prototype.SolvePositionConstraints = function(baumgarte) {
  var minSeparation = 0;
  for(var i = 0;i < this.m_constraintCount;i++) {
    var c = this.m_constraints[i];
    var bodyA = c.bodyA;
    var bodyB = c.bodyB;
    var invMassA = bodyA.m_mass * bodyA.m_invMass;
    var invIA = bodyA.m_mass * bodyA.m_invI;
    var invMassB = bodyB.m_mass * bodyB.m_invMass;
    var invIB = bodyB.m_mass * bodyB.m_invI;
    b2ContactSolver.s_psm.Initialize(c);
    var normal = b2ContactSolver.s_psm.m_normal;
    for(var j = 0;j < c.pointCount;j++) {
      var ccp = c.points[j];
      var point = b2ContactSolver.s_psm.m_points[j];
      var separation = b2ContactSolver.s_psm.m_separations[j];
      var rAX = point.x - bodyA.m_sweep.c.x;
      var rAY = point.y - bodyA.m_sweep.c.y;
      var rBX = point.x - bodyB.m_sweep.c.x;
      var rBY = point.y - bodyB.m_sweep.c.y;
      minSeparation = minSeparation < separation ? minSeparation : separation;
      var C = b2Math.Clamp(baumgarte * (separation + b2Settings.b2_linearSlop), -b2Settings.b2_maxLinearCorrection, 0);
      var impulse = -ccp.equalizedMass * C;
      var PX = impulse * normal.x;
      var PY = impulse * normal.y;
      bodyA.m_sweep.c.x -= invMassA * PX;
      bodyA.m_sweep.c.y -= invMassA * PY;
      bodyA.m_sweep.a -= invIA * (rAX * PY - rAY * PX);
      bodyA.SynchronizeTransform();
      bodyB.m_sweep.c.x += invMassB * PX;
      bodyB.m_sweep.c.y += invMassB * PY;
      bodyB.m_sweep.a += invIB * (rBX * PY - rBY * PX);
      bodyB.SynchronizeTransform()
    }
  }
  return minSeparation > -1.5 * b2Settings.b2_linearSlop
};
b2ContactSolver.prototype.m_step = new b2TimeStep;
b2ContactSolver.prototype.m_allocator = null;
b2ContactSolver.prototype.m_constraints = new Array;
b2ContactSolver.prototype.m_constraintCount = 0;var b2Simplex = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Simplex.prototype.__constructor = function() {
  this.m_vertices[0] = this.m_v1;
  this.m_vertices[1] = this.m_v2;
  this.m_vertices[2] = this.m_v3
};
b2Simplex.prototype.__varz = function() {
  this.m_v1 = new b2SimplexVertex;
  this.m_v2 = new b2SimplexVertex;
  this.m_v3 = new b2SimplexVertex;
  this.m_vertices = new Array(3)
};
b2Simplex.prototype.ReadCache = function(cache, proxyA, transformA, proxyB, transformB) {
  b2Settings.b2Assert(0 <= cache.count && cache.count <= 3);
  var wALocal;
  var wBLocal;
  this.m_count = cache.count;
  var vertices = this.m_vertices;
  for(var i = 0;i < this.m_count;i++) {
    var v = vertices[i];
    v.indexA = cache.indexA[i];
    v.indexB = cache.indexB[i];
    wALocal = proxyA.GetVertex(v.indexA);
    wBLocal = proxyB.GetVertex(v.indexB);
    v.wA = b2Math.MulX(transformA, wALocal);
    v.wB = b2Math.MulX(transformB, wBLocal);
    v.w = b2Math.SubtractVV(v.wB, v.wA);
    v.a = 0
  }
  if(this.m_count > 1) {
    var metric1 = cache.metric;
    var metric2 = this.GetMetric();
    if(metric2 < 0.5 * metric1 || 2 * metric1 < metric2 || metric2 < Number.MIN_VALUE) {
      this.m_count = 0
    }
  }
  if(this.m_count == 0) {
    v = vertices[0];
    v.indexA = 0;
    v.indexB = 0;
    wALocal = proxyA.GetVertex(0);
    wBLocal = proxyB.GetVertex(0);
    v.wA = b2Math.MulX(transformA, wALocal);
    v.wB = b2Math.MulX(transformB, wBLocal);
    v.w = b2Math.SubtractVV(v.wB, v.wA);
    this.m_count = 1
  }
};
b2Simplex.prototype.WriteCache = function(cache) {
  cache.metric = this.GetMetric();
  cache.count = parseInt(this.m_count);
  var vertices = this.m_vertices;
  for(var i = 0;i < this.m_count;i++) {
    cache.indexA[i] = parseInt(vertices[i].indexA);
    cache.indexB[i] = parseInt(vertices[i].indexB)
  }
};
b2Simplex.prototype.GetSearchDirection = function() {
  switch(this.m_count) {
    case 1:
      return this.m_v1.w.GetNegative();
    case 2:
      var e12 = b2Math.SubtractVV(this.m_v2.w, this.m_v1.w);
      var sgn = b2Math.CrossVV(e12, this.m_v1.w.GetNegative());
      if(sgn > 0) {
        return b2Math.CrossFV(1, e12)
      }else {
        return b2Math.CrossVF(e12, 1)
      }
    ;
    default:
      b2Settings.b2Assert(false);
      return new b2Vec2
  }
};
b2Simplex.prototype.GetClosestPoint = function() {
  switch(this.m_count) {
    case 0:
      b2Settings.b2Assert(false);
      return new b2Vec2;
    case 1:
      return this.m_v1.w;
    case 2:
      return new b2Vec2(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
    default:
      b2Settings.b2Assert(false);
      return new b2Vec2
  }
};
b2Simplex.prototype.GetWitnessPoints = function(pA, pB) {
  switch(this.m_count) {
    case 0:
      b2Settings.b2Assert(false);
      break;
    case 1:
      pA.SetV(this.m_v1.wA);
      pB.SetV(this.m_v1.wB);
      break;
    case 2:
      pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
      pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
      pB.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
      pB.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
      break;
    case 3:
      pB.x = pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;
      pB.y = pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
      break;
    default:
      b2Settings.b2Assert(false);
      break
  }
};
b2Simplex.prototype.GetMetric = function() {
  switch(this.m_count) {
    case 0:
      b2Settings.b2Assert(false);
      return 0;
    case 1:
      return 0;
    case 2:
      return b2Math.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
    case 3:
      return b2Math.CrossVV(b2Math.SubtractVV(this.m_v2.w, this.m_v1.w), b2Math.SubtractVV(this.m_v3.w, this.m_v1.w));
    default:
      b2Settings.b2Assert(false);
      return 0
  }
};
b2Simplex.prototype.Solve2 = function() {
  var w1 = this.m_v1.w;
  var w2 = this.m_v2.w;
  var e12 = b2Math.SubtractVV(w2, w1);
  var d12_2 = -(w1.x * e12.x + w1.y * e12.y);
  if(d12_2 <= 0) {
    this.m_v1.a = 1;
    this.m_count = 1;
    return
  }
  var d12_1 = w2.x * e12.x + w2.y * e12.y;
  if(d12_1 <= 0) {
    this.m_v2.a = 1;
    this.m_count = 1;
    this.m_v1.Set(this.m_v2);
    return
  }
  var inv_d12 = 1 / (d12_1 + d12_2);
  this.m_v1.a = d12_1 * inv_d12;
  this.m_v2.a = d12_2 * inv_d12;
  this.m_count = 2
};
b2Simplex.prototype.Solve3 = function() {
  var w1 = this.m_v1.w;
  var w2 = this.m_v2.w;
  var w3 = this.m_v3.w;
  var e12 = b2Math.SubtractVV(w2, w1);
  var w1e12 = b2Math.Dot(w1, e12);
  var w2e12 = b2Math.Dot(w2, e12);
  var d12_1 = w2e12;
  var d12_2 = -w1e12;
  var e13 = b2Math.SubtractVV(w3, w1);
  var w1e13 = b2Math.Dot(w1, e13);
  var w3e13 = b2Math.Dot(w3, e13);
  var d13_1 = w3e13;
  var d13_2 = -w1e13;
  var e23 = b2Math.SubtractVV(w3, w2);
  var w2e23 = b2Math.Dot(w2, e23);
  var w3e23 = b2Math.Dot(w3, e23);
  var d23_1 = w3e23;
  var d23_2 = -w2e23;
  var n123 = b2Math.CrossVV(e12, e13);
  var d123_1 = n123 * b2Math.CrossVV(w2, w3);
  var d123_2 = n123 * b2Math.CrossVV(w3, w1);
  var d123_3 = n123 * b2Math.CrossVV(w1, w2);
  if(d12_2 <= 0 && d13_2 <= 0) {
    this.m_v1.a = 1;
    this.m_count = 1;
    return
  }
  if(d12_1 > 0 && d12_2 > 0 && d123_3 <= 0) {
    var inv_d12 = 1 / (d12_1 + d12_2);
    this.m_v1.a = d12_1 * inv_d12;
    this.m_v2.a = d12_2 * inv_d12;
    this.m_count = 2;
    return
  }
  if(d13_1 > 0 && d13_2 > 0 && d123_2 <= 0) {
    var inv_d13 = 1 / (d13_1 + d13_2);
    this.m_v1.a = d13_1 * inv_d13;
    this.m_v3.a = d13_2 * inv_d13;
    this.m_count = 2;
    this.m_v2.Set(this.m_v3);
    return
  }
  if(d12_1 <= 0 && d23_2 <= 0) {
    this.m_v2.a = 1;
    this.m_count = 1;
    this.m_v1.Set(this.m_v2);
    return
  }
  if(d13_1 <= 0 && d23_1 <= 0) {
    this.m_v3.a = 1;
    this.m_count = 1;
    this.m_v1.Set(this.m_v3);
    return
  }
  if(d23_1 > 0 && d23_2 > 0 && d123_1 <= 0) {
    var inv_d23 = 1 / (d23_1 + d23_2);
    this.m_v2.a = d23_1 * inv_d23;
    this.m_v3.a = d23_2 * inv_d23;
    this.m_count = 2;
    this.m_v1.Set(this.m_v3);
    return
  }
  var inv_d123 = 1 / (d123_1 + d123_2 + d123_3);
  this.m_v1.a = d123_1 * inv_d123;
  this.m_v2.a = d123_2 * inv_d123;
  this.m_v3.a = d123_3 * inv_d123;
  this.m_count = 3
};
b2Simplex.prototype.m_v1 = new b2SimplexVertex;
b2Simplex.prototype.m_v2 = new b2SimplexVertex;
b2Simplex.prototype.m_v3 = new b2SimplexVertex;
b2Simplex.prototype.m_vertices = new Array(3);
b2Simplex.prototype.m_count = 0;var b2WeldJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2WeldJoint.prototype, b2Joint.prototype);
b2WeldJoint.prototype._super = b2Joint.prototype;
b2WeldJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  this.m_localAnchorA.SetV(def.localAnchorA);
  this.m_localAnchorB.SetV(def.localAnchorB);
  this.m_referenceAngle = def.referenceAngle;
  this.m_impulse.SetZero();
  this.m_mass = new b2Mat33
};
b2WeldJoint.prototype.__varz = function() {
  this.m_localAnchorA = new b2Vec2;
  this.m_localAnchorB = new b2Vec2;
  this.m_impulse = new b2Vec3;
  this.m_mass = new b2Mat33
};
b2WeldJoint.prototype.InitVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
  this.m_mass.col2.x = -rAY * rAX * iA - rBY * rBX * iB;
  this.m_mass.col3.x = -rAY * iA - rBY * iB;
  this.m_mass.col1.y = this.m_mass.col2.x;
  this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
  this.m_mass.col3.y = rAX * iA + rBX * iB;
  this.m_mass.col1.z = this.m_mass.col3.x;
  this.m_mass.col2.z = this.m_mass.col3.y;
  this.m_mass.col3.z = iA + iB;
  if(step.warmStarting) {
    this.m_impulse.x *= step.dtRatio;
    this.m_impulse.y *= step.dtRatio;
    this.m_impulse.z *= step.dtRatio;
    bA.m_linearVelocity.x -= mA * this.m_impulse.x;
    bA.m_linearVelocity.y -= mA * this.m_impulse.y;
    bA.m_angularVelocity -= iA * (rAX * this.m_impulse.y - rAY * this.m_impulse.x + this.m_impulse.z);
    bB.m_linearVelocity.x += mB * this.m_impulse.x;
    bB.m_linearVelocity.y += mB * this.m_impulse.y;
    bB.m_angularVelocity += iB * (rBX * this.m_impulse.y - rBY * this.m_impulse.x + this.m_impulse.z)
  }else {
    this.m_impulse.SetZero()
  }
};
b2WeldJoint.prototype.SolveVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var vA = bA.m_linearVelocity;
  var wA = bA.m_angularVelocity;
  var vB = bB.m_linearVelocity;
  var wB = bB.m_angularVelocity;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var Cdot1X = vB.x - wB * rBY - vA.x + wA * rAY;
  var Cdot1Y = vB.y + wB * rBX - vA.y - wA * rAX;
  var Cdot2 = wB - wA;
  var impulse = new b2Vec3;
  this.m_mass.Solve33(impulse, -Cdot1X, -Cdot1Y, -Cdot2);
  this.m_impulse.Add(impulse);
  vA.x -= mA * impulse.x;
  vA.y -= mA * impulse.y;
  wA -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
  vB.x += mB * impulse.x;
  vB.y += mB * impulse.y;
  wB += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
  bA.m_angularVelocity = wA;
  bB.m_angularVelocity = wB
};
b2WeldJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  var C1X = bB.m_sweep.c.x + rBX - bA.m_sweep.c.x - rAX;
  var C1Y = bB.m_sweep.c.y + rBY - bA.m_sweep.c.y - rAY;
  var C2 = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
  var k_allowedStretch = 10 * b2Settings.b2_linearSlop;
  var positionError = Math.sqrt(C1X * C1X + C1Y * C1Y);
  var angularError = b2Math.Abs(C2);
  if(positionError > k_allowedStretch) {
    iA *= 1;
    iB *= 1
  }
  this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
  this.m_mass.col2.x = -rAY * rAX * iA - rBY * rBX * iB;
  this.m_mass.col3.x = -rAY * iA - rBY * iB;
  this.m_mass.col1.y = this.m_mass.col2.x;
  this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
  this.m_mass.col3.y = rAX * iA + rBX * iB;
  this.m_mass.col1.z = this.m_mass.col3.x;
  this.m_mass.col2.z = this.m_mass.col3.y;
  this.m_mass.col3.z = iA + iB;
  var impulse = new b2Vec3;
  this.m_mass.Solve33(impulse, -C1X, -C1Y, -C2);
  bA.m_sweep.c.x -= mA * impulse.x;
  bA.m_sweep.c.y -= mA * impulse.y;
  bA.m_sweep.a -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
  bB.m_sweep.c.x += mB * impulse.x;
  bB.m_sweep.c.y += mB * impulse.y;
  bB.m_sweep.a += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
};
b2WeldJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)
};
b2WeldJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)
};
b2WeldJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y)
};
b2WeldJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.z
};
b2WeldJoint.prototype.m_localAnchorA = new b2Vec2;
b2WeldJoint.prototype.m_localAnchorB = new b2Vec2;
b2WeldJoint.prototype.m_referenceAngle = null;
b2WeldJoint.prototype.m_impulse = new b2Vec3;
b2WeldJoint.prototype.m_mass = new b2Mat33;var b2Math = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Math.prototype.__constructor = function() {
};
b2Math.prototype.__varz = function() {
};
b2Math.IsValid = function(x) {
  return isFinite(x)
};
b2Math.Dot = function(a, b) {
  return a.x * b.x + a.y * b.y
};
b2Math.CrossVV = function(a, b) {
  return a.x * b.y - a.y * b.x
};
b2Math.CrossVF = function(a, s) {
  var v = new b2Vec2(s * a.y, -s * a.x);
  return v
};
b2Math.CrossFV = function(s, a) {
  var v = new b2Vec2(-s * a.y, s * a.x);
  return v
};
b2Math.MulMV = function(A, v) {
  var u = new b2Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y);
  return u
};
b2Math.MulTMV = function(A, v) {
  var u = new b2Vec2(b2Math.Dot(v, A.col1), b2Math.Dot(v, A.col2));
  return u
};
b2Math.MulX = function(T, v) {
  var a = b2Math.MulMV(T.R, v);
  a.x += T.position.x;
  a.y += T.position.y;
  return a
};
b2Math.MulXT = function(T, v) {
  var a = b2Math.SubtractVV(v, T.position);
  var tX = a.x * T.R.col1.x + a.y * T.R.col1.y;
  a.y = a.x * T.R.col2.x + a.y * T.R.col2.y;
  a.x = tX;
  return a
};
b2Math.AddVV = function(a, b) {
  var v = new b2Vec2(a.x + b.x, a.y + b.y);
  return v
};
b2Math.SubtractVV = function(a, b) {
  var v = new b2Vec2(a.x - b.x, a.y - b.y);
  return v
};
b2Math.Distance = function(a, b) {
  var cX = a.x - b.x;
  var cY = a.y - b.y;
  return Math.sqrt(cX * cX + cY * cY)
};
b2Math.DistanceSquared = function(a, b) {
  var cX = a.x - b.x;
  var cY = a.y - b.y;
  return cX * cX + cY * cY
};
b2Math.MulFV = function(s, a) {
  var v = new b2Vec2(s * a.x, s * a.y);
  return v
};
b2Math.AddMM = function(A, B) {
  var C = b2Mat22.FromVV(b2Math.AddVV(A.col1, B.col1), b2Math.AddVV(A.col2, B.col2));
  return C
};
b2Math.MulMM = function(A, B) {
  var C = b2Mat22.FromVV(b2Math.MulMV(A, B.col1), b2Math.MulMV(A, B.col2));
  return C
};
b2Math.MulTMM = function(A, B) {
  var c1 = new b2Vec2(b2Math.Dot(A.col1, B.col1), b2Math.Dot(A.col2, B.col1));
  var c2 = new b2Vec2(b2Math.Dot(A.col1, B.col2), b2Math.Dot(A.col2, B.col2));
  var C = b2Mat22.FromVV(c1, c2);
  return C
};
b2Math.Abs = function(a) {
  return a > 0 ? a : -a
};
b2Math.AbsV = function(a) {
  var b = new b2Vec2(b2Math.Abs(a.x), b2Math.Abs(a.y));
  return b
};
b2Math.AbsM = function(A) {
  var B = b2Mat22.FromVV(b2Math.AbsV(A.col1), b2Math.AbsV(A.col2));
  return B
};
b2Math.Min = function(a, b) {
  return a < b ? a : b
};
b2Math.MinV = function(a, b) {
  var c = new b2Vec2(b2Math.Min(a.x, b.x), b2Math.Min(a.y, b.y));
  return c
};
b2Math.Max = function(a, b) {
  return a > b ? a : b
};
b2Math.MaxV = function(a, b) {
  var c = new b2Vec2(b2Math.Max(a.x, b.x), b2Math.Max(a.y, b.y));
  return c
};
b2Math.Clamp = function(a, low, high) {
  return a < low ? low : a > high ? high : a
};
b2Math.ClampV = function(a, low, high) {
  return b2Math.MaxV(low, b2Math.MinV(a, high))
};
b2Math.Swap = function(a, b) {
  var tmp = a[0];
  a[0] = b[0];
  b[0] = tmp
};
b2Math.Random = function() {
  return Math.random() * 2 - 1
};
b2Math.RandomRange = function(lo, hi) {
  var r = Math.random();
  r = (hi - lo) * r + lo;
  return r
};
b2Math.NextPowerOfTwo = function(x) {
  x |= x >> 1 & 2147483647;
  x |= x >> 2 & 1073741823;
  x |= x >> 4 & 268435455;
  x |= x >> 8 & 16777215;
  x |= x >> 16 & 65535;
  return x + 1
};
b2Math.IsPowerOfTwo = function(x) {
  var result = x > 0 && (x & x - 1) == 0;
  return result
};
b2Math.b2Vec2_zero = new b2Vec2(0, 0);
b2Math.b2Mat22_identity = b2Mat22.FromVV(new b2Vec2(1, 0), new b2Vec2(0, 1));
b2Math.b2Transform_identity = new b2Transform(b2Math.b2Vec2_zero, b2Math.b2Mat22_identity);var b2PulleyJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PulleyJoint.prototype, b2Joint.prototype);
b2PulleyJoint.prototype._super = b2Joint.prototype;
b2PulleyJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var tMat;
  var tX;
  var tY;
  this.m_ground = this.m_bodyA.m_world.m_groundBody;
  this.m_groundAnchor1.x = def.groundAnchorA.x - this.m_ground.m_xf.position.x;
  this.m_groundAnchor1.y = def.groundAnchorA.y - this.m_ground.m_xf.position.y;
  this.m_groundAnchor2.x = def.groundAnchorB.x - this.m_ground.m_xf.position.x;
  this.m_groundAnchor2.y = def.groundAnchorB.y - this.m_ground.m_xf.position.y;
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_ratio = def.ratio;
  this.m_constant = def.lengthA + this.m_ratio * def.lengthB;
  this.m_maxLength1 = b2Math.Min(def.maxLengthA, this.m_constant - this.m_ratio * b2PulleyJoint.b2_minPulleyLength);
  this.m_maxLength2 = b2Math.Min(def.maxLengthB, (this.m_constant - b2PulleyJoint.b2_minPulleyLength) / this.m_ratio);
  this.m_impulse = 0;
  this.m_limitImpulse1 = 0;
  this.m_limitImpulse2 = 0
};
b2PulleyJoint.prototype.__varz = function() {
  this.m_groundAnchor1 = new b2Vec2;
  this.m_groundAnchor2 = new b2Vec2;
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_u1 = new b2Vec2;
  this.m_u2 = new b2Vec2
};
b2PulleyJoint.b2_minPulleyLength = 2;
b2PulleyJoint.prototype.InitVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var p1X = bA.m_sweep.c.x + r1X;
  var p1Y = bA.m_sweep.c.y + r1Y;
  var p2X = bB.m_sweep.c.x + r2X;
  var p2Y = bB.m_sweep.c.y + r2Y;
  var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
  var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
  var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
  var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
  this.m_u1.Set(p1X - s1X, p1Y - s1Y);
  this.m_u2.Set(p2X - s2X, p2Y - s2Y);
  var length1 = this.m_u1.Length();
  var length2 = this.m_u2.Length();
  if(length1 > b2Settings.b2_linearSlop) {
    this.m_u1.Multiply(1 / length1)
  }else {
    this.m_u1.SetZero()
  }
  if(length2 > b2Settings.b2_linearSlop) {
    this.m_u2.Multiply(1 / length2)
  }else {
    this.m_u2.SetZero()
  }
  var C = this.m_constant - length1 - this.m_ratio * length2;
  if(C > 0) {
    this.m_state = b2Joint.e_inactiveLimit;
    this.m_impulse = 0
  }else {
    this.m_state = b2Joint.e_atUpperLimit
  }
  if(length1 < this.m_maxLength1) {
    this.m_limitState1 = b2Joint.e_inactiveLimit;
    this.m_limitImpulse1 = 0
  }else {
    this.m_limitState1 = b2Joint.e_atUpperLimit
  }
  if(length2 < this.m_maxLength2) {
    this.m_limitState2 = b2Joint.e_inactiveLimit;
    this.m_limitImpulse2 = 0
  }else {
    this.m_limitState2 = b2Joint.e_atUpperLimit
  }
  var cr1u1 = r1X * this.m_u1.y - r1Y * this.m_u1.x;
  var cr2u2 = r2X * this.m_u2.y - r2Y * this.m_u2.x;
  this.m_limitMass1 = bA.m_invMass + bA.m_invI * cr1u1 * cr1u1;
  this.m_limitMass2 = bB.m_invMass + bB.m_invI * cr2u2 * cr2u2;
  this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2;
  this.m_limitMass1 = 1 / this.m_limitMass1;
  this.m_limitMass2 = 1 / this.m_limitMass2;
  this.m_pulleyMass = 1 / this.m_pulleyMass;
  if(step.warmStarting) {
    this.m_impulse *= step.dtRatio;
    this.m_limitImpulse1 *= step.dtRatio;
    this.m_limitImpulse2 *= step.dtRatio;
    var P1X = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.x;
    var P1Y = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.y;
    var P2X = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.x;
    var P2Y = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.y;
    bA.m_linearVelocity.x += bA.m_invMass * P1X;
    bA.m_linearVelocity.y += bA.m_invMass * P1Y;
    bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
    bB.m_linearVelocity.x += bB.m_invMass * P2X;
    bB.m_linearVelocity.y += bB.m_invMass * P2Y;
    bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X)
  }else {
    this.m_impulse = 0;
    this.m_limitImpulse1 = 0;
    this.m_limitImpulse2 = 0
  }
};
b2PulleyJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var v1X;
  var v1Y;
  var v2X;
  var v2Y;
  var P1X;
  var P1Y;
  var P2X;
  var P2Y;
  var Cdot;
  var impulse;
  var oldImpulse;
  if(this.m_state == b2Joint.e_atUpperLimit) {
    v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * r1Y;
    v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * r1X;
    v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * r2Y;
    v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * r2X;
    Cdot = -(this.m_u1.x * v1X + this.m_u1.y * v1Y) - this.m_ratio * (this.m_u2.x * v2X + this.m_u2.y * v2Y);
    impulse = this.m_pulleyMass * -Cdot;
    oldImpulse = this.m_impulse;
    this.m_impulse = b2Math.Max(0, this.m_impulse + impulse);
    impulse = this.m_impulse - oldImpulse;
    P1X = -impulse * this.m_u1.x;
    P1Y = -impulse * this.m_u1.y;
    P2X = -this.m_ratio * impulse * this.m_u2.x;
    P2Y = -this.m_ratio * impulse * this.m_u2.y;
    bA.m_linearVelocity.x += bA.m_invMass * P1X;
    bA.m_linearVelocity.y += bA.m_invMass * P1Y;
    bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
    bB.m_linearVelocity.x += bB.m_invMass * P2X;
    bB.m_linearVelocity.y += bB.m_invMass * P2Y;
    bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X)
  }
  if(this.m_limitState1 == b2Joint.e_atUpperLimit) {
    v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * r1Y;
    v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * r1X;
    Cdot = -(this.m_u1.x * v1X + this.m_u1.y * v1Y);
    impulse = -this.m_limitMass1 * Cdot;
    oldImpulse = this.m_limitImpulse1;
    this.m_limitImpulse1 = b2Math.Max(0, this.m_limitImpulse1 + impulse);
    impulse = this.m_limitImpulse1 - oldImpulse;
    P1X = -impulse * this.m_u1.x;
    P1Y = -impulse * this.m_u1.y;
    bA.m_linearVelocity.x += bA.m_invMass * P1X;
    bA.m_linearVelocity.y += bA.m_invMass * P1Y;
    bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X)
  }
  if(this.m_limitState2 == b2Joint.e_atUpperLimit) {
    v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * r2Y;
    v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * r2X;
    Cdot = -(this.m_u2.x * v2X + this.m_u2.y * v2Y);
    impulse = -this.m_limitMass2 * Cdot;
    oldImpulse = this.m_limitImpulse2;
    this.m_limitImpulse2 = b2Math.Max(0, this.m_limitImpulse2 + impulse);
    impulse = this.m_limitImpulse2 - oldImpulse;
    P2X = -impulse * this.m_u2.x;
    P2Y = -impulse * this.m_u2.y;
    bB.m_linearVelocity.x += bB.m_invMass * P2X;
    bB.m_linearVelocity.y += bB.m_invMass * P2Y;
    bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X)
  }
};
b2PulleyJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
  var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
  var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
  var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
  var r1X;
  var r1Y;
  var r2X;
  var r2Y;
  var p1X;
  var p1Y;
  var p2X;
  var p2Y;
  var length1;
  var length2;
  var C;
  var impulse;
  var oldImpulse;
  var oldLimitPositionImpulse;
  var tX;
  var linearError = 0;
  if(this.m_state == b2Joint.e_atUpperLimit) {
    tMat = bA.m_xf.R;
    r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    p1X = bA.m_sweep.c.x + r1X;
    p1Y = bA.m_sweep.c.y + r1Y;
    p2X = bB.m_sweep.c.x + r2X;
    p2Y = bB.m_sweep.c.y + r2Y;
    this.m_u1.Set(p1X - s1X, p1Y - s1Y);
    this.m_u2.Set(p2X - s2X, p2Y - s2Y);
    length1 = this.m_u1.Length();
    length2 = this.m_u2.Length();
    if(length1 > b2Settings.b2_linearSlop) {
      this.m_u1.Multiply(1 / length1)
    }else {
      this.m_u1.SetZero()
    }
    if(length2 > b2Settings.b2_linearSlop) {
      this.m_u2.Multiply(1 / length2)
    }else {
      this.m_u2.SetZero()
    }
    C = this.m_constant - length1 - this.m_ratio * length2;
    linearError = b2Math.Max(linearError, -C);
    C = b2Math.Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
    impulse = -this.m_pulleyMass * C;
    p1X = -impulse * this.m_u1.x;
    p1Y = -impulse * this.m_u1.y;
    p2X = -this.m_ratio * impulse * this.m_u2.x;
    p2Y = -this.m_ratio * impulse * this.m_u2.y;
    bA.m_sweep.c.x += bA.m_invMass * p1X;
    bA.m_sweep.c.y += bA.m_invMass * p1Y;
    bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
    bB.m_sweep.c.x += bB.m_invMass * p2X;
    bB.m_sweep.c.y += bB.m_invMass * p2Y;
    bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
    bA.SynchronizeTransform();
    bB.SynchronizeTransform()
  }
  if(this.m_limitState1 == b2Joint.e_atUpperLimit) {
    tMat = bA.m_xf.R;
    r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    p1X = bA.m_sweep.c.x + r1X;
    p1Y = bA.m_sweep.c.y + r1Y;
    this.m_u1.Set(p1X - s1X, p1Y - s1Y);
    length1 = this.m_u1.Length();
    if(length1 > b2Settings.b2_linearSlop) {
      this.m_u1.x *= 1 / length1;
      this.m_u1.y *= 1 / length1
    }else {
      this.m_u1.SetZero()
    }
    C = this.m_maxLength1 - length1;
    linearError = b2Math.Max(linearError, -C);
    C = b2Math.Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
    impulse = -this.m_limitMass1 * C;
    p1X = -impulse * this.m_u1.x;
    p1Y = -impulse * this.m_u1.y;
    bA.m_sweep.c.x += bA.m_invMass * p1X;
    bA.m_sweep.c.y += bA.m_invMass * p1Y;
    bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
    bA.SynchronizeTransform()
  }
  if(this.m_limitState2 == b2Joint.e_atUpperLimit) {
    tMat = bB.m_xf.R;
    r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    p2X = bB.m_sweep.c.x + r2X;
    p2Y = bB.m_sweep.c.y + r2Y;
    this.m_u2.Set(p2X - s2X, p2Y - s2Y);
    length2 = this.m_u2.Length();
    if(length2 > b2Settings.b2_linearSlop) {
      this.m_u2.x *= 1 / length2;
      this.m_u2.y *= 1 / length2
    }else {
      this.m_u2.SetZero()
    }
    C = this.m_maxLength2 - length2;
    linearError = b2Math.Max(linearError, -C);
    C = b2Math.Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
    impulse = -this.m_limitMass2 * C;
    p2X = -impulse * this.m_u2.x;
    p2Y = -impulse * this.m_u2.y;
    bB.m_sweep.c.x += bB.m_invMass * p2X;
    bB.m_sweep.c.y += bB.m_invMass * p2Y;
    bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
    bB.SynchronizeTransform()
  }
  return linearError < b2Settings.b2_linearSlop
};
b2PulleyJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2PulleyJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2PulleyJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse * this.m_u2.x, inv_dt * this.m_impulse * this.m_u2.y)
};
b2PulleyJoint.prototype.GetReactionTorque = function(inv_dt) {
  return 0
};
b2PulleyJoint.prototype.GetGroundAnchorA = function() {
  var a = this.m_ground.m_xf.position.Copy();
  a.Add(this.m_groundAnchor1);
  return a
};
b2PulleyJoint.prototype.GetGroundAnchorB = function() {
  var a = this.m_ground.m_xf.position.Copy();
  a.Add(this.m_groundAnchor2);
  return a
};
b2PulleyJoint.prototype.GetLength1 = function() {
  var p = this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
  var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
  var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
  var dX = p.x - sX;
  var dY = p.y - sY;
  return Math.sqrt(dX * dX + dY * dY)
};
b2PulleyJoint.prototype.GetLength2 = function() {
  var p = this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
  var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
  var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
  var dX = p.x - sX;
  var dY = p.y - sY;
  return Math.sqrt(dX * dX + dY * dY)
};
b2PulleyJoint.prototype.GetRatio = function() {
  return this.m_ratio
};
b2PulleyJoint.prototype.m_ground = null;
b2PulleyJoint.prototype.m_groundAnchor1 = new b2Vec2;
b2PulleyJoint.prototype.m_groundAnchor2 = new b2Vec2;
b2PulleyJoint.prototype.m_localAnchor1 = new b2Vec2;
b2PulleyJoint.prototype.m_localAnchor2 = new b2Vec2;
b2PulleyJoint.prototype.m_u1 = new b2Vec2;
b2PulleyJoint.prototype.m_u2 = new b2Vec2;
b2PulleyJoint.prototype.m_constant = null;
b2PulleyJoint.prototype.m_ratio = null;
b2PulleyJoint.prototype.m_maxLength1 = null;
b2PulleyJoint.prototype.m_maxLength2 = null;
b2PulleyJoint.prototype.m_pulleyMass = null;
b2PulleyJoint.prototype.m_limitMass1 = null;
b2PulleyJoint.prototype.m_limitMass2 = null;
b2PulleyJoint.prototype.m_impulse = null;
b2PulleyJoint.prototype.m_limitImpulse1 = null;
b2PulleyJoint.prototype.m_limitImpulse2 = null;
b2PulleyJoint.prototype.m_state = 0;
b2PulleyJoint.prototype.m_limitState1 = 0;
b2PulleyJoint.prototype.m_limitState2 = 0;var b2PrismaticJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PrismaticJoint.prototype, b2Joint.prototype);
b2PrismaticJoint.prototype._super = b2Joint.prototype;
b2PrismaticJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var tMat;
  var tX;
  var tY;
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_localXAxis1.SetV(def.localAxisA);
  this.m_localYAxis1.x = -this.m_localXAxis1.y;
  this.m_localYAxis1.y = this.m_localXAxis1.x;
  this.m_refAngle = def.referenceAngle;
  this.m_impulse.SetZero();
  this.m_motorMass = 0;
  this.m_motorImpulse = 0;
  this.m_lowerTranslation = def.lowerTranslation;
  this.m_upperTranslation = def.upperTranslation;
  this.m_maxMotorForce = def.maxMotorForce;
  this.m_motorSpeed = def.motorSpeed;
  this.m_enableLimit = def.enableLimit;
  this.m_enableMotor = def.enableMotor;
  this.m_limitState = b2Joint.e_inactiveLimit;
  this.m_axis.SetZero();
  this.m_perp.SetZero()
};
b2PrismaticJoint.prototype.__varz = function() {
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_localXAxis1 = new b2Vec2;
  this.m_localYAxis1 = new b2Vec2;
  this.m_axis = new b2Vec2;
  this.m_perp = new b2Vec2;
  this.m_K = new b2Mat33;
  this.m_impulse = new b2Vec3
};
b2PrismaticJoint.prototype.InitVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var tX;
  this.m_localCenterA.SetV(bA.GetLocalCenter());
  this.m_localCenterB.SetV(bB.GetLocalCenter());
  var xf1 = bA.GetTransform();
  var xf2 = bB.GetTransform();
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
  var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
  var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  this.m_invMassA = bA.m_invMass;
  this.m_invMassB = bB.m_invMass;
  this.m_invIA = bA.m_invI;
  this.m_invIB = bB.m_invI;
  this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
  this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
  this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
  this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
  if(this.m_motorMass > Number.MIN_VALUE) {
    this.m_motorMass = 1 / this.m_motorMass
  }
  this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
  this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
  this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
  var m1 = this.m_invMassA;
  var m2 = this.m_invMassB;
  var i1 = this.m_invIA;
  var i2 = this.m_invIB;
  this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
  this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
  this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
  this.m_K.col2.x = this.m_K.col1.y;
  this.m_K.col2.y = i1 + i2;
  this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
  this.m_K.col3.x = this.m_K.col1.z;
  this.m_K.col3.y = this.m_K.col2.z;
  this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
  if(this.m_enableLimit) {
    var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
    if(b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
      this.m_limitState = b2Joint.e_equalLimits
    }else {
      if(jointTransition <= this.m_lowerTranslation) {
        if(this.m_limitState != b2Joint.e_atLowerLimit) {
          this.m_limitState = b2Joint.e_atLowerLimit;
          this.m_impulse.z = 0
        }
      }else {
        if(jointTransition >= this.m_upperTranslation) {
          if(this.m_limitState != b2Joint.e_atUpperLimit) {
            this.m_limitState = b2Joint.e_atUpperLimit;
            this.m_impulse.z = 0
          }
        }else {
          this.m_limitState = b2Joint.e_inactiveLimit;
          this.m_impulse.z = 0
        }
      }
    }
  }else {
    this.m_limitState = b2Joint.e_inactiveLimit
  }
  if(this.m_enableMotor == false) {
    this.m_motorImpulse = 0
  }
  if(step.warmStarting) {
    this.m_impulse.x *= step.dtRatio;
    this.m_impulse.y *= step.dtRatio;
    this.m_motorImpulse *= step.dtRatio;
    var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x;
    var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y;
    var L1 = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
    var L2 = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
    bA.m_linearVelocity.x -= this.m_invMassA * PX;
    bA.m_linearVelocity.y -= this.m_invMassA * PY;
    bA.m_angularVelocity -= this.m_invIA * L1;
    bB.m_linearVelocity.x += this.m_invMassB * PX;
    bB.m_linearVelocity.y += this.m_invMassB * PY;
    bB.m_angularVelocity += this.m_invIB * L2
  }else {
    this.m_impulse.SetZero();
    this.m_motorImpulse = 0
  }
};
b2PrismaticJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var v1 = bA.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var v2 = bB.m_linearVelocity;
  var w2 = bB.m_angularVelocity;
  var PX;
  var PY;
  var L1;
  var L2;
  if(this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
    var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
    var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
    var oldImpulse = this.m_motorImpulse;
    var maxImpulse = step.dt * this.m_maxMotorForce;
    this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
    impulse = this.m_motorImpulse - oldImpulse;
    PX = impulse * this.m_axis.x;
    PY = impulse * this.m_axis.y;
    L1 = impulse * this.m_a1;
    L2 = impulse * this.m_a2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }
  var Cdot1X = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
  var Cdot1Y = w2 - w1;
  if(this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
    var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
    var f1 = this.m_impulse.Copy();
    var df = this.m_K.Solve33(new b2Vec3, -Cdot1X, -Cdot1Y, -Cdot2);
    this.m_impulse.Add(df);
    if(this.m_limitState == b2Joint.e_atLowerLimit) {
      this.m_impulse.z = b2Math.Max(this.m_impulse.z, 0)
    }else {
      if(this.m_limitState == b2Joint.e_atUpperLimit) {
        this.m_impulse.z = b2Math.Min(this.m_impulse.z, 0)
      }
    }
    var bX = -Cdot1X - (this.m_impulse.z - f1.z) * this.m_K.col3.x;
    var bY = -Cdot1Y - (this.m_impulse.z - f1.z) * this.m_K.col3.y;
    var f2r = this.m_K.Solve22(new b2Vec2, bX, bY);
    f2r.x += f1.x;
    f2r.y += f1.y;
    this.m_impulse.x = f2r.x;
    this.m_impulse.y = f2r.y;
    df.x = this.m_impulse.x - f1.x;
    df.y = this.m_impulse.y - f1.y;
    df.z = this.m_impulse.z - f1.z;
    PX = df.x * this.m_perp.x + df.z * this.m_axis.x;
    PY = df.x * this.m_perp.y + df.z * this.m_axis.y;
    L1 = df.x * this.m_s1 + df.y + df.z * this.m_a1;
    L2 = df.x * this.m_s2 + df.y + df.z * this.m_a2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }else {
    var df2 = this.m_K.Solve22(new b2Vec2, -Cdot1X, -Cdot1Y);
    this.m_impulse.x += df2.x;
    this.m_impulse.y += df2.y;
    PX = df2.x * this.m_perp.x;
    PY = df2.x * this.m_perp.y;
    L1 = df2.x * this.m_s1 + df2.y;
    L2 = df2.x * this.m_s2 + df2.y;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }
  bA.m_linearVelocity.SetV(v1);
  bA.m_angularVelocity = w1;
  bB.m_linearVelocity.SetV(v2);
  bB.m_angularVelocity = w2
};
b2PrismaticJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var limitC;
  var oldLimitImpulse;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var c1 = bA.m_sweep.c;
  var a1 = bA.m_sweep.a;
  var c2 = bB.m_sweep.c;
  var a2 = bB.m_sweep.a;
  var tMat;
  var tX;
  var m1;
  var m2;
  var i1;
  var i2;
  var linearError = 0;
  var angularError = 0;
  var active = false;
  var C2 = 0;
  var R1 = b2Mat22.FromAngle(a1);
  var R2 = b2Mat22.FromAngle(a2);
  tMat = R1;
  var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
  var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = R2;
  var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
  var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = c2.x + r2X - c1.x - r1X;
  var dY = c2.y + r2Y - c1.y - r1Y;
  if(this.m_enableLimit) {
    this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
    this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
    this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
    var translation = this.m_axis.x * dX + this.m_axis.y * dY;
    if(b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
      C2 = b2Math.Clamp(translation, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection);
      linearError = b2Math.Abs(translation);
      active = true
    }else {
      if(translation <= this.m_lowerTranslation) {
        C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
        linearError = this.m_lowerTranslation - translation;
        active = true
      }else {
        if(translation >= this.m_upperTranslation) {
          C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0, b2Settings.b2_maxLinearCorrection);
          linearError = translation - this.m_upperTranslation;
          active = true
        }
      }
    }
  }
  this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
  this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
  this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
  var impulse = new b2Vec3;
  var C1X = this.m_perp.x * dX + this.m_perp.y * dY;
  var C1Y = a2 - a1 - this.m_refAngle;
  linearError = b2Math.Max(linearError, b2Math.Abs(C1X));
  angularError = b2Math.Abs(C1Y);
  if(active) {
    m1 = this.m_invMassA;
    m2 = this.m_invMassB;
    i1 = this.m_invIA;
    i2 = this.m_invIB;
    this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
    this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
    this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
    this.m_K.col2.x = this.m_K.col1.y;
    this.m_K.col2.y = i1 + i2;
    this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
    this.m_K.col3.x = this.m_K.col1.z;
    this.m_K.col3.y = this.m_K.col2.z;
    this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
    this.m_K.Solve33(impulse, -C1X, -C1Y, -C2)
  }else {
    m1 = this.m_invMassA;
    m2 = this.m_invMassB;
    i1 = this.m_invIA;
    i2 = this.m_invIB;
    var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
    var k12 = i1 * this.m_s1 + i2 * this.m_s2;
    var k22 = i1 + i2;
    this.m_K.col1.Set(k11, k12, 0);
    this.m_K.col2.Set(k12, k22, 0);
    var impulse1 = this.m_K.Solve22(new b2Vec2, -C1X, -C1Y);
    impulse.x = impulse1.x;
    impulse.y = impulse1.y;
    impulse.z = 0
  }
  var PX = impulse.x * this.m_perp.x + impulse.z * this.m_axis.x;
  var PY = impulse.x * this.m_perp.y + impulse.z * this.m_axis.y;
  var L1 = impulse.x * this.m_s1 + impulse.y + impulse.z * this.m_a1;
  var L2 = impulse.x * this.m_s2 + impulse.y + impulse.z * this.m_a2;
  c1.x -= this.m_invMassA * PX;
  c1.y -= this.m_invMassA * PY;
  a1 -= this.m_invIA * L1;
  c2.x += this.m_invMassB * PX;
  c2.y += this.m_invMassB * PY;
  a2 += this.m_invIB * L2;
  bA.m_sweep.a = a1;
  bB.m_sweep.a = a2;
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
};
b2PrismaticJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2PrismaticJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2PrismaticJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y))
};
b2PrismaticJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.y
};
b2PrismaticJoint.prototype.GetJointTranslation = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var p1 = bA.GetWorldPoint(this.m_localAnchor1);
  var p2 = bB.GetWorldPoint(this.m_localAnchor2);
  var dX = p2.x - p1.x;
  var dY = p2.y - p1.y;
  var axis = bA.GetWorldVector(this.m_localXAxis1);
  var translation = axis.x * dX + axis.y * dY;
  return translation
};
b2PrismaticJoint.prototype.GetJointSpeed = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var p1X = bA.m_sweep.c.x + r1X;
  var p1Y = bA.m_sweep.c.y + r1Y;
  var p2X = bB.m_sweep.c.x + r2X;
  var p2Y = bB.m_sweep.c.y + r2Y;
  var dX = p2X - p1X;
  var dY = p2Y - p1Y;
  var axis = bA.GetWorldVector(this.m_localXAxis1);
  var v1 = bA.m_linearVelocity;
  var v2 = bB.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var w2 = bB.m_angularVelocity;
  var speed = dX * -w1 * axis.y + dY * w1 * axis.x + (axis.x * (v2.x + -w2 * r2Y - v1.x - -w1 * r1Y) + axis.y * (v2.y + w2 * r2X - v1.y - w1 * r1X));
  return speed
};
b2PrismaticJoint.prototype.IsLimitEnabled = function() {
  return this.m_enableLimit
};
b2PrismaticJoint.prototype.EnableLimit = function(flag) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_enableLimit = flag
};
b2PrismaticJoint.prototype.GetLowerLimit = function() {
  return this.m_lowerTranslation
};
b2PrismaticJoint.prototype.GetUpperLimit = function() {
  return this.m_upperTranslation
};
b2PrismaticJoint.prototype.SetLimits = function(lower, upper) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_lowerTranslation = lower;
  this.m_upperTranslation = upper
};
b2PrismaticJoint.prototype.IsMotorEnabled = function() {
  return this.m_enableMotor
};
b2PrismaticJoint.prototype.EnableMotor = function(flag) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_enableMotor = flag
};
b2PrismaticJoint.prototype.SetMotorSpeed = function(speed) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_motorSpeed = speed
};
b2PrismaticJoint.prototype.GetMotorSpeed = function() {
  return this.m_motorSpeed
};
b2PrismaticJoint.prototype.SetMaxMotorForce = function(force) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_maxMotorForce = force
};
b2PrismaticJoint.prototype.GetMotorForce = function() {
  return this.m_motorImpulse
};
b2PrismaticJoint.prototype.m_localAnchor1 = new b2Vec2;
b2PrismaticJoint.prototype.m_localAnchor2 = new b2Vec2;
b2PrismaticJoint.prototype.m_localXAxis1 = new b2Vec2;
b2PrismaticJoint.prototype.m_localYAxis1 = new b2Vec2;
b2PrismaticJoint.prototype.m_refAngle = null;
b2PrismaticJoint.prototype.m_axis = new b2Vec2;
b2PrismaticJoint.prototype.m_perp = new b2Vec2;
b2PrismaticJoint.prototype.m_s1 = null;
b2PrismaticJoint.prototype.m_s2 = null;
b2PrismaticJoint.prototype.m_a1 = null;
b2PrismaticJoint.prototype.m_a2 = null;
b2PrismaticJoint.prototype.m_K = new b2Mat33;
b2PrismaticJoint.prototype.m_impulse = new b2Vec3;
b2PrismaticJoint.prototype.m_motorMass = null;
b2PrismaticJoint.prototype.m_motorImpulse = null;
b2PrismaticJoint.prototype.m_lowerTranslation = null;
b2PrismaticJoint.prototype.m_upperTranslation = null;
b2PrismaticJoint.prototype.m_maxMotorForce = null;
b2PrismaticJoint.prototype.m_motorSpeed = null;
b2PrismaticJoint.prototype.m_enableLimit = null;
b2PrismaticJoint.prototype.m_enableMotor = null;
b2PrismaticJoint.prototype.m_limitState = 0;var b2RevoluteJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2RevoluteJoint.prototype, b2Joint.prototype);
b2RevoluteJoint.prototype._super = b2Joint.prototype;
b2RevoluteJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_referenceAngle = def.referenceAngle;
  this.m_impulse.SetZero();
  this.m_motorImpulse = 0;
  this.m_lowerAngle = def.lowerAngle;
  this.m_upperAngle = def.upperAngle;
  this.m_maxMotorTorque = def.maxMotorTorque;
  this.m_motorSpeed = def.motorSpeed;
  this.m_enableLimit = def.enableLimit;
  this.m_enableMotor = def.enableMotor;
  this.m_limitState = b2Joint.e_inactiveLimit
};
b2RevoluteJoint.prototype.__varz = function() {
  this.K = new b2Mat22;
  this.K1 = new b2Mat22;
  this.K2 = new b2Mat22;
  this.K3 = new b2Mat22;
  this.impulse3 = new b2Vec3;
  this.impulse2 = new b2Vec2;
  this.reduced = new b2Vec2;
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_impulse = new b2Vec3;
  this.m_mass = new b2Mat33
};
b2RevoluteJoint.tImpulse = new b2Vec2;
b2RevoluteJoint.prototype.InitVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var tX;
  if(this.m_enableMotor || this.m_enableLimit) {
  }
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var m1 = bA.m_invMass;
  var m2 = bB.m_invMass;
  var i1 = bA.m_invI;
  var i2 = bB.m_invI;
  this.m_mass.col1.x = m1 + m2 + r1Y * r1Y * i1 + r2Y * r2Y * i2;
  this.m_mass.col2.x = -r1Y * r1X * i1 - r2Y * r2X * i2;
  this.m_mass.col3.x = -r1Y * i1 - r2Y * i2;
  this.m_mass.col1.y = this.m_mass.col2.x;
  this.m_mass.col2.y = m1 + m2 + r1X * r1X * i1 + r2X * r2X * i2;
  this.m_mass.col3.y = r1X * i1 + r2X * i2;
  this.m_mass.col1.z = this.m_mass.col3.x;
  this.m_mass.col2.z = this.m_mass.col3.y;
  this.m_mass.col3.z = i1 + i2;
  this.m_motorMass = 1 / (i1 + i2);
  if(this.m_enableMotor == false) {
    this.m_motorImpulse = 0
  }
  if(this.m_enableLimit) {
    var jointAngle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
    if(b2Math.Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * b2Settings.b2_angularSlop) {
      this.m_limitState = b2Joint.e_equalLimits
    }else {
      if(jointAngle <= this.m_lowerAngle) {
        if(this.m_limitState != b2Joint.e_atLowerLimit) {
          this.m_impulse.z = 0
        }
        this.m_limitState = b2Joint.e_atLowerLimit
      }else {
        if(jointAngle >= this.m_upperAngle) {
          if(this.m_limitState != b2Joint.e_atUpperLimit) {
            this.m_impulse.z = 0
          }
          this.m_limitState = b2Joint.e_atUpperLimit
        }else {
          this.m_limitState = b2Joint.e_inactiveLimit;
          this.m_impulse.z = 0
        }
      }
    }
  }else {
    this.m_limitState = b2Joint.e_inactiveLimit
  }
  if(step.warmStarting) {
    this.m_impulse.x *= step.dtRatio;
    this.m_impulse.y *= step.dtRatio;
    this.m_motorImpulse *= step.dtRatio;
    var PX = this.m_impulse.x;
    var PY = this.m_impulse.y;
    bA.m_linearVelocity.x -= m1 * PX;
    bA.m_linearVelocity.y -= m1 * PY;
    bA.m_angularVelocity -= i1 * (r1X * PY - r1Y * PX + this.m_motorImpulse + this.m_impulse.z);
    bB.m_linearVelocity.x += m2 * PX;
    bB.m_linearVelocity.y += m2 * PY;
    bB.m_angularVelocity += i2 * (r2X * PY - r2Y * PX + this.m_motorImpulse + this.m_impulse.z)
  }else {
    this.m_impulse.SetZero();
    this.m_motorImpulse = 0
  }
};
b2RevoluteJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var tX;
  var newImpulse;
  var r1X;
  var r1Y;
  var r2X;
  var r2Y;
  var v1 = bA.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var v2 = bB.m_linearVelocity;
  var w2 = bB.m_angularVelocity;
  var m1 = bA.m_invMass;
  var m2 = bB.m_invMass;
  var i1 = bA.m_invI;
  var i2 = bB.m_invI;
  if(this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
    var Cdot = w2 - w1 - this.m_motorSpeed;
    var impulse = this.m_motorMass * -Cdot;
    var oldImpulse = this.m_motorImpulse;
    var maxImpulse = step.dt * this.m_maxMotorTorque;
    this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
    impulse = this.m_motorImpulse - oldImpulse;
    w1 -= i1 * impulse;
    w2 += i2 * impulse
  }
  if(this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
    tMat = bA.m_xf.R;
    r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    var Cdot1X = v2.x + -w2 * r2Y - v1.x - -w1 * r1Y;
    var Cdot1Y = v2.y + w2 * r2X - v1.y - w1 * r1X;
    var Cdot2 = w2 - w1;
    this.m_mass.Solve33(this.impulse3, -Cdot1X, -Cdot1Y, -Cdot2);
    if(this.m_limitState == b2Joint.e_equalLimits) {
      this.m_impulse.Add(this.impulse3)
    }else {
      if(this.m_limitState == b2Joint.e_atLowerLimit) {
        newImpulse = this.m_impulse.z + this.impulse3.z;
        if(newImpulse < 0) {
          this.m_mass.Solve22(this.reduced, -Cdot1X, -Cdot1Y);
          this.impulse3.x = this.reduced.x;
          this.impulse3.y = this.reduced.y;
          this.impulse3.z = -this.m_impulse.z;
          this.m_impulse.x += this.reduced.x;
          this.m_impulse.y += this.reduced.y;
          this.m_impulse.z = 0
        }
      }else {
        if(this.m_limitState == b2Joint.e_atUpperLimit) {
          newImpulse = this.m_impulse.z + this.impulse3.z;
          if(newImpulse > 0) {
            this.m_mass.Solve22(this.reduced, -Cdot1X, -Cdot1Y);
            this.impulse3.x = this.reduced.x;
            this.impulse3.y = this.reduced.y;
            this.impulse3.z = -this.m_impulse.z;
            this.m_impulse.x += this.reduced.x;
            this.m_impulse.y += this.reduced.y;
            this.m_impulse.z = 0
          }
        }
      }
    }
    v1.x -= m1 * this.impulse3.x;
    v1.y -= m1 * this.impulse3.y;
    w1 -= i1 * (r1X * this.impulse3.y - r1Y * this.impulse3.x + this.impulse3.z);
    v2.x += m2 * this.impulse3.x;
    v2.y += m2 * this.impulse3.y;
    w2 += i2 * (r2X * this.impulse3.y - r2Y * this.impulse3.x + this.impulse3.z)
  }else {
    tMat = bA.m_xf.R;
    r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    var CdotX = v2.x + -w2 * r2Y - v1.x - -w1 * r1Y;
    var CdotY = v2.y + w2 * r2X - v1.y - w1 * r1X;
    this.m_mass.Solve22(this.impulse2, -CdotX, -CdotY);
    this.m_impulse.x += this.impulse2.x;
    this.m_impulse.y += this.impulse2.y;
    v1.x -= m1 * this.impulse2.x;
    v1.y -= m1 * this.impulse2.y;
    w1 -= i1 * (r1X * this.impulse2.y - r1Y * this.impulse2.x);
    v2.x += m2 * this.impulse2.x;
    v2.y += m2 * this.impulse2.y;
    w2 += i2 * (r2X * this.impulse2.y - r2Y * this.impulse2.x)
  }
  bA.m_linearVelocity.SetV(v1);
  bA.m_angularVelocity = w1;
  bB.m_linearVelocity.SetV(v2);
  bB.m_angularVelocity = w2
};
b2RevoluteJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var oldLimitImpulse;
  var C;
  var tMat;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var angularError = 0;
  var positionError = 0;
  var tX;
  var impulseX;
  var impulseY;
  if(this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
    var angle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
    var limitImpulse = 0;
    if(this.m_limitState == b2Joint.e_equalLimits) {
      C = b2Math.Clamp(angle - this.m_lowerAngle, -b2Settings.b2_maxAngularCorrection, b2Settings.b2_maxAngularCorrection);
      limitImpulse = -this.m_motorMass * C;
      angularError = b2Math.Abs(C)
    }else {
      if(this.m_limitState == b2Joint.e_atLowerLimit) {
        C = angle - this.m_lowerAngle;
        angularError = -C;
        C = b2Math.Clamp(C + b2Settings.b2_angularSlop, -b2Settings.b2_maxAngularCorrection, 0);
        limitImpulse = -this.m_motorMass * C
      }else {
        if(this.m_limitState == b2Joint.e_atUpperLimit) {
          C = angle - this.m_upperAngle;
          angularError = C;
          C = b2Math.Clamp(C - b2Settings.b2_angularSlop, 0, b2Settings.b2_maxAngularCorrection);
          limitImpulse = -this.m_motorMass * C
        }
      }
    }
    bA.m_sweep.a -= bA.m_invI * limitImpulse;
    bB.m_sweep.a += bB.m_invI * limitImpulse;
    bA.SynchronizeTransform();
    bB.SynchronizeTransform()
  }
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  var CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  var CLengthSquared = CX * CX + CY * CY;
  var CLength = Math.sqrt(CLengthSquared);
  positionError = CLength;
  var invMass1 = bA.m_invMass;
  var invMass2 = bB.m_invMass;
  var invI1 = bA.m_invI;
  var invI2 = bB.m_invI;
  var k_allowedStretch = 10 * b2Settings.b2_linearSlop;
  if(CLengthSquared > k_allowedStretch * k_allowedStretch) {
    var uX = CX / CLength;
    var uY = CY / CLength;
    var k = invMass1 + invMass2;
    var m = 1 / k;
    impulseX = m * -CX;
    impulseY = m * -CY;
    var k_beta = 0.5;
    bA.m_sweep.c.x -= k_beta * invMass1 * impulseX;
    bA.m_sweep.c.y -= k_beta * invMass1 * impulseY;
    bB.m_sweep.c.x += k_beta * invMass2 * impulseX;
    bB.m_sweep.c.y += k_beta * invMass2 * impulseY;
    CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
    CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y
  }
  this.K1.col1.x = invMass1 + invMass2;
  this.K1.col2.x = 0;
  this.K1.col1.y = 0;
  this.K1.col2.y = invMass1 + invMass2;
  this.K2.col1.x = invI1 * r1Y * r1Y;
  this.K2.col2.x = -invI1 * r1X * r1Y;
  this.K2.col1.y = -invI1 * r1X * r1Y;
  this.K2.col2.y = invI1 * r1X * r1X;
  this.K3.col1.x = invI2 * r2Y * r2Y;
  this.K3.col2.x = -invI2 * r2X * r2Y;
  this.K3.col1.y = -invI2 * r2X * r2Y;
  this.K3.col2.y = invI2 * r2X * r2X;
  this.K.SetM(this.K1);
  this.K.AddM(this.K2);
  this.K.AddM(this.K3);
  this.K.Solve(b2RevoluteJoint.tImpulse, -CX, -CY);
  impulseX = b2RevoluteJoint.tImpulse.x;
  impulseY = b2RevoluteJoint.tImpulse.y;
  bA.m_sweep.c.x -= bA.m_invMass * impulseX;
  bA.m_sweep.c.y -= bA.m_invMass * impulseY;
  bA.m_sweep.a -= bA.m_invI * (r1X * impulseY - r1Y * impulseX);
  bB.m_sweep.c.x += bB.m_invMass * impulseX;
  bB.m_sweep.c.y += bB.m_invMass * impulseY;
  bB.m_sweep.a += bB.m_invI * (r2X * impulseY - r2Y * impulseX);
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
};
b2RevoluteJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2RevoluteJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2RevoluteJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y)
};
b2RevoluteJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.z
};
b2RevoluteJoint.prototype.GetJointAngle = function() {
  return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle
};
b2RevoluteJoint.prototype.GetJointSpeed = function() {
  return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity
};
b2RevoluteJoint.prototype.IsLimitEnabled = function() {
  return this.m_enableLimit
};
b2RevoluteJoint.prototype.EnableLimit = function(flag) {
  this.m_enableLimit = flag
};
b2RevoluteJoint.prototype.GetLowerLimit = function() {
  return this.m_lowerAngle
};
b2RevoluteJoint.prototype.GetUpperLimit = function() {
  return this.m_upperAngle
};
b2RevoluteJoint.prototype.SetLimits = function(lower, upper) {
  this.m_lowerAngle = lower;
  this.m_upperAngle = upper
};
b2RevoluteJoint.prototype.IsMotorEnabled = function() {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  return this.m_enableMotor
};
b2RevoluteJoint.prototype.EnableMotor = function(flag) {
  this.m_enableMotor = flag
};
b2RevoluteJoint.prototype.SetMotorSpeed = function(speed) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_motorSpeed = speed
};
b2RevoluteJoint.prototype.GetMotorSpeed = function() {
  return this.m_motorSpeed
};
b2RevoluteJoint.prototype.SetMaxMotorTorque = function(torque) {
  this.m_maxMotorTorque = torque
};
b2RevoluteJoint.prototype.GetMotorTorque = function() {
  return this.m_maxMotorTorque
};
b2RevoluteJoint.prototype.K = new b2Mat22;
b2RevoluteJoint.prototype.K1 = new b2Mat22;
b2RevoluteJoint.prototype.K2 = new b2Mat22;
b2RevoluteJoint.prototype.K3 = new b2Mat22;
b2RevoluteJoint.prototype.impulse3 = new b2Vec3;
b2RevoluteJoint.prototype.impulse2 = new b2Vec2;
b2RevoluteJoint.prototype.reduced = new b2Vec2;
b2RevoluteJoint.prototype.m_localAnchor1 = new b2Vec2;
b2RevoluteJoint.prototype.m_localAnchor2 = new b2Vec2;
b2RevoluteJoint.prototype.m_impulse = new b2Vec3;
b2RevoluteJoint.prototype.m_motorImpulse = null;
b2RevoluteJoint.prototype.m_mass = new b2Mat33;
b2RevoluteJoint.prototype.m_motorMass = null;
b2RevoluteJoint.prototype.m_enableMotor = null;
b2RevoluteJoint.prototype.m_maxMotorTorque = null;
b2RevoluteJoint.prototype.m_motorSpeed = null;
b2RevoluteJoint.prototype.m_enableLimit = null;
b2RevoluteJoint.prototype.m_referenceAngle = null;
b2RevoluteJoint.prototype.m_lowerAngle = null;
b2RevoluteJoint.prototype.m_upperAngle = null;
b2RevoluteJoint.prototype.m_limitState = 0;var b2JointDef = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2JointDef.prototype.__constructor = function() {
  this.type = b2Joint.e_unknownJoint;
  this.userData = null;
  this.bodyA = null;
  this.bodyB = null;
  this.collideConnected = false
};
b2JointDef.prototype.__varz = function() {
};
b2JointDef.prototype.type = 0;
b2JointDef.prototype.userData = null;
b2JointDef.prototype.bodyA = null;
b2JointDef.prototype.bodyB = null;
b2JointDef.prototype.collideConnected = null;var b2LineJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2LineJointDef.prototype, b2JointDef.prototype);
b2LineJointDef.prototype._super = b2JointDef.prototype;
b2LineJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_lineJoint;
  this.localAxisA.Set(1, 0);
  this.enableLimit = false;
  this.lowerTranslation = 0;
  this.upperTranslation = 0;
  this.enableMotor = false;
  this.maxMotorForce = 0;
  this.motorSpeed = 0
};
b2LineJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2;
  this.localAxisA = new b2Vec2
};
b2LineJointDef.prototype.Initialize = function(bA, bB, anchor, axis) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
  this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
  this.localAxisA = this.bodyA.GetLocalVector(axis)
};
b2LineJointDef.prototype.localAnchorA = new b2Vec2;
b2LineJointDef.prototype.localAnchorB = new b2Vec2;
b2LineJointDef.prototype.localAxisA = new b2Vec2;
b2LineJointDef.prototype.enableLimit = null;
b2LineJointDef.prototype.lowerTranslation = null;
b2LineJointDef.prototype.upperTranslation = null;
b2LineJointDef.prototype.enableMotor = null;
b2LineJointDef.prototype.maxMotorForce = null;
b2LineJointDef.prototype.motorSpeed = null;var b2DistanceJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2DistanceJoint.prototype, b2Joint.prototype);
b2DistanceJoint.prototype._super = b2Joint.prototype;
b2DistanceJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var tMat;
  var tX;
  var tY;
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_length = def.length;
  this.m_frequencyHz = def.frequencyHz;
  this.m_dampingRatio = def.dampingRatio;
  this.m_impulse = 0;
  this.m_gamma = 0;
  this.m_bias = 0
};
b2DistanceJoint.prototype.__varz = function() {
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_u = new b2Vec2
};
b2DistanceJoint.prototype.InitVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  this.m_u.x = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  this.m_u.y = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  var length = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
  if(length > b2Settings.b2_linearSlop) {
    this.m_u.Multiply(1 / length)
  }else {
    this.m_u.SetZero()
  }
  var cr1u = r1X * this.m_u.y - r1Y * this.m_u.x;
  var cr2u = r2X * this.m_u.y - r2Y * this.m_u.x;
  var invMass = bA.m_invMass + bA.m_invI * cr1u * cr1u + bB.m_invMass + bB.m_invI * cr2u * cr2u;
  this.m_mass = invMass != 0 ? 1 / invMass : 0;
  if(this.m_frequencyHz > 0) {
    var C = length - this.m_length;
    var omega = 2 * Math.PI * this.m_frequencyHz;
    var d = 2 * this.m_mass * this.m_dampingRatio * omega;
    var k = this.m_mass * omega * omega;
    this.m_gamma = step.dt * (d + step.dt * k);
    this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0;
    this.m_bias = C * step.dt * k * this.m_gamma;
    this.m_mass = invMass + this.m_gamma;
    this.m_mass = this.m_mass != 0 ? 1 / this.m_mass : 0
  }
  if(step.warmStarting) {
    this.m_impulse *= step.dtRatio;
    var PX = this.m_impulse * this.m_u.x;
    var PY = this.m_impulse * this.m_u.y;
    bA.m_linearVelocity.x -= bA.m_invMass * PX;
    bA.m_linearVelocity.y -= bA.m_invMass * PY;
    bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
    bB.m_linearVelocity.x += bB.m_invMass * PX;
    bB.m_linearVelocity.y += bB.m_invMass * PY;
    bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX)
  }else {
    this.m_impulse = 0
  }
};
b2DistanceJoint.prototype.SolveVelocityConstraints = function(step) {
  var tMat;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * r1Y;
  var v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * r1X;
  var v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * r2Y;
  var v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * r2X;
  var Cdot = this.m_u.x * (v2X - v1X) + this.m_u.y * (v2Y - v1Y);
  var impulse = -this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);
  this.m_impulse += impulse;
  var PX = impulse * this.m_u.x;
  var PY = impulse * this.m_u.y;
  bA.m_linearVelocity.x -= bA.m_invMass * PX;
  bA.m_linearVelocity.y -= bA.m_invMass * PY;
  bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
  bB.m_linearVelocity.x += bB.m_invMass * PX;
  bB.m_linearVelocity.y += bB.m_invMass * PY;
  bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX)
};
b2DistanceJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var tMat;
  if(this.m_frequencyHz > 0) {
    return true
  }
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  var length = Math.sqrt(dX * dX + dY * dY);
  dX /= length;
  dY /= length;
  var C = length - this.m_length;
  C = b2Math.Clamp(C, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection);
  var impulse = -this.m_mass * C;
  this.m_u.Set(dX, dY);
  var PX = impulse * this.m_u.x;
  var PY = impulse * this.m_u.y;
  bA.m_sweep.c.x -= bA.m_invMass * PX;
  bA.m_sweep.c.y -= bA.m_invMass * PY;
  bA.m_sweep.a -= bA.m_invI * (r1X * PY - r1Y * PX);
  bB.m_sweep.c.x += bB.m_invMass * PX;
  bB.m_sweep.c.y += bB.m_invMass * PY;
  bB.m_sweep.a += bB.m_invI * (r2X * PY - r2Y * PX);
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return b2Math.Abs(C) < b2Settings.b2_linearSlop
};
b2DistanceJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2DistanceJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2DistanceJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse * this.m_u.x, inv_dt * this.m_impulse * this.m_u.y)
};
b2DistanceJoint.prototype.GetReactionTorque = function(inv_dt) {
  return 0
};
b2DistanceJoint.prototype.GetLength = function() {
  return this.m_length
};
b2DistanceJoint.prototype.SetLength = function(length) {
  this.m_length = length
};
b2DistanceJoint.prototype.GetFrequency = function() {
  return this.m_frequencyHz
};
b2DistanceJoint.prototype.SetFrequency = function(hz) {
  this.m_frequencyHz = hz
};
b2DistanceJoint.prototype.GetDampingRatio = function() {
  return this.m_dampingRatio
};
b2DistanceJoint.prototype.SetDampingRatio = function(ratio) {
  this.m_dampingRatio = ratio
};
b2DistanceJoint.prototype.m_localAnchor1 = new b2Vec2;
b2DistanceJoint.prototype.m_localAnchor2 = new b2Vec2;
b2DistanceJoint.prototype.m_u = new b2Vec2;
b2DistanceJoint.prototype.m_frequencyHz = null;
b2DistanceJoint.prototype.m_dampingRatio = null;
b2DistanceJoint.prototype.m_gamma = null;
b2DistanceJoint.prototype.m_bias = null;
b2DistanceJoint.prototype.m_impulse = null;
b2DistanceJoint.prototype.m_mass = null;
b2DistanceJoint.prototype.m_length = null;var b2PulleyJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PulleyJointDef.prototype, b2JointDef.prototype);
b2PulleyJointDef.prototype._super = b2JointDef.prototype;
b2PulleyJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_pulleyJoint;
  this.groundAnchorA.Set(-1, 1);
  this.groundAnchorB.Set(1, 1);
  this.localAnchorA.Set(-1, 0);
  this.localAnchorB.Set(1, 0);
  this.lengthA = 0;
  this.maxLengthA = 0;
  this.lengthB = 0;
  this.maxLengthB = 0;
  this.ratio = 1;
  this.collideConnected = true
};
b2PulleyJointDef.prototype.__varz = function() {
  this.groundAnchorA = new b2Vec2;
  this.groundAnchorB = new b2Vec2;
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2PulleyJointDef.prototype.Initialize = function(bA, bB, gaA, gaB, anchorA, anchorB, r) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.groundAnchorA.SetV(gaA);
  this.groundAnchorB.SetV(gaB);
  this.localAnchorA = this.bodyA.GetLocalPoint(anchorA);
  this.localAnchorB = this.bodyB.GetLocalPoint(anchorB);
  var d1X = anchorA.x - gaA.x;
  var d1Y = anchorA.y - gaA.y;
  this.lengthA = Math.sqrt(d1X * d1X + d1Y * d1Y);
  var d2X = anchorB.x - gaB.x;
  var d2Y = anchorB.y - gaB.y;
  this.lengthB = Math.sqrt(d2X * d2X + d2Y * d2Y);
  this.ratio = r;
  var C = this.lengthA + this.ratio * this.lengthB;
  this.maxLengthA = C - this.ratio * b2PulleyJoint.b2_minPulleyLength;
  this.maxLengthB = (C - b2PulleyJoint.b2_minPulleyLength) / this.ratio
};
b2PulleyJointDef.prototype.groundAnchorA = new b2Vec2;
b2PulleyJointDef.prototype.groundAnchorB = new b2Vec2;
b2PulleyJointDef.prototype.localAnchorA = new b2Vec2;
b2PulleyJointDef.prototype.localAnchorB = new b2Vec2;
b2PulleyJointDef.prototype.lengthA = null;
b2PulleyJointDef.prototype.maxLengthA = null;
b2PulleyJointDef.prototype.lengthB = null;
b2PulleyJointDef.prototype.maxLengthB = null;
b2PulleyJointDef.prototype.ratio = null;var b2DistanceJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2DistanceJointDef.prototype, b2JointDef.prototype);
b2DistanceJointDef.prototype._super = b2JointDef.prototype;
b2DistanceJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_distanceJoint;
  this.length = 1;
  this.frequencyHz = 0;
  this.dampingRatio = 0
};
b2DistanceJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2DistanceJointDef.prototype.Initialize = function(bA, bB, anchorA, anchorB) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchorA));
  this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchorB));
  var dX = anchorB.x - anchorA.x;
  var dY = anchorB.y - anchorA.y;
  this.length = Math.sqrt(dX * dX + dY * dY);
  this.frequencyHz = 0;
  this.dampingRatio = 0
};
b2DistanceJointDef.prototype.localAnchorA = new b2Vec2;
b2DistanceJointDef.prototype.localAnchorB = new b2Vec2;
b2DistanceJointDef.prototype.length = null;
b2DistanceJointDef.prototype.frequencyHz = null;
b2DistanceJointDef.prototype.dampingRatio = null;var b2FrictionJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2FrictionJointDef.prototype, b2JointDef.prototype);
b2FrictionJointDef.prototype._super = b2JointDef.prototype;
b2FrictionJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_frictionJoint;
  this.maxForce = 0;
  this.maxTorque = 0
};
b2FrictionJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2FrictionJointDef.prototype.Initialize = function(bA, bB, anchor) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
  this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor))
};
b2FrictionJointDef.prototype.localAnchorA = new b2Vec2;
b2FrictionJointDef.prototype.localAnchorB = new b2Vec2;
b2FrictionJointDef.prototype.maxForce = null;
b2FrictionJointDef.prototype.maxTorque = null;var b2WeldJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2WeldJointDef.prototype, b2JointDef.prototype);
b2WeldJointDef.prototype._super = b2JointDef.prototype;
b2WeldJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_weldJoint;
  this.referenceAngle = 0
};
b2WeldJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2WeldJointDef.prototype.Initialize = function(bA, bB, anchor) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
  this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
  this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
};
b2WeldJointDef.prototype.localAnchorA = new b2Vec2;
b2WeldJointDef.prototype.localAnchorB = new b2Vec2;
b2WeldJointDef.prototype.referenceAngle = null;var b2GearJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2GearJointDef.prototype, b2JointDef.prototype);
b2GearJointDef.prototype._super = b2JointDef.prototype;
b2GearJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_gearJoint;
  this.joint1 = null;
  this.joint2 = null;
  this.ratio = 1
};
b2GearJointDef.prototype.__varz = function() {
};
b2GearJointDef.prototype.joint1 = null;
b2GearJointDef.prototype.joint2 = null;
b2GearJointDef.prototype.ratio = null;var b2Color = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Color.prototype.__constructor = function(rr, gg, bb) {
  this._r = parseInt(255 * b2Math.Clamp(rr, 0, 1));
  this._g = parseInt(255 * b2Math.Clamp(gg, 0, 1));
  this._b = parseInt(255 * b2Math.Clamp(bb, 0, 1))
};
b2Color.prototype.__varz = function() {
};
b2Color.prototype.Set = function(rr, gg, bb) {
  this._r = parseInt(255 * b2Math.Clamp(rr, 0, 1));
  this._g = parseInt(255 * b2Math.Clamp(gg, 0, 1));
  this._b = parseInt(255 * b2Math.Clamp(bb, 0, 1))
};
b2Color.prototype.__defineGetter__("r", function() {
  return this._r
});
b2Color.prototype.__defineSetter__("r", function(rr) {
  this._r = parseInt(255 * b2Math.Clamp(rr, 0, 1))
});
b2Color.prototype.__defineGetter__("g", function() {
  return this._g
});
b2Color.prototype.__defineSetter__("g", function(gg) {
  this._g = parseInt(255 * b2Math.Clamp(gg, 0, 1))
});
b2Color.prototype.__defineGetter__("b", function() {
  return this._g
});
b2Color.prototype.__defineSetter__("b", function(bb) {
  this._b = parseInt(255 * b2Math.Clamp(bb, 0, 1))
});
b2Color.prototype.__defineGetter__("color", function() {
  return this._r << 16 | this._g << 8 | this._b
});
b2Color.prototype._r = 0;
b2Color.prototype._g = 0;
b2Color.prototype._b = 0;var b2FrictionJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2FrictionJoint.prototype, b2Joint.prototype);
b2FrictionJoint.prototype._super = b2Joint.prototype;
b2FrictionJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  this.m_localAnchorA.SetV(def.localAnchorA);
  this.m_localAnchorB.SetV(def.localAnchorB);
  this.m_linearMass.SetZero();
  this.m_angularMass = 0;
  this.m_linearImpulse.SetZero();
  this.m_angularImpulse = 0;
  this.m_maxForce = def.maxForce;
  this.m_maxTorque = def.maxTorque
};
b2FrictionJoint.prototype.__varz = function() {
  this.m_localAnchorA = new b2Vec2;
  this.m_localAnchorB = new b2Vec2;
  this.m_linearImpulse = new b2Vec2;
  this.m_linearMass = new b2Mat22
};
b2FrictionJoint.prototype.InitVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  var K = new b2Mat22;
  K.col1.x = mA + mB;
  K.col2.x = 0;
  K.col1.y = 0;
  K.col2.y = mA + mB;
  K.col1.x += iA * rAY * rAY;
  K.col2.x += -iA * rAX * rAY;
  K.col1.y += -iA * rAX * rAY;
  K.col2.y += iA * rAX * rAX;
  K.col1.x += iB * rBY * rBY;
  K.col2.x += -iB * rBX * rBY;
  K.col1.y += -iB * rBX * rBY;
  K.col2.y += iB * rBX * rBX;
  K.GetInverse(this.m_linearMass);
  this.m_angularMass = iA + iB;
  if(this.m_angularMass > 0) {
    this.m_angularMass = 1 / this.m_angularMass
  }
  if(step.warmStarting) {
    this.m_linearImpulse.x *= step.dtRatio;
    this.m_linearImpulse.y *= step.dtRatio;
    this.m_angularImpulse *= step.dtRatio;
    var P = this.m_linearImpulse;
    bA.m_linearVelocity.x -= mA * P.x;
    bA.m_linearVelocity.y -= mA * P.y;
    bA.m_angularVelocity -= iA * (rAX * P.y - rAY * P.x + this.m_angularImpulse);
    bB.m_linearVelocity.x += mB * P.x;
    bB.m_linearVelocity.y += mB * P.y;
    bB.m_angularVelocity += iB * (rBX * P.y - rBY * P.x + this.m_angularImpulse)
  }else {
    this.m_linearImpulse.SetZero();
    this.m_angularImpulse = 0
  }
};
b2FrictionJoint.prototype.SolveVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var vA = bA.m_linearVelocity;
  var wA = bA.m_angularVelocity;
  var vB = bB.m_linearVelocity;
  var wB = bB.m_angularVelocity;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var maxImpulse;
  var Cdot = wB - wA;
  var impulse = -this.m_angularMass * Cdot;
  var oldImpulse = this.m_angularImpulse;
  maxImpulse = step.dt * this.m_maxTorque;
  this.m_angularImpulse = b2Math.Clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);
  impulse = this.m_angularImpulse - oldImpulse;
  wA -= iA * impulse;
  wB += iB * impulse;
  var CdotX = vB.x - wB * rBY - vA.x + wA * rAY;
  var CdotY = vB.y + wB * rBX - vA.y - wA * rAX;
  var impulseV = b2Math.MulMV(this.m_linearMass, new b2Vec2(-CdotX, -CdotY));
  var oldImpulseV = this.m_linearImpulse.Copy();
  this.m_linearImpulse.Add(impulseV);
  maxImpulse = step.dt * this.m_maxForce;
  if(this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
    this.m_linearImpulse.Normalize();
    this.m_linearImpulse.Multiply(maxImpulse)
  }
  impulseV = b2Math.SubtractVV(this.m_linearImpulse, oldImpulseV);
  vA.x -= mA * impulseV.x;
  vA.y -= mA * impulseV.y;
  wA -= iA * (rAX * impulseV.y - rAY * impulseV.x);
  vB.x += mB * impulseV.x;
  vB.y += mB * impulseV.y;
  wB += iB * (rBX * impulseV.y - rBY * impulseV.x);
  bA.m_angularVelocity = wA;
  bB.m_angularVelocity = wB
};
b2FrictionJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  return true
};
b2FrictionJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)
};
b2FrictionJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)
};
b2FrictionJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_linearImpulse.x, inv_dt * this.m_linearImpulse.y)
};
b2FrictionJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_angularImpulse
};
b2FrictionJoint.prototype.SetMaxForce = function(force) {
  this.m_maxForce = force
};
b2FrictionJoint.prototype.GetMaxForce = function() {
  return this.m_maxForce
};
b2FrictionJoint.prototype.SetMaxTorque = function(torque) {
  this.m_maxTorque = torque
};
b2FrictionJoint.prototype.GetMaxTorque = function() {
  return this.m_maxTorque
};
b2FrictionJoint.prototype.m_localAnchorA = new b2Vec2;
b2FrictionJoint.prototype.m_localAnchorB = new b2Vec2;
b2FrictionJoint.prototype.m_linearImpulse = new b2Vec2;
b2FrictionJoint.prototype.m_angularImpulse = null;
b2FrictionJoint.prototype.m_maxForce = null;
b2FrictionJoint.prototype.m_maxTorque = null;
b2FrictionJoint.prototype.m_linearMass = new b2Mat22;
b2FrictionJoint.prototype.m_angularMass = null;var b2Distance = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Distance.prototype.__constructor = function() {
};
b2Distance.prototype.__varz = function() {
};
b2Distance.Distance = function(output, cache, input) {
  ++b2Distance.b2_gjkCalls;
  var proxyA = input.proxyA;
  var proxyB = input.proxyB;
  var transformA = input.transformA;
  var transformB = input.transformB;
  var simplex = b2Distance.s_simplex;
  simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
  var vertices = simplex.m_vertices;
  var k_maxIters = 20;
  var saveA = b2Distance.s_saveA;
  var saveB = b2Distance.s_saveB;
  var saveCount = 0;
  var closestPoint = simplex.GetClosestPoint();
  var distanceSqr1 = closestPoint.LengthSquared();
  var distanceSqr2 = distanceSqr1;
  var i = 0;
  var p;
  var iter = 0;
  while(iter < k_maxIters) {
    saveCount = simplex.m_count;
    for(i = 0;i < saveCount;i++) {
      saveA[i] = vertices[i].indexA;
      saveB[i] = vertices[i].indexB
    }
    switch(simplex.m_count) {
      case 1:
        break;
      case 2:
        simplex.Solve2();
        break;
      case 3:
        simplex.Solve3();
        break;
      default:
        b2Settings.b2Assert(false)
    }
    if(simplex.m_count == 3) {
      break
    }
    p = simplex.GetClosestPoint();
    distanceSqr2 = p.LengthSquared();
    if(distanceSqr2 > distanceSqr1) {
    }
    distanceSqr1 = distanceSqr2;
    var d = simplex.GetSearchDirection();
    if(d.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE) {
      break
    }
    var vertex = vertices[simplex.m_count];
    vertex.indexA = proxyA.GetSupport(b2Math.MulTMV(transformA.R, d.GetNegative()));
    vertex.wA = b2Math.MulX(transformA, proxyA.GetVertex(vertex.indexA));
    vertex.indexB = proxyB.GetSupport(b2Math.MulTMV(transformB.R, d));
    vertex.wB = b2Math.MulX(transformB, proxyB.GetVertex(vertex.indexB));
    vertex.w = b2Math.SubtractVV(vertex.wB, vertex.wA);
    ++iter;
    ++b2Distance.b2_gjkIters;
    var duplicate = false;
    for(i = 0;i < saveCount;i++) {
      if(vertex.indexA == saveA[i] && vertex.indexB == saveB[i]) {
        duplicate = true;
        break
      }
    }
    if(duplicate) {
      break
    }
    ++simplex.m_count
  }
  b2Distance.b2_gjkMaxIters = b2Math.Max(b2Distance.b2_gjkMaxIters, iter);
  simplex.GetWitnessPoints(output.pointA, output.pointB);
  output.distance = b2Math.SubtractVV(output.pointA, output.pointB).Length();
  output.iterations = iter;
  simplex.WriteCache(cache);
  if(input.useRadii) {
    var rA = proxyA.m_radius;
    var rB = proxyB.m_radius;
    if(output.distance > rA + rB && output.distance > Number.MIN_VALUE) {
      output.distance -= rA + rB;
      var normal = b2Math.SubtractVV(output.pointB, output.pointA);
      normal.Normalize();
      output.pointA.x += rA * normal.x;
      output.pointA.y += rA * normal.y;
      output.pointB.x -= rB * normal.x;
      output.pointB.y -= rB * normal.y
    }else {
      p = new b2Vec2;
      p.x = 0.5 * (output.pointA.x + output.pointB.x);
      p.y = 0.5 * (output.pointA.y + output.pointB.y);
      output.pointA.x = output.pointB.x = p.x;
      output.pointA.y = output.pointB.y = p.y;
      output.distance = 0
    }
  }
};
b2Distance.b2_gjkCalls = 0;
b2Distance.b2_gjkIters = 0;
b2Distance.b2_gjkMaxIters = 0;
b2Distance.s_simplex = new b2Simplex;
b2Distance.s_saveA = new Array(3);
b2Distance.s_saveB = new Array(3);var b2MouseJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2MouseJoint.prototype, b2Joint.prototype);
b2MouseJoint.prototype._super = b2Joint.prototype;
b2MouseJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  this.m_target.SetV(def.target);
  var tX = this.m_target.x - this.m_bodyB.m_xf.position.x;
  var tY = this.m_target.y - this.m_bodyB.m_xf.position.y;
  var tMat = this.m_bodyB.m_xf.R;
  this.m_localAnchor.x = tX * tMat.col1.x + tY * tMat.col1.y;
  this.m_localAnchor.y = tX * tMat.col2.x + tY * tMat.col2.y;
  this.m_maxForce = def.maxForce;
  this.m_impulse.SetZero();
  this.m_frequencyHz = def.frequencyHz;
  this.m_dampingRatio = def.dampingRatio;
  this.m_beta = 0;
  this.m_gamma = 0
};
b2MouseJoint.prototype.__varz = function() {
  this.K = new b2Mat22;
  this.K1 = new b2Mat22;
  this.K2 = new b2Mat22;
  this.m_localAnchor = new b2Vec2;
  this.m_target = new b2Vec2;
  this.m_impulse = new b2Vec2;
  this.m_mass = new b2Mat22;
  this.m_C = new b2Vec2
};
b2MouseJoint.prototype.InitVelocityConstraints = function(step) {
  var b = this.m_bodyB;
  var mass = b.GetMass();
  var omega = 2 * Math.PI * this.m_frequencyHz;
  var d = 2 * mass * this.m_dampingRatio * omega;
  var k = mass * omega * omega;
  this.m_gamma = step.dt * (d + step.dt * k);
  this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0;
  this.m_beta = step.dt * k * this.m_gamma;
  var tMat;
  tMat = b.m_xf.R;
  var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
  var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
  var tX = tMat.col1.x * rX + tMat.col2.x * rY;
  rY = tMat.col1.y * rX + tMat.col2.y * rY;
  rX = tX;
  var invMass = b.m_invMass;
  var invI = b.m_invI;
  this.K1.col1.x = invMass;
  this.K1.col2.x = 0;
  this.K1.col1.y = 0;
  this.K1.col2.y = invMass;
  this.K2.col1.x = invI * rY * rY;
  this.K2.col2.x = -invI * rX * rY;
  this.K2.col1.y = -invI * rX * rY;
  this.K2.col2.y = invI * rX * rX;
  this.K.SetM(this.K1);
  this.K.AddM(this.K2);
  this.K.col1.x += this.m_gamma;
  this.K.col2.y += this.m_gamma;
  this.K.GetInverse(this.m_mass);
  this.m_C.x = b.m_sweep.c.x + rX - this.m_target.x;
  this.m_C.y = b.m_sweep.c.y + rY - this.m_target.y;
  b.m_angularVelocity *= 0.98;
  this.m_impulse.x *= step.dtRatio;
  this.m_impulse.y *= step.dtRatio;
  b.m_linearVelocity.x += invMass * this.m_impulse.x;
  b.m_linearVelocity.y += invMass * this.m_impulse.y;
  b.m_angularVelocity += invI * (rX * this.m_impulse.y - rY * this.m_impulse.x)
};
b2MouseJoint.prototype.SolveVelocityConstraints = function(step) {
  var b = this.m_bodyB;
  var tMat;
  var tX;
  var tY;
  tMat = b.m_xf.R;
  var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
  var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
  tX = tMat.col1.x * rX + tMat.col2.x * rY;
  rY = tMat.col1.y * rX + tMat.col2.y * rY;
  rX = tX;
  var CdotX = b.m_linearVelocity.x + -b.m_angularVelocity * rY;
  var CdotY = b.m_linearVelocity.y + b.m_angularVelocity * rX;
  tMat = this.m_mass;
  tX = CdotX + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x;
  tY = CdotY + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
  var impulseX = -(tMat.col1.x * tX + tMat.col2.x * tY);
  var impulseY = -(tMat.col1.y * tX + tMat.col2.y * tY);
  var oldImpulseX = this.m_impulse.x;
  var oldImpulseY = this.m_impulse.y;
  this.m_impulse.x += impulseX;
  this.m_impulse.y += impulseY;
  var maxImpulse = step.dt * this.m_maxForce;
  if(this.m_impulse.LengthSquared() > maxImpulse * maxImpulse) {
    this.m_impulse.Multiply(maxImpulse / this.m_impulse.Length())
  }
  impulseX = this.m_impulse.x - oldImpulseX;
  impulseY = this.m_impulse.y - oldImpulseY;
  b.m_linearVelocity.x += b.m_invMass * impulseX;
  b.m_linearVelocity.y += b.m_invMass * impulseY;
  b.m_angularVelocity += b.m_invI * (rX * impulseY - rY * impulseX)
};
b2MouseJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  return true
};
b2MouseJoint.prototype.GetAnchorA = function() {
  return this.m_target
};
b2MouseJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor)
};
b2MouseJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y)
};
b2MouseJoint.prototype.GetReactionTorque = function(inv_dt) {
  return 0
};
b2MouseJoint.prototype.GetTarget = function() {
  return this.m_target
};
b2MouseJoint.prototype.SetTarget = function(target) {
  if(this.m_bodyB.IsAwake() == false) {
    this.m_bodyB.SetAwake(true)
  }
  this.m_target = target
};
b2MouseJoint.prototype.GetMaxForce = function() {
  return this.m_maxForce
};
b2MouseJoint.prototype.SetMaxForce = function(maxForce) {
  this.m_maxForce = maxForce
};
b2MouseJoint.prototype.GetFrequency = function() {
  return this.m_frequencyHz
};
b2MouseJoint.prototype.SetFrequency = function(hz) {
  this.m_frequencyHz = hz
};
b2MouseJoint.prototype.GetDampingRatio = function() {
  return this.m_dampingRatio
};
b2MouseJoint.prototype.SetDampingRatio = function(ratio) {
  this.m_dampingRatio = ratio
};
b2MouseJoint.prototype.K = new b2Mat22;
b2MouseJoint.prototype.K1 = new b2Mat22;
b2MouseJoint.prototype.K2 = new b2Mat22;
b2MouseJoint.prototype.m_localAnchor = new b2Vec2;
b2MouseJoint.prototype.m_target = new b2Vec2;
b2MouseJoint.prototype.m_impulse = new b2Vec2;
b2MouseJoint.prototype.m_mass = new b2Mat22;
b2MouseJoint.prototype.m_C = new b2Vec2;
b2MouseJoint.prototype.m_maxForce = null;
b2MouseJoint.prototype.m_frequencyHz = null;
b2MouseJoint.prototype.m_dampingRatio = null;
b2MouseJoint.prototype.m_beta = null;
b2MouseJoint.prototype.m_gamma = null;var b2PrismaticJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PrismaticJointDef.prototype, b2JointDef.prototype);
b2PrismaticJointDef.prototype._super = b2JointDef.prototype;
b2PrismaticJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_prismaticJoint;
  this.localAxisA.Set(1, 0);
  this.referenceAngle = 0;
  this.enableLimit = false;
  this.lowerTranslation = 0;
  this.upperTranslation = 0;
  this.enableMotor = false;
  this.maxMotorForce = 0;
  this.motorSpeed = 0
};
b2PrismaticJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2;
  this.localAxisA = new b2Vec2
};
b2PrismaticJointDef.prototype.Initialize = function(bA, bB, anchor, axis) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
  this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
  this.localAxisA = this.bodyA.GetLocalVector(axis);
  this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
};
b2PrismaticJointDef.prototype.localAnchorA = new b2Vec2;
b2PrismaticJointDef.prototype.localAnchorB = new b2Vec2;
b2PrismaticJointDef.prototype.localAxisA = new b2Vec2;
b2PrismaticJointDef.prototype.referenceAngle = null;
b2PrismaticJointDef.prototype.enableLimit = null;
b2PrismaticJointDef.prototype.lowerTranslation = null;
b2PrismaticJointDef.prototype.upperTranslation = null;
b2PrismaticJointDef.prototype.enableMotor = null;
b2PrismaticJointDef.prototype.maxMotorForce = null;
b2PrismaticJointDef.prototype.motorSpeed = null;var b2TimeOfImpact = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2TimeOfImpact.prototype.__constructor = function() {
};
b2TimeOfImpact.prototype.__varz = function() {
};
b2TimeOfImpact.TimeOfImpact = function(input) {
  ++b2TimeOfImpact.b2_toiCalls;
  var proxyA = input.proxyA;
  var proxyB = input.proxyB;
  var sweepA = input.sweepA;
  var sweepB = input.sweepB;
  b2Settings.b2Assert(sweepA.t0 == sweepB.t0);
  b2Settings.b2Assert(1 - sweepA.t0 > Number.MIN_VALUE);
  var radius = proxyA.m_radius + proxyB.m_radius;
  var tolerance = input.tolerance;
  var alpha = 0;
  var k_maxIterations = 1E3;
  var iter = 0;
  var target = 0;
  b2TimeOfImpact.s_cache.count = 0;
  b2TimeOfImpact.s_distanceInput.useRadii = false;
  for(;;) {
    sweepA.GetTransform(b2TimeOfImpact.s_xfA, alpha);
    sweepB.GetTransform(b2TimeOfImpact.s_xfB, alpha);
    b2TimeOfImpact.s_distanceInput.proxyA = proxyA;
    b2TimeOfImpact.s_distanceInput.proxyB = proxyB;
    b2TimeOfImpact.s_distanceInput.transformA = b2TimeOfImpact.s_xfA;
    b2TimeOfImpact.s_distanceInput.transformB = b2TimeOfImpact.s_xfB;
    b2Distance.Distance(b2TimeOfImpact.s_distanceOutput, b2TimeOfImpact.s_cache, b2TimeOfImpact.s_distanceInput);
    if(b2TimeOfImpact.s_distanceOutput.distance <= 0) {
      alpha = 1;
      break
    }
    b2TimeOfImpact.s_fcn.Initialize(b2TimeOfImpact.s_cache, proxyA, b2TimeOfImpact.s_xfA, proxyB, b2TimeOfImpact.s_xfB);
    var separation = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
    if(separation <= 0) {
      alpha = 1;
      break
    }
    if(iter == 0) {
      if(separation > radius) {
        target = b2Math.Max(radius - tolerance, 0.75 * radius)
      }else {
        target = b2Math.Max(separation - tolerance, 0.02 * radius)
      }
    }
    if(separation - target < 0.5 * tolerance) {
      if(iter == 0) {
        alpha = 1;
        break
      }
      break
    }
    var newAlpha = alpha;
    var x1 = alpha;
    var x2 = 1;
    var f1 = separation;
    sweepA.GetTransform(b2TimeOfImpact.s_xfA, x2);
    sweepB.GetTransform(b2TimeOfImpact.s_xfB, x2);
    var f2 = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
    if(f2 >= target) {
      alpha = 1;
      break
    }
    var rootIterCount = 0;
    for(;;) {
      var x;
      if(rootIterCount & 1) {
        x = x1 + (target - f1) * (x2 - x1) / (f2 - f1)
      }else {
        x = 0.5 * (x1 + x2)
      }
      sweepA.GetTransform(b2TimeOfImpact.s_xfA, x);
      sweepB.GetTransform(b2TimeOfImpact.s_xfB, x);
      var f = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
      if(b2Math.Abs(f - target) < 0.025 * tolerance) {
        newAlpha = x;
        break
      }
      if(f > target) {
        x1 = x;
        f1 = f
      }else {
        x2 = x;
        f2 = f
      }
      ++rootIterCount;
      ++b2TimeOfImpact.b2_toiRootIters;
      if(rootIterCount == 50) {
        break
      }
    }
    b2TimeOfImpact.b2_toiMaxRootIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxRootIters, rootIterCount);
    if(newAlpha < (1 + 100 * Number.MIN_VALUE) * alpha) {
      break
    }
    alpha = newAlpha;
    iter++;
    ++b2TimeOfImpact.b2_toiIters;
    if(iter == k_maxIterations) {
      break
    }
  }
  b2TimeOfImpact.b2_toiMaxIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxIters, iter);
  return alpha
};
b2TimeOfImpact.b2_toiCalls = 0;
b2TimeOfImpact.b2_toiIters = 0;
b2TimeOfImpact.b2_toiMaxIters = 0;
b2TimeOfImpact.b2_toiRootIters = 0;
b2TimeOfImpact.b2_toiMaxRootIters = 0;
b2TimeOfImpact.s_cache = new b2SimplexCache;
b2TimeOfImpact.s_distanceInput = new b2DistanceInput;
b2TimeOfImpact.s_xfA = new b2Transform;
b2TimeOfImpact.s_xfB = new b2Transform;
b2TimeOfImpact.s_fcn = new b2SeparationFunction;
b2TimeOfImpact.s_distanceOutput = new b2DistanceOutput;var b2GearJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2GearJoint.prototype, b2Joint.prototype);
b2GearJoint.prototype._super = b2Joint.prototype;
b2GearJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var type1 = def.joint1.m_type;
  var type2 = def.joint2.m_type;
  this.m_revolute1 = null;
  this.m_prismatic1 = null;
  this.m_revolute2 = null;
  this.m_prismatic2 = null;
  var coordinate1;
  var coordinate2;
  this.m_ground1 = def.joint1.GetBodyA();
  this.m_bodyA = def.joint1.GetBodyB();
  if(type1 == b2Joint.e_revoluteJoint) {
    this.m_revolute1 = def.joint1;
    this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1);
    this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2);
    coordinate1 = this.m_revolute1.GetJointAngle()
  }else {
    this.m_prismatic1 = def.joint1;
    this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1);
    this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2);
    coordinate1 = this.m_prismatic1.GetJointTranslation()
  }
  this.m_ground2 = def.joint2.GetBodyA();
  this.m_bodyB = def.joint2.GetBodyB();
  if(type2 == b2Joint.e_revoluteJoint) {
    this.m_revolute2 = def.joint2;
    this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1);
    this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2);
    coordinate2 = this.m_revolute2.GetJointAngle()
  }else {
    this.m_prismatic2 = def.joint2;
    this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1);
    this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2);
    coordinate2 = this.m_prismatic2.GetJointTranslation()
  }
  this.m_ratio = def.ratio;
  this.m_constant = coordinate1 + this.m_ratio * coordinate2;
  this.m_impulse = 0
};
b2GearJoint.prototype.__varz = function() {
  this.m_groundAnchor1 = new b2Vec2;
  this.m_groundAnchor2 = new b2Vec2;
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_J = new b2Jacobian
};
b2GearJoint.prototype.InitVelocityConstraints = function(step) {
  var g1 = this.m_ground1;
  var g2 = this.m_ground2;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var ugX;
  var ugY;
  var rX;
  var rY;
  var tMat;
  var tVec;
  var crug;
  var tX;
  var K = 0;
  this.m_J.SetZero();
  if(this.m_revolute1) {
    this.m_J.angularA = -1;
    K += bA.m_invI
  }else {
    tMat = g1.m_xf.R;
    tVec = this.m_prismatic1.m_localXAxis1;
    ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
    ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
    tMat = bA.m_xf.R;
    rX = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    rY = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * rX + tMat.col2.x * rY;
    rY = tMat.col1.y * rX + tMat.col2.y * rY;
    rX = tX;
    crug = rX * ugY - rY * ugX;
    this.m_J.linearA.Set(-ugX, -ugY);
    this.m_J.angularA = -crug;
    K += bA.m_invMass + bA.m_invI * crug * crug
  }
  if(this.m_revolute2) {
    this.m_J.angularB = -this.m_ratio;
    K += this.m_ratio * this.m_ratio * bB.m_invI
  }else {
    tMat = g2.m_xf.R;
    tVec = this.m_prismatic2.m_localXAxis1;
    ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
    ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
    tMat = bB.m_xf.R;
    rX = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    rY = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * rX + tMat.col2.x * rY;
    rY = tMat.col1.y * rX + tMat.col2.y * rY;
    rX = tX;
    crug = rX * ugY - rY * ugX;
    this.m_J.linearB.Set(-this.m_ratio * ugX, -this.m_ratio * ugY);
    this.m_J.angularB = -this.m_ratio * crug;
    K += this.m_ratio * this.m_ratio * (bB.m_invMass + bB.m_invI * crug * crug)
  }
  this.m_mass = K > 0 ? 1 / K : 0;
  if(step.warmStarting) {
    bA.m_linearVelocity.x += bA.m_invMass * this.m_impulse * this.m_J.linearA.x;
    bA.m_linearVelocity.y += bA.m_invMass * this.m_impulse * this.m_J.linearA.y;
    bA.m_angularVelocity += bA.m_invI * this.m_impulse * this.m_J.angularA;
    bB.m_linearVelocity.x += bB.m_invMass * this.m_impulse * this.m_J.linearB.x;
    bB.m_linearVelocity.y += bB.m_invMass * this.m_impulse * this.m_J.linearB.y;
    bB.m_angularVelocity += bB.m_invI * this.m_impulse * this.m_J.angularB
  }else {
    this.m_impulse = 0
  }
};
b2GearJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var Cdot = this.m_J.Compute(bA.m_linearVelocity, bA.m_angularVelocity, bB.m_linearVelocity, bB.m_angularVelocity);
  var impulse = -this.m_mass * Cdot;
  this.m_impulse += impulse;
  bA.m_linearVelocity.x += bA.m_invMass * impulse * this.m_J.linearA.x;
  bA.m_linearVelocity.y += bA.m_invMass * impulse * this.m_J.linearA.y;
  bA.m_angularVelocity += bA.m_invI * impulse * this.m_J.angularA;
  bB.m_linearVelocity.x += bB.m_invMass * impulse * this.m_J.linearB.x;
  bB.m_linearVelocity.y += bB.m_invMass * impulse * this.m_J.linearB.y;
  bB.m_angularVelocity += bB.m_invI * impulse * this.m_J.angularB
};
b2GearJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var linearError = 0;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var coordinate1;
  var coordinate2;
  if(this.m_revolute1) {
    coordinate1 = this.m_revolute1.GetJointAngle()
  }else {
    coordinate1 = this.m_prismatic1.GetJointTranslation()
  }
  if(this.m_revolute2) {
    coordinate2 = this.m_revolute2.GetJointAngle()
  }else {
    coordinate2 = this.m_prismatic2.GetJointTranslation()
  }
  var C = this.m_constant - (coordinate1 + this.m_ratio * coordinate2);
  var impulse = -this.m_mass * C;
  bA.m_sweep.c.x += bA.m_invMass * impulse * this.m_J.linearA.x;
  bA.m_sweep.c.y += bA.m_invMass * impulse * this.m_J.linearA.y;
  bA.m_sweep.a += bA.m_invI * impulse * this.m_J.angularA;
  bB.m_sweep.c.x += bB.m_invMass * impulse * this.m_J.linearB.x;
  bB.m_sweep.c.y += bB.m_invMass * impulse * this.m_J.linearB.y;
  bB.m_sweep.a += bB.m_invI * impulse * this.m_J.angularB;
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return linearError < b2Settings.b2_linearSlop
};
b2GearJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2GearJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2GearJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse * this.m_J.linearB.x, inv_dt * this.m_impulse * this.m_J.linearB.y)
};
b2GearJoint.prototype.GetReactionTorque = function(inv_dt) {
  var tMat = this.m_bodyB.m_xf.R;
  var rX = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x;
  var rY = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y;
  var tX = tMat.col1.x * rX + tMat.col2.x * rY;
  rY = tMat.col1.y * rX + tMat.col2.y * rY;
  rX = tX;
  var PX = this.m_impulse * this.m_J.linearB.x;
  var PY = this.m_impulse * this.m_J.linearB.y;
  return inv_dt * (this.m_impulse * this.m_J.angularB - rX * PY + rY * PX)
};
b2GearJoint.prototype.GetRatio = function() {
  return this.m_ratio
};
b2GearJoint.prototype.SetRatio = function(ratio) {
  this.m_ratio = ratio
};
b2GearJoint.prototype.m_ground1 = null;
b2GearJoint.prototype.m_ground2 = null;
b2GearJoint.prototype.m_revolute1 = null;
b2GearJoint.prototype.m_prismatic1 = null;
b2GearJoint.prototype.m_revolute2 = null;
b2GearJoint.prototype.m_prismatic2 = null;
b2GearJoint.prototype.m_groundAnchor1 = new b2Vec2;
b2GearJoint.prototype.m_groundAnchor2 = new b2Vec2;
b2GearJoint.prototype.m_localAnchor1 = new b2Vec2;
b2GearJoint.prototype.m_localAnchor2 = new b2Vec2;
b2GearJoint.prototype.m_J = new b2Jacobian;
b2GearJoint.prototype.m_constant = null;
b2GearJoint.prototype.m_ratio = null;
b2GearJoint.prototype.m_mass = null;
b2GearJoint.prototype.m_impulse = null;var b2TOIInput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2TOIInput.prototype.__constructor = function() {
};
b2TOIInput.prototype.__varz = function() {
  this.proxyA = new b2DistanceProxy;
  this.proxyB = new b2DistanceProxy;
  this.sweepA = new b2Sweep;
  this.sweepB = new b2Sweep
};
b2TOIInput.prototype.proxyA = new b2DistanceProxy;
b2TOIInput.prototype.proxyB = new b2DistanceProxy;
b2TOIInput.prototype.sweepA = new b2Sweep;
b2TOIInput.prototype.sweepB = new b2Sweep;
b2TOIInput.prototype.tolerance = null;var b2RevoluteJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2RevoluteJointDef.prototype, b2JointDef.prototype);
b2RevoluteJointDef.prototype._super = b2JointDef.prototype;
b2RevoluteJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_revoluteJoint;
  this.localAnchorA.Set(0, 0);
  this.localAnchorB.Set(0, 0);
  this.referenceAngle = 0;
  this.lowerAngle = 0;
  this.upperAngle = 0;
  this.maxMotorTorque = 0;
  this.motorSpeed = 0;
  this.enableLimit = false;
  this.enableMotor = false
};
b2RevoluteJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2RevoluteJointDef.prototype.Initialize = function(bA, bB, anchor) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
  this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
  this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
};
b2RevoluteJointDef.prototype.localAnchorA = new b2Vec2;
b2RevoluteJointDef.prototype.localAnchorB = new b2Vec2;
b2RevoluteJointDef.prototype.referenceAngle = null;
b2RevoluteJointDef.prototype.enableLimit = null;
b2RevoluteJointDef.prototype.lowerAngle = null;
b2RevoluteJointDef.prototype.upperAngle = null;
b2RevoluteJointDef.prototype.enableMotor = null;
b2RevoluteJointDef.prototype.motorSpeed = null;
b2RevoluteJointDef.prototype.maxMotorTorque = null;var b2MouseJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2MouseJointDef.prototype, b2JointDef.prototype);
b2MouseJointDef.prototype._super = b2JointDef.prototype;
b2MouseJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_mouseJoint;
  this.maxForce = 0;
  this.frequencyHz = 5;
  this.dampingRatio = 0.7
};
b2MouseJointDef.prototype.__varz = function() {
  this.target = new b2Vec2
};
b2MouseJointDef.prototype.target = new b2Vec2;
b2MouseJointDef.prototype.maxForce = null;
b2MouseJointDef.prototype.frequencyHz = null;
b2MouseJointDef.prototype.dampingRatio = null;var b2Contact = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Contact.prototype.__constructor = function() {
};
b2Contact.prototype.__varz = function() {
  this.m_nodeA = new b2ContactEdge;
  this.m_nodeB = new b2ContactEdge;
  this.m_manifold = new b2Manifold;
  this.m_oldManifold = new b2Manifold
};
b2Contact.s_input = new b2TOIInput;
b2Contact.e_sensorFlag = 1;
b2Contact.e_continuousFlag = 2;
b2Contact.e_islandFlag = 4;
b2Contact.e_toiFlag = 8;
b2Contact.e_touchingFlag = 16;
b2Contact.e_enabledFlag = 32;
b2Contact.e_filterFlag = 64;
b2Contact.prototype.Reset = function(fixtureA, fixtureB) {
  this.m_flags = b2Contact.e_enabledFlag;
  if(!fixtureA || !fixtureB) {
    this.m_fixtureA = null;
    this.m_fixtureB = null;
    return
  }
  if(fixtureA.IsSensor() || fixtureB.IsSensor()) {
    this.m_flags |= b2Contact.e_sensorFlag
  }
  var bodyA = fixtureA.GetBody();
  var bodyB = fixtureB.GetBody();
  if(bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
    this.m_flags |= b2Contact.e_continuousFlag
  }
  this.m_fixtureA = fixtureA;
  this.m_fixtureB = fixtureB;
  this.m_manifold.m_pointCount = 0;
  this.m_prev = null;
  this.m_next = null;
  this.m_nodeA.contact = null;
  this.m_nodeA.prev = null;
  this.m_nodeA.next = null;
  this.m_nodeA.other = null;
  this.m_nodeB.contact = null;
  this.m_nodeB.prev = null;
  this.m_nodeB.next = null;
  this.m_nodeB.other = null
};
b2Contact.prototype.Update = function(listener) {
  var tManifold = this.m_oldManifold;
  this.m_oldManifold = this.m_manifold;
  this.m_manifold = tManifold;
  this.m_flags |= b2Contact.e_enabledFlag;
  var touching = false;
  var wasTouching = (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
  var bodyA = this.m_fixtureA.m_body;
  var bodyB = this.m_fixtureB.m_body;
  var aabbOverlap = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
  if(this.m_flags & b2Contact.e_sensorFlag) {
    if(aabbOverlap) {
      var shapeA = this.m_fixtureA.GetShape();
      var shapeB = this.m_fixtureB.GetShape();
      var xfA = bodyA.GetTransform();
      var xfB = bodyB.GetTransform();
      touching = b2Shape.TestOverlap(shapeA, xfA, shapeB, xfB)
    }
    this.m_manifold.m_pointCount = 0
  }else {
    if(bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
      this.m_flags |= b2Contact.e_continuousFlag
    }else {
      this.m_flags &= ~b2Contact.e_continuousFlag
    }
    if(aabbOverlap) {
      this.Evaluate();
      touching = this.m_manifold.m_pointCount > 0;
      for(var i = 0;i < this.m_manifold.m_pointCount;++i) {
        var mp2 = this.m_manifold.m_points[i];
        mp2.m_normalImpulse = 0;
        mp2.m_tangentImpulse = 0;
        var id2 = mp2.m_id;
        for(var j = 0;j < this.m_oldManifold.m_pointCount;++j) {
          var mp1 = this.m_oldManifold.m_points[j];
          if(mp1.m_id.key == id2.key) {
            mp2.m_normalImpulse = mp1.m_normalImpulse;
            mp2.m_tangentImpulse = mp1.m_tangentImpulse;
            break
          }
        }
      }
    }else {
      this.m_manifold.m_pointCount = 0
    }
    if(touching != wasTouching) {
      bodyA.SetAwake(true);
      bodyB.SetAwake(true)
    }
  }
  if(touching) {
    this.m_flags |= b2Contact.e_touchingFlag
  }else {
    this.m_flags &= ~b2Contact.e_touchingFlag
  }
  if(wasTouching == false && touching == true) {
    listener.BeginContact(this)
  }
  if(wasTouching == true && touching == false) {
    listener.EndContact(this)
  }
  if((this.m_flags & b2Contact.e_sensorFlag) == 0) {
    listener.PreSolve(this, this.m_oldManifold)
  }
};
b2Contact.prototype.Evaluate = function() {
};
b2Contact.prototype.ComputeTOI = function(sweepA, sweepB) {
  b2Contact.s_input.proxyA.Set(this.m_fixtureA.GetShape());
  b2Contact.s_input.proxyB.Set(this.m_fixtureB.GetShape());
  b2Contact.s_input.sweepA = sweepA;
  b2Contact.s_input.sweepB = sweepB;
  b2Contact.s_input.tolerance = b2Settings.b2_linearSlop;
  return b2TimeOfImpact.TimeOfImpact(b2Contact.s_input)
};
b2Contact.prototype.GetManifold = function() {
  return this.m_manifold
};
b2Contact.prototype.GetWorldManifold = function(worldManifold) {
  var bodyA = this.m_fixtureA.GetBody();
  var bodyB = this.m_fixtureB.GetBody();
  var shapeA = this.m_fixtureA.GetShape();
  var shapeB = this.m_fixtureB.GetShape();
  worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius)
};
b2Contact.prototype.IsTouching = function() {
  return(this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag
};
b2Contact.prototype.IsContinuous = function() {
  return(this.m_flags & b2Contact.e_continuousFlag) == b2Contact.e_continuousFlag
};
b2Contact.prototype.SetSensor = function(sensor) {
  if(sensor) {
    this.m_flags |= b2Contact.e_sensorFlag
  }else {
    this.m_flags &= ~b2Contact.e_sensorFlag
  }
};
b2Contact.prototype.IsSensor = function() {
  return(this.m_flags & b2Contact.e_sensorFlag) == b2Contact.e_sensorFlag
};
b2Contact.prototype.SetEnabled = function(flag) {
  if(flag) {
    this.m_flags |= b2Contact.e_enabledFlag
  }else {
    this.m_flags &= ~b2Contact.e_enabledFlag
  }
};
b2Contact.prototype.IsEnabled = function() {
  return(this.m_flags & b2Contact.e_enabledFlag) == b2Contact.e_enabledFlag
};
b2Contact.prototype.GetNext = function() {
  return this.m_next
};
b2Contact.prototype.GetFixtureA = function() {
  return this.m_fixtureA
};
b2Contact.prototype.GetFixtureB = function() {
  return this.m_fixtureB
};
b2Contact.prototype.FlagForFiltering = function() {
  this.m_flags |= b2Contact.e_filterFlag
};
b2Contact.prototype.m_flags = 0;
b2Contact.prototype.m_prev = null;
b2Contact.prototype.m_next = null;
b2Contact.prototype.m_nodeA = new b2ContactEdge;
b2Contact.prototype.m_nodeB = new b2ContactEdge;
b2Contact.prototype.m_fixtureA = null;
b2Contact.prototype.m_fixtureB = null;
b2Contact.prototype.m_manifold = new b2Manifold;
b2Contact.prototype.m_oldManifold = new b2Manifold;
b2Contact.prototype.m_toi = null;var b2ContactConstraint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactConstraint.prototype.__constructor = function() {
  this.points = new Array(b2Settings.b2_maxManifoldPoints);
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.points[i] = new b2ContactConstraintPoint
  }
};
b2ContactConstraint.prototype.__varz = function() {
  this.localPlaneNormal = new b2Vec2;
  this.localPoint = new b2Vec2;
  this.normal = new b2Vec2;
  this.normalMass = new b2Mat22;
  this.K = new b2Mat22
};
b2ContactConstraint.prototype.points = null;
b2ContactConstraint.prototype.localPlaneNormal = new b2Vec2;
b2ContactConstraint.prototype.localPoint = new b2Vec2;
b2ContactConstraint.prototype.normal = new b2Vec2;
b2ContactConstraint.prototype.normalMass = new b2Mat22;
b2ContactConstraint.prototype.K = new b2Mat22;
b2ContactConstraint.prototype.bodyA = null;
b2ContactConstraint.prototype.bodyB = null;
b2ContactConstraint.prototype.type = 0;
b2ContactConstraint.prototype.radius = null;
b2ContactConstraint.prototype.friction = null;
b2ContactConstraint.prototype.restitution = null;
b2ContactConstraint.prototype.pointCount = 0;
b2ContactConstraint.prototype.manifold = null;var b2ContactResult = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactResult.prototype.__constructor = function() {
};
b2ContactResult.prototype.__varz = function() {
  this.position = new b2Vec2;
  this.normal = new b2Vec2;
  this.id = new b2ContactID
};
b2ContactResult.prototype.shape1 = null;
b2ContactResult.prototype.shape2 = null;
b2ContactResult.prototype.position = new b2Vec2;
b2ContactResult.prototype.normal = new b2Vec2;
b2ContactResult.prototype.normalImpulse = null;
b2ContactResult.prototype.tangentImpulse = null;
b2ContactResult.prototype.id = new b2ContactID;var b2PolygonContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PolygonContact.prototype, b2Contact.prototype);
b2PolygonContact.prototype._super = b2Contact.prototype;
b2PolygonContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2PolygonContact.prototype.__varz = function() {
};
b2PolygonContact.Create = function(allocator) {
  return new b2PolygonContact
};
b2PolygonContact.Destroy = function(contact, allocator) {
};
b2PolygonContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.GetBody();
  var bB = this.m_fixtureB.GetBody();
  b2Collision.CollidePolygons(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2PolygonContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB])
};var ClipVertex = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
ClipVertex.prototype.__constructor = function() {
};
ClipVertex.prototype.__varz = function() {
  this.v = new b2Vec2;
  this.id = new b2ContactID
};
ClipVertex.prototype.Set = function(other) {
  this.v.SetV(other.v);
  this.id.Set(other.id)
};
ClipVertex.prototype.v = new b2Vec2;
ClipVertex.prototype.id = new b2ContactID;var b2ContactFilter = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactFilter.prototype.__constructor = function() {
};
b2ContactFilter.prototype.__varz = function() {
};
b2ContactFilter.b2_defaultFilter = new b2ContactFilter;
b2ContactFilter.prototype.ShouldCollide = function(fixtureA, fixtureB) {
  var filter1 = fixtureA.GetFilterData();
  var filter2 = fixtureB.GetFilterData();
  if(filter1.groupIndex == filter2.groupIndex && filter1.groupIndex != 0) {
    return filter1.groupIndex > 0
  }
  var collide = (filter1.maskBits & filter2.categoryBits) != 0 && (filter1.categoryBits & filter2.maskBits) != 0;
  return collide
};
b2ContactFilter.prototype.RayCollide = function(userData, fixture) {
  if(!userData) {
    return true
  }
  return this.ShouldCollide(userData, fixture)
};var b2NullContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2NullContact.prototype, b2Contact.prototype);
b2NullContact.prototype._super = b2Contact.prototype;
b2NullContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2NullContact.prototype.__varz = function() {
};
b2NullContact.prototype.Evaluate = function() {
};var b2ContactListener = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactListener.prototype.__constructor = function() {
};
b2ContactListener.prototype.__varz = function() {
};
b2ContactListener.b2_defaultListener = new b2ContactListener;
b2ContactListener.prototype.BeginContact = function(contact) {
};
b2ContactListener.prototype.EndContact = function(contact) {
};
b2ContactListener.prototype.PreSolve = function(contact, oldManifold) {
};
b2ContactListener.prototype.PostSolve = function(contact, impulse) {
};var b2Island = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Island.prototype.__constructor = function() {
  this.m_bodies = new Array;
  this.m_contacts = new Array;
  this.m_joints = new Array
};
b2Island.prototype.__varz = function() {
};
b2Island.s_impulse = new b2ContactImpulse;
b2Island.prototype.Initialize = function(bodyCapacity, contactCapacity, jointCapacity, allocator, listener, contactSolver) {
  var i = 0;
  this.m_bodyCapacity = bodyCapacity;
  this.m_contactCapacity = contactCapacity;
  this.m_jointCapacity = jointCapacity;
  this.m_bodyCount = 0;
  this.m_contactCount = 0;
  this.m_jointCount = 0;
  this.m_allocator = allocator;
  this.m_listener = listener;
  this.m_contactSolver = contactSolver;
  for(i = this.m_bodies.length;i < bodyCapacity;i++) {
    this.m_bodies[i] = null
  }
  for(i = this.m_contacts.length;i < contactCapacity;i++) {
    this.m_contacts[i] = null
  }
  for(i = this.m_joints.length;i < jointCapacity;i++) {
    this.m_joints[i] = null
  }
};
b2Island.prototype.Clear = function() {
  this.m_bodyCount = 0;
  this.m_contactCount = 0;
  this.m_jointCount = 0
};
b2Island.prototype.Solve = function(step, gravity, allowSleep) {
  var i = 0;
  var j = 0;
  var b;
  var joint;
  for(i = 0;i < this.m_bodyCount;++i) {
    b = this.m_bodies[i];
    if(b.GetType() != b2Body.b2_dynamicBody) {
      continue
    }
    b.m_linearVelocity.x += step.dt * (gravity.x + b.m_invMass * b.m_force.x);
    b.m_linearVelocity.y += step.dt * (gravity.y + b.m_invMass * b.m_force.y);
    b.m_angularVelocity += step.dt * b.m_invI * b.m_torque;
    b.m_linearVelocity.Multiply(b2Math.Clamp(1 - step.dt * b.m_linearDamping, 0, 1));
    b.m_angularVelocity *= b2Math.Clamp(1 - step.dt * b.m_angularDamping, 0, 1)
  }
  this.m_contactSolver.Initialize(step, this.m_contacts, this.m_contactCount, this.m_allocator);
  var contactSolver = this.m_contactSolver;
  contactSolver.InitVelocityConstraints(step);
  for(i = 0;i < this.m_jointCount;++i) {
    joint = this.m_joints[i];
    joint.InitVelocityConstraints(step)
  }
  for(i = 0;i < step.velocityIterations;++i) {
    for(j = 0;j < this.m_jointCount;++j) {
      joint = this.m_joints[j];
      joint.SolveVelocityConstraints(step)
    }
    contactSolver.SolveVelocityConstraints()
  }
  for(i = 0;i < this.m_jointCount;++i) {
    joint = this.m_joints[i];
    joint.FinalizeVelocityConstraints()
  }
  contactSolver.FinalizeVelocityConstraints();
  for(i = 0;i < this.m_bodyCount;++i) {
    b = this.m_bodies[i];
    if(b.GetType() == b2Body.b2_staticBody) {
      continue
    }
    var translationX = step.dt * b.m_linearVelocity.x;
    var translationY = step.dt * b.m_linearVelocity.y;
    if(translationX * translationX + translationY * translationY > b2Settings.b2_maxTranslationSquared) {
      b.m_linearVelocity.Normalize();
      b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * step.inv_dt;
      b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * step.inv_dt
    }
    var rotation = step.dt * b.m_angularVelocity;
    if(rotation * rotation > b2Settings.b2_maxRotationSquared) {
      if(b.m_angularVelocity < 0) {
        b.m_angularVelocity = -b2Settings.b2_maxRotation * step.inv_dt
      }else {
        b.m_angularVelocity = b2Settings.b2_maxRotation * step.inv_dt
      }
    }
    b.m_sweep.c0.SetV(b.m_sweep.c);
    b.m_sweep.a0 = b.m_sweep.a;
    b.m_sweep.c.x += step.dt * b.m_linearVelocity.x;
    b.m_sweep.c.y += step.dt * b.m_linearVelocity.y;
    b.m_sweep.a += step.dt * b.m_angularVelocity;
    b.SynchronizeTransform()
  }
  for(i = 0;i < step.positionIterations;++i) {
    var contactsOkay = contactSolver.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
    var jointsOkay = true;
    for(j = 0;j < this.m_jointCount;++j) {
      joint = this.m_joints[j];
      var jointOkay = joint.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
      jointsOkay = jointsOkay && jointOkay
    }
    if(contactsOkay && jointsOkay) {
      break
    }
  }
  this.Report(contactSolver.m_constraints);
  if(allowSleep) {
    var minSleepTime = Number.MAX_VALUE;
    var linTolSqr = b2Settings.b2_linearSleepTolerance * b2Settings.b2_linearSleepTolerance;
    var angTolSqr = b2Settings.b2_angularSleepTolerance * b2Settings.b2_angularSleepTolerance;
    for(i = 0;i < this.m_bodyCount;++i) {
      b = this.m_bodies[i];
      if(b.GetType() == b2Body.b2_staticBody) {
        continue
      }
      if((b.m_flags & b2Body.e_allowSleepFlag) == 0) {
        b.m_sleepTime = 0;
        minSleepTime = 0
      }
      if((b.m_flags & b2Body.e_allowSleepFlag) == 0 || b.m_angularVelocity * b.m_angularVelocity > angTolSqr || b2Math.Dot(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
        b.m_sleepTime = 0;
        minSleepTime = 0
      }else {
        b.m_sleepTime += step.dt;
        minSleepTime = b2Math.Min(minSleepTime, b.m_sleepTime)
      }
    }
    if(minSleepTime >= b2Settings.b2_timeToSleep) {
      for(i = 0;i < this.m_bodyCount;++i) {
        b = this.m_bodies[i];
        b.SetAwake(false)
      }
    }
  }
};
b2Island.prototype.SolveTOI = function(subStep) {
  var i = 0;
  var j = 0;
  this.m_contactSolver.Initialize(subStep, this.m_contacts, this.m_contactCount, this.m_allocator);
  var contactSolver = this.m_contactSolver;
  for(i = 0;i < this.m_jointCount;++i) {
    this.m_joints[i].InitVelocityConstraints(subStep)
  }
  for(i = 0;i < subStep.velocityIterations;++i) {
    contactSolver.SolveVelocityConstraints();
    for(j = 0;j < this.m_jointCount;++j) {
      this.m_joints[j].SolveVelocityConstraints(subStep)
    }
  }
  for(i = 0;i < this.m_bodyCount;++i) {
    var b = this.m_bodies[i];
    if(b.GetType() == b2Body.b2_staticBody) {
      continue
    }
    var translationX = subStep.dt * b.m_linearVelocity.x;
    var translationY = subStep.dt * b.m_linearVelocity.y;
    if(translationX * translationX + translationY * translationY > b2Settings.b2_maxTranslationSquared) {
      b.m_linearVelocity.Normalize();
      b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * subStep.inv_dt;
      b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * subStep.inv_dt
    }
    var rotation = subStep.dt * b.m_angularVelocity;
    if(rotation * rotation > b2Settings.b2_maxRotationSquared) {
      if(b.m_angularVelocity < 0) {
        b.m_angularVelocity = -b2Settings.b2_maxRotation * subStep.inv_dt
      }else {
        b.m_angularVelocity = b2Settings.b2_maxRotation * subStep.inv_dt
      }
    }
    b.m_sweep.c0.SetV(b.m_sweep.c);
    b.m_sweep.a0 = b.m_sweep.a;
    b.m_sweep.c.x += subStep.dt * b.m_linearVelocity.x;
    b.m_sweep.c.y += subStep.dt * b.m_linearVelocity.y;
    b.m_sweep.a += subStep.dt * b.m_angularVelocity;
    b.SynchronizeTransform()
  }
  var k_toiBaumgarte = 0.75;
  for(i = 0;i < subStep.positionIterations;++i) {
    var contactsOkay = contactSolver.SolvePositionConstraints(k_toiBaumgarte);
    var jointsOkay = true;
    for(j = 0;j < this.m_jointCount;++j) {
      var jointOkay = this.m_joints[j].SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
      jointsOkay = jointsOkay && jointOkay
    }
    if(contactsOkay && jointsOkay) {
      break
    }
  }
  this.Report(contactSolver.m_constraints)
};
b2Island.prototype.Report = function(constraints) {
  if(this.m_listener == null) {
    return
  }
  for(var i = 0;i < this.m_contactCount;++i) {
    var c = this.m_contacts[i];
    var cc = constraints[i];
    for(var j = 0;j < cc.pointCount;++j) {
      b2Island.s_impulse.normalImpulses[j] = cc.points[j].normalImpulse;
      b2Island.s_impulse.tangentImpulses[j] = cc.points[j].tangentImpulse
    }
    this.m_listener.PostSolve(c, b2Island.s_impulse)
  }
};
b2Island.prototype.AddBody = function(body) {
  body.m_islandIndex = this.m_bodyCount;
  this.m_bodies[this.m_bodyCount++] = body
};
b2Island.prototype.AddContact = function(contact) {
  this.m_contacts[this.m_contactCount++] = contact
};
b2Island.prototype.AddJoint = function(joint) {
  this.m_joints[this.m_jointCount++] = joint
};
b2Island.prototype.m_allocator = null;
b2Island.prototype.m_listener = null;
b2Island.prototype.m_contactSolver = null;
b2Island.prototype.m_bodies = null;
b2Island.prototype.m_contacts = null;
b2Island.prototype.m_joints = null;
b2Island.prototype.m_bodyCount = 0;
b2Island.prototype.m_jointCount = 0;
b2Island.prototype.m_contactCount = 0;
b2Island.prototype.m_bodyCapacity = 0;
b2Island.prototype.m_contactCapacity = 0;
b2Island.prototype.m_jointCapacity = 0;var b2PolyAndEdgeContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PolyAndEdgeContact.prototype, b2Contact.prototype);
b2PolyAndEdgeContact.prototype._super = b2Contact.prototype;
b2PolyAndEdgeContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2PolyAndEdgeContact.prototype.__varz = function() {
};
b2PolyAndEdgeContact.Create = function(allocator) {
  return new b2PolyAndEdgeContact
};
b2PolyAndEdgeContact.Destroy = function(contact, allocator) {
};
b2PolyAndEdgeContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.GetBody();
  var bB = this.m_fixtureB.GetBody();
  this.b2CollidePolyAndEdge(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2PolyAndEdgeContact.prototype.b2CollidePolyAndEdge = function(manifold, polygon, xf1, edge, xf2) {
};
b2PolyAndEdgeContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB]);
  b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
  b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_edgeShape)
};var b2Collision = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Collision.prototype.__constructor = function() {
};
b2Collision.prototype.__varz = function() {
};
b2Collision.MakeClipPointVector = function() {
  var r = new Array(2);
  r[0] = new ClipVertex;
  r[1] = new ClipVertex;
  return r
};
b2Collision.ClipSegmentToLine = function(vOut, vIn, normal, offset) {
  var cv;
  var numOut = 0;
  cv = vIn[0];
  var vIn0 = cv.v;
  cv = vIn[1];
  var vIn1 = cv.v;
  var distance0 = normal.x * vIn0.x + normal.y * vIn0.y - offset;
  var distance1 = normal.x * vIn1.x + normal.y * vIn1.y - offset;
  if(distance0 <= 0) {
    vOut[numOut++].Set(vIn[0])
  }
  if(distance1 <= 0) {
    vOut[numOut++].Set(vIn[1])
  }
  if(distance0 * distance1 < 0) {
    var interp = distance0 / (distance0 - distance1);
    cv = vOut[numOut];
    var tVec = cv.v;
    tVec.x = vIn0.x + interp * (vIn1.x - vIn0.x);
    tVec.y = vIn0.y + interp * (vIn1.y - vIn0.y);
    cv = vOut[numOut];
    var cv2;
    if(distance0 > 0) {
      cv2 = vIn[0];
      cv.id = cv2.id
    }else {
      cv2 = vIn[1];
      cv.id = cv2.id
    }
    ++numOut
  }
  return numOut
};
b2Collision.EdgeSeparation = function(poly1, xf1, edge1, poly2, xf2) {
  var count1 = poly1.m_vertexCount;
  var vertices1 = poly1.m_vertices;
  var normals1 = poly1.m_normals;
  var count2 = poly2.m_vertexCount;
  var vertices2 = poly2.m_vertices;
  var tMat;
  var tVec;
  tMat = xf1.R;
  tVec = normals1[edge1];
  var normal1WorldX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
  var normal1WorldY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
  tMat = xf2.R;
  var normal1X = tMat.col1.x * normal1WorldX + tMat.col1.y * normal1WorldY;
  var normal1Y = tMat.col2.x * normal1WorldX + tMat.col2.y * normal1WorldY;
  var index = 0;
  var minDot = Number.MAX_VALUE;
  for(var i = 0;i < count2;++i) {
    tVec = vertices2[i];
    var dot = tVec.x * normal1X + tVec.y * normal1Y;
    if(dot < minDot) {
      minDot = dot;
      index = i
    }
  }
  tVec = vertices1[edge1];
  tMat = xf1.R;
  var v1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var v1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tVec = vertices2[index];
  tMat = xf2.R;
  var v2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var v2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  v2X -= v1X;
  v2Y -= v1Y;
  var separation = v2X * normal1WorldX + v2Y * normal1WorldY;
  return separation
};
b2Collision.FindMaxSeparation = function(edgeIndex, poly1, xf1, poly2, xf2) {
  var count1 = poly1.m_vertexCount;
  var normals1 = poly1.m_normals;
  var tVec;
  var tMat;
  tMat = xf2.R;
  tVec = poly2.m_centroid;
  var dX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var dY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tMat = xf1.R;
  tVec = poly1.m_centroid;
  dX -= xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  dY -= xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var dLocal1X = dX * xf1.R.col1.x + dY * xf1.R.col1.y;
  var dLocal1Y = dX * xf1.R.col2.x + dY * xf1.R.col2.y;
  var edge = 0;
  var maxDot = -Number.MAX_VALUE;
  for(var i = 0;i < count1;++i) {
    tVec = normals1[i];
    var dot = tVec.x * dLocal1X + tVec.y * dLocal1Y;
    if(dot > maxDot) {
      maxDot = dot;
      edge = i
    }
  }
  var s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
  var prevEdge = edge - 1 >= 0 ? edge - 1 : count1 - 1;
  var sPrev = b2Collision.EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);
  var nextEdge = edge + 1 < count1 ? edge + 1 : 0;
  var sNext = b2Collision.EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);
  var bestEdge = 0;
  var bestSeparation;
  var increment = 0;
  if(sPrev > s && sPrev > sNext) {
    increment = -1;
    bestEdge = prevEdge;
    bestSeparation = sPrev
  }else {
    if(sNext > s) {
      increment = 1;
      bestEdge = nextEdge;
      bestSeparation = sNext
    }else {
      edgeIndex[0] = edge;
      return s
    }
  }
  while(true) {
    if(increment == -1) {
      edge = bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1
    }else {
      edge = bestEdge + 1 < count1 ? bestEdge + 1 : 0
    }
    s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
    if(s > bestSeparation) {
      bestEdge = edge;
      bestSeparation = s
    }else {
      break
    }
  }
  edgeIndex[0] = bestEdge;
  return bestSeparation
};
b2Collision.FindIncidentEdge = function(c, poly1, xf1, edge1, poly2, xf2) {
  var count1 = poly1.m_vertexCount;
  var normals1 = poly1.m_normals;
  var count2 = poly2.m_vertexCount;
  var vertices2 = poly2.m_vertices;
  var normals2 = poly2.m_normals;
  var tMat;
  var tVec;
  tMat = xf1.R;
  tVec = normals1[edge1];
  var normal1X = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
  var normal1Y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
  tMat = xf2.R;
  var tX = tMat.col1.x * normal1X + tMat.col1.y * normal1Y;
  normal1Y = tMat.col2.x * normal1X + tMat.col2.y * normal1Y;
  normal1X = tX;
  var index = 0;
  var minDot = Number.MAX_VALUE;
  for(var i = 0;i < count2;++i) {
    tVec = normals2[i];
    var dot = normal1X * tVec.x + normal1Y * tVec.y;
    if(dot < minDot) {
      minDot = dot;
      index = i
    }
  }
  var tClip;
  var i1 = index;
  var i2 = i1 + 1 < count2 ? i1 + 1 : 0;
  tClip = c[0];
  tVec = vertices2[i1];
  tMat = xf2.R;
  tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tClip.id.features.referenceEdge = edge1;
  tClip.id.features.incidentEdge = i1;
  tClip.id.features.incidentVertex = 0;
  tClip = c[1];
  tVec = vertices2[i2];
  tMat = xf2.R;
  tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tClip.id.features.referenceEdge = edge1;
  tClip.id.features.incidentEdge = i2;
  tClip.id.features.incidentVertex = 1
};
b2Collision.CollidePolygons = function(manifold, polyA, xfA, polyB, xfB) {
  var cv;
  manifold.m_pointCount = 0;
  var totalRadius = polyA.m_radius + polyB.m_radius;
  var edgeA = 0;
  b2Collision.s_edgeAO[0] = edgeA;
  var separationA = b2Collision.FindMaxSeparation(b2Collision.s_edgeAO, polyA, xfA, polyB, xfB);
  edgeA = b2Collision.s_edgeAO[0];
  if(separationA > totalRadius) {
    return
  }
  var edgeB = 0;
  b2Collision.s_edgeBO[0] = edgeB;
  var separationB = b2Collision.FindMaxSeparation(b2Collision.s_edgeBO, polyB, xfB, polyA, xfA);
  edgeB = b2Collision.s_edgeBO[0];
  if(separationB > totalRadius) {
    return
  }
  var poly1;
  var poly2;
  var xf1;
  var xf2;
  var edge1 = 0;
  var flip = 0;
  var k_relativeTol = 0.98;
  var k_absoluteTol = 0.0010;
  var tMat;
  if(separationB > k_relativeTol * separationA + k_absoluteTol) {
    poly1 = polyB;
    poly2 = polyA;
    xf1 = xfB;
    xf2 = xfA;
    edge1 = edgeB;
    manifold.m_type = b2Manifold.e_faceB;
    flip = 1
  }else {
    poly1 = polyA;
    poly2 = polyB;
    xf1 = xfA;
    xf2 = xfB;
    edge1 = edgeA;
    manifold.m_type = b2Manifold.e_faceA;
    flip = 0
  }
  var incidentEdge = b2Collision.s_incidentEdge;
  b2Collision.FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
  var count1 = poly1.m_vertexCount;
  var vertices1 = poly1.m_vertices;
  var local_v11 = vertices1[edge1];
  var local_v12;
  if(edge1 + 1 < count1) {
    local_v12 = vertices1[parseInt(edge1 + 1)]
  }else {
    local_v12 = vertices1[0]
  }
  var localTangent = b2Collision.s_localTangent;
  localTangent.Set(local_v12.x - local_v11.x, local_v12.y - local_v11.y);
  localTangent.Normalize();
  var localNormal = b2Collision.s_localNormal;
  localNormal.x = localTangent.y;
  localNormal.y = -localTangent.x;
  var planePoint = b2Collision.s_planePoint;
  planePoint.Set(0.5 * (local_v11.x + local_v12.x), 0.5 * (local_v11.y + local_v12.y));
  var tangent = b2Collision.s_tangent;
  tMat = xf1.R;
  tangent.x = tMat.col1.x * localTangent.x + tMat.col2.x * localTangent.y;
  tangent.y = tMat.col1.y * localTangent.x + tMat.col2.y * localTangent.y;
  var tangent2 = b2Collision.s_tangent2;
  tangent2.x = -tangent.x;
  tangent2.y = -tangent.y;
  var normal = b2Collision.s_normal;
  normal.x = tangent.y;
  normal.y = -tangent.x;
  var v11 = b2Collision.s_v11;
  var v12 = b2Collision.s_v12;
  v11.x = xf1.position.x + (tMat.col1.x * local_v11.x + tMat.col2.x * local_v11.y);
  v11.y = xf1.position.y + (tMat.col1.y * local_v11.x + tMat.col2.y * local_v11.y);
  v12.x = xf1.position.x + (tMat.col1.x * local_v12.x + tMat.col2.x * local_v12.y);
  v12.y = xf1.position.y + (tMat.col1.y * local_v12.x + tMat.col2.y * local_v12.y);
  var frontOffset = normal.x * v11.x + normal.y * v11.y;
  var sideOffset1 = -tangent.x * v11.x - tangent.y * v11.y + totalRadius;
  var sideOffset2 = tangent.x * v12.x + tangent.y * v12.y + totalRadius;
  var clipPoints1 = b2Collision.s_clipPoints1;
  var clipPoints2 = b2Collision.s_clipPoints2;
  var np = 0;
  np = b2Collision.ClipSegmentToLine(clipPoints1, incidentEdge, tangent2, sideOffset1);
  if(np < 2) {
    return
  }
  np = b2Collision.ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2);
  if(np < 2) {
    return
  }
  manifold.m_localPlaneNormal.SetV(localNormal);
  manifold.m_localPoint.SetV(planePoint);
  var pointCount = 0;
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;++i) {
    cv = clipPoints2[i];
    var separation = normal.x * cv.v.x + normal.y * cv.v.y - frontOffset;
    if(separation <= totalRadius) {
      var cp = manifold.m_points[pointCount];
      tMat = xf2.R;
      var tX = cv.v.x - xf2.position.x;
      var tY = cv.v.y - xf2.position.y;
      cp.m_localPoint.x = tX * tMat.col1.x + tY * tMat.col1.y;
      cp.m_localPoint.y = tX * tMat.col2.x + tY * tMat.col2.y;
      cp.m_id.Set(cv.id);
      cp.m_id.features.flip = flip;
      ++pointCount
    }
  }
  manifold.m_pointCount = pointCount
};
b2Collision.CollideCircles = function(manifold, circle1, xf1, circle2, xf2) {
  manifold.m_pointCount = 0;
  var tMat;
  var tVec;
  tMat = xf1.R;
  tVec = circle1.m_p;
  var p1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var p1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tMat = xf2.R;
  tVec = circle2.m_p;
  var p2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var p2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var dX = p2X - p1X;
  var dY = p2Y - p1Y;
  var distSqr = dX * dX + dY * dY;
  var radius = circle1.m_radius + circle2.m_radius;
  if(distSqr > radius * radius) {
    return
  }
  manifold.m_type = b2Manifold.e_circles;
  manifold.m_localPoint.SetV(circle1.m_p);
  manifold.m_localPlaneNormal.SetZero();
  manifold.m_pointCount = 1;
  manifold.m_points[0].m_localPoint.SetV(circle2.m_p);
  manifold.m_points[0].m_id.key = 0
};
b2Collision.CollidePolygonAndCircle = function(manifold, polygon, xf1, circle, xf2) {
  manifold.m_pointCount = 0;
  var tPoint;
  var dX;
  var dY;
  var positionX;
  var positionY;
  var tVec;
  var tMat;
  tMat = xf2.R;
  tVec = circle.m_p;
  var cX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var cY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  dX = cX - xf1.position.x;
  dY = cY - xf1.position.y;
  tMat = xf1.R;
  var cLocalX = dX * tMat.col1.x + dY * tMat.col1.y;
  var cLocalY = dX * tMat.col2.x + dY * tMat.col2.y;
  var dist;
  var normalIndex = 0;
  var separation = -Number.MAX_VALUE;
  var radius = polygon.m_radius + circle.m_radius;
  var vertexCount = polygon.m_vertexCount;
  var vertices = polygon.m_vertices;
  var normals = polygon.m_normals;
  for(var i = 0;i < vertexCount;++i) {
    tVec = vertices[i];
    dX = cLocalX - tVec.x;
    dY = cLocalY - tVec.y;
    tVec = normals[i];
    var s = tVec.x * dX + tVec.y * dY;
    if(s > radius) {
      return
    }
    if(s > separation) {
      separation = s;
      normalIndex = i
    }
  }
  var vertIndex1 = normalIndex;
  var vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;
  var v1 = vertices[vertIndex1];
  var v2 = vertices[vertIndex2];
  if(separation < Number.MIN_VALUE) {
    manifold.m_pointCount = 1;
    manifold.m_type = b2Manifold.e_faceA;
    manifold.m_localPlaneNormal.SetV(normals[normalIndex]);
    manifold.m_localPoint.x = 0.5 * (v1.x + v2.x);
    manifold.m_localPoint.y = 0.5 * (v1.y + v2.y);
    manifold.m_points[0].m_localPoint.SetV(circle.m_p);
    manifold.m_points[0].m_id.key = 0;
    return
  }
  var u1 = (cLocalX - v1.x) * (v2.x - v1.x) + (cLocalY - v1.y) * (v2.y - v1.y);
  var u2 = (cLocalX - v2.x) * (v1.x - v2.x) + (cLocalY - v2.y) * (v1.y - v2.y);
  if(u1 <= 0) {
    if((cLocalX - v1.x) * (cLocalX - v1.x) + (cLocalY - v1.y) * (cLocalY - v1.y) > radius * radius) {
      return
    }
    manifold.m_pointCount = 1;
    manifold.m_type = b2Manifold.e_faceA;
    manifold.m_localPlaneNormal.x = cLocalX - v1.x;
    manifold.m_localPlaneNormal.y = cLocalY - v1.y;
    manifold.m_localPlaneNormal.Normalize();
    manifold.m_localPoint.SetV(v1);
    manifold.m_points[0].m_localPoint.SetV(circle.m_p);
    manifold.m_points[0].m_id.key = 0
  }else {
    if(u2 <= 0) {
      if((cLocalX - v2.x) * (cLocalX - v2.x) + (cLocalY - v2.y) * (cLocalY - v2.y) > radius * radius) {
        return
      }
      manifold.m_pointCount = 1;
      manifold.m_type = b2Manifold.e_faceA;
      manifold.m_localPlaneNormal.x = cLocalX - v2.x;
      manifold.m_localPlaneNormal.y = cLocalY - v2.y;
      manifold.m_localPlaneNormal.Normalize();
      manifold.m_localPoint.SetV(v2);
      manifold.m_points[0].m_localPoint.SetV(circle.m_p);
      manifold.m_points[0].m_id.key = 0
    }else {
      var faceCenterX = 0.5 * (v1.x + v2.x);
      var faceCenterY = 0.5 * (v1.y + v2.y);
      separation = (cLocalX - faceCenterX) * normals[vertIndex1].x + (cLocalY - faceCenterY) * normals[vertIndex1].y;
      if(separation > radius) {
        return
      }
      manifold.m_pointCount = 1;
      manifold.m_type = b2Manifold.e_faceA;
      manifold.m_localPlaneNormal.x = normals[vertIndex1].x;
      manifold.m_localPlaneNormal.y = normals[vertIndex1].y;
      manifold.m_localPlaneNormal.Normalize();
      manifold.m_localPoint.Set(faceCenterX, faceCenterY);
      manifold.m_points[0].m_localPoint.SetV(circle.m_p);
      manifold.m_points[0].m_id.key = 0
    }
  }
};
b2Collision.TestOverlap = function(a, b) {
  var t1 = b.lowerBound;
  var t2 = a.upperBound;
  var d1X = t1.x - t2.x;
  var d1Y = t1.y - t2.y;
  t1 = a.lowerBound;
  t2 = b.upperBound;
  var d2X = t1.x - t2.x;
  var d2Y = t1.y - t2.y;
  if(d1X > 0 || d1Y > 0) {
    return false
  }
  if(d2X > 0 || d2Y > 0) {
    return false
  }
  return true
};
b2Collision.b2_nullFeature = 255;
b2Collision.s_incidentEdge = b2Collision.MakeClipPointVector();
b2Collision.s_clipPoints1 = b2Collision.MakeClipPointVector();
b2Collision.s_clipPoints2 = b2Collision.MakeClipPointVector();
b2Collision.s_edgeAO = new Array(1);
b2Collision.s_edgeBO = new Array(1);
b2Collision.s_localTangent = new b2Vec2;
b2Collision.s_localNormal = new b2Vec2;
b2Collision.s_planePoint = new b2Vec2;
b2Collision.s_normal = new b2Vec2;
b2Collision.s_tangent = new b2Vec2;
b2Collision.s_tangent2 = new b2Vec2;
b2Collision.s_v11 = new b2Vec2;
b2Collision.s_v12 = new b2Vec2;
b2Collision.b2CollidePolyTempVec = new b2Vec2;var b2PolyAndCircleContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PolyAndCircleContact.prototype, b2Contact.prototype);
b2PolyAndCircleContact.prototype._super = b2Contact.prototype;
b2PolyAndCircleContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2PolyAndCircleContact.prototype.__varz = function() {
};
b2PolyAndCircleContact.Create = function(allocator) {
  return new b2PolyAndCircleContact
};
b2PolyAndCircleContact.Destroy = function(contact, allocator) {
};
b2PolyAndCircleContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.m_body;
  var bB = this.m_fixtureB.m_body;
  b2Collision.CollidePolygonAndCircle(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2PolyAndCircleContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB]);
  b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
  b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_circleShape)
};var b2ContactPoint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactPoint.prototype.__constructor = function() {
};
b2ContactPoint.prototype.__varz = function() {
  this.position = new b2Vec2;
  this.velocity = new b2Vec2;
  this.normal = new b2Vec2;
  this.id = new b2ContactID
};
b2ContactPoint.prototype.shape1 = null;
b2ContactPoint.prototype.shape2 = null;
b2ContactPoint.prototype.position = new b2Vec2;
b2ContactPoint.prototype.velocity = new b2Vec2;
b2ContactPoint.prototype.normal = new b2Vec2;
b2ContactPoint.prototype.separation = null;
b2ContactPoint.prototype.friction = null;
b2ContactPoint.prototype.restitution = null;
b2ContactPoint.prototype.id = new b2ContactID;var b2CircleContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2CircleContact.prototype, b2Contact.prototype);
b2CircleContact.prototype._super = b2Contact.prototype;
b2CircleContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2CircleContact.prototype.__varz = function() {
};
b2CircleContact.Create = function(allocator) {
  return new b2CircleContact
};
b2CircleContact.Destroy = function(contact, allocator) {
};
b2CircleContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.GetBody();
  var bB = this.m_fixtureB.GetBody();
  b2Collision.CollideCircles(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2CircleContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB])
};var b2EdgeAndCircleContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2EdgeAndCircleContact.prototype, b2Contact.prototype);
b2EdgeAndCircleContact.prototype._super = b2Contact.prototype;
b2EdgeAndCircleContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2EdgeAndCircleContact.prototype.__varz = function() {
};
b2EdgeAndCircleContact.Create = function(allocator) {
  return new b2EdgeAndCircleContact
};
b2EdgeAndCircleContact.Destroy = function(contact, allocator) {
};
b2EdgeAndCircleContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.GetBody();
  var bB = this.m_fixtureB.GetBody();
  this.b2CollideEdgeAndCircle(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2EdgeAndCircleContact.prototype.b2CollideEdgeAndCircle = function(manifold, edge, xf1, circle, xf2) {
};
b2EdgeAndCircleContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB])
};var b2ContactManager = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactManager.prototype.__constructor = function() {
  this.m_world = null;
  this.m_contactCount = 0;
  this.m_contactFilter = b2ContactFilter.b2_defaultFilter;
  this.m_contactListener = b2ContactListener.b2_defaultListener;
  this.m_contactFactory = new b2ContactFactory(this.m_allocator);
  this.m_broadPhase = new b2DynamicTreeBroadPhase
};
b2ContactManager.prototype.__varz = function() {
};
b2ContactManager.s_evalCP = new b2ContactPoint;
b2ContactManager.prototype.AddPair = function(proxyUserDataA, proxyUserDataB) {
  var fixtureA = proxyUserDataA;
  var fixtureB = proxyUserDataB;
  var bodyA = fixtureA.GetBody();
  var bodyB = fixtureB.GetBody();
  if(bodyA == bodyB) {
    return
  }
  var edge = bodyB.GetContactList();
  while(edge) {
    if(edge.other == bodyA) {
      var fA = edge.contact.GetFixtureA();
      var fB = edge.contact.GetFixtureB();
      if(fA == fixtureA && fB == fixtureB) {
        return
      }
      if(fA == fixtureB && fB == fixtureA) {
        return
      }
    }
    edge = edge.next
  }
  if(bodyB.ShouldCollide(bodyA) == false) {
    return
  }
  if(this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
    return
  }
  var c = this.m_contactFactory.Create(fixtureA, fixtureB);
  fixtureA = c.GetFixtureA();
  fixtureB = c.GetFixtureB();
  bodyA = fixtureA.m_body;
  bodyB = fixtureB.m_body;
  c.m_prev = null;
  c.m_next = this.m_world.m_contactList;
  if(this.m_world.m_contactList != null) {
    this.m_world.m_contactList.m_prev = c
  }
  this.m_world.m_contactList = c;
  c.m_nodeA.contact = c;
  c.m_nodeA.other = bodyB;
  c.m_nodeA.prev = null;
  c.m_nodeA.next = bodyA.m_contactList;
  if(bodyA.m_contactList != null) {
    bodyA.m_contactList.prev = c.m_nodeA
  }
  bodyA.m_contactList = c.m_nodeA;
  c.m_nodeB.contact = c;
  c.m_nodeB.other = bodyA;
  c.m_nodeB.prev = null;
  c.m_nodeB.next = bodyB.m_contactList;
  if(bodyB.m_contactList != null) {
    bodyB.m_contactList.prev = c.m_nodeB
  }
  bodyB.m_contactList = c.m_nodeB;
  ++this.m_world.m_contactCount;
  return
};
b2ContactManager.prototype.FindNewContacts = function() {
  var that = this;
  this.m_broadPhase.UpdatePairs(function(a, b) {
    return that.AddPair(a, b)
  })
};
b2ContactManager.prototype.Destroy = function(c) {
  var fixtureA = c.GetFixtureA();
  var fixtureB = c.GetFixtureB();
  var bodyA = fixtureA.GetBody();
  var bodyB = fixtureB.GetBody();
  if(c.IsTouching()) {
    this.m_contactListener.EndContact(c)
  }
  if(c.m_prev) {
    c.m_prev.m_next = c.m_next
  }
  if(c.m_next) {
    c.m_next.m_prev = c.m_prev
  }
  if(c == this.m_world.m_contactList) {
    this.m_world.m_contactList = c.m_next
  }
  if(c.m_nodeA.prev) {
    c.m_nodeA.prev.next = c.m_nodeA.next
  }
  if(c.m_nodeA.next) {
    c.m_nodeA.next.prev = c.m_nodeA.prev
  }
  if(c.m_nodeA == bodyA.m_contactList) {
    bodyA.m_contactList = c.m_nodeA.next
  }
  if(c.m_nodeB.prev) {
    c.m_nodeB.prev.next = c.m_nodeB.next
  }
  if(c.m_nodeB.next) {
    c.m_nodeB.next.prev = c.m_nodeB.prev
  }
  if(c.m_nodeB == bodyB.m_contactList) {
    bodyB.m_contactList = c.m_nodeB.next
  }
  this.m_contactFactory.Destroy(c);
  --this.m_contactCount
};
b2ContactManager.prototype.Collide = function() {
  var c = this.m_world.m_contactList;
  while(c) {
    var fixtureA = c.GetFixtureA();
    var fixtureB = c.GetFixtureB();
    var bodyA = fixtureA.GetBody();
    var bodyB = fixtureB.GetBody();
    if(bodyA.IsAwake() == false && bodyB.IsAwake() == false) {
      c = c.GetNext();
      continue
    }
    if(c.m_flags & b2Contact.e_filterFlag) {
      if(bodyB.ShouldCollide(bodyA) == false) {
        var cNuke = c;
        c = cNuke.GetNext();
        this.Destroy(cNuke);
        continue
      }
      if(this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
        cNuke = c;
        c = cNuke.GetNext();
        this.Destroy(cNuke);
        continue
      }
      c.m_flags &= ~b2Contact.e_filterFlag
    }
    var proxyA = fixtureA.m_proxy;
    var proxyB = fixtureB.m_proxy;
    var overlap = this.m_broadPhase.TestOverlap(proxyA, proxyB);
    if(overlap == false) {
      cNuke = c;
      c = cNuke.GetNext();
      this.Destroy(cNuke);
      continue
    }
    c.Update(this.m_contactListener);
    c = c.GetNext()
  }
};
b2ContactManager.prototype.m_world = null;
b2ContactManager.prototype.m_broadPhase = null;
b2ContactManager.prototype.m_contactList = null;
b2ContactManager.prototype.m_contactCount = 0;
b2ContactManager.prototype.m_contactFilter = null;
b2ContactManager.prototype.m_contactListener = null;
b2ContactManager.prototype.m_contactFactory = null;
b2ContactManager.prototype.m_allocator = null;var b2World = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2World.prototype.__constructor = function(gravity, doSleep) {
  this.m_destructionListener = null;
  this.m_debugDraw = null;
  this.m_bodyList = null;
  this.m_contactList = null;
  this.m_jointList = null;
  this.m_controllerList = null;
  this.m_bodyCount = 0;
  this.m_contactCount = 0;
  this.m_jointCount = 0;
  this.m_controllerCount = 0;
  b2World.m_warmStarting = true;
  b2World.m_continuousPhysics = true;
  this.m_allowSleep = doSleep;
  this.m_gravity = gravity;
  this.m_inv_dt0 = 0;
  this.m_contactManager.m_world = this;
  var bd = new b2BodyDef;
  this.m_groundBody = this.CreateBody(bd)
};
b2World.prototype.__varz = function() {
  this.s_stack = new Array;
  this.m_contactManager = new b2ContactManager;
  this.m_contactSolver = new b2ContactSolver;
  this.m_island = new b2Island
};
b2World.s_timestep2 = new b2TimeStep;
b2World.s_backupA = new b2Sweep;
b2World.s_backupB = new b2Sweep;
b2World.s_timestep = new b2TimeStep;
b2World.s_queue = new Array;
b2World.e_newFixture = 1;
b2World.e_locked = 2;
b2World.s_xf = new b2Transform;
b2World.s_jointColor = new b2Color(0.5, 0.8, 0.8);
b2World.m_warmStarting = null;
b2World.m_continuousPhysics = null;
b2World.prototype.Solve = function(step) {
  var b;
  for(var controller = this.m_controllerList;controller;controller = controller.m_next) {
    controller.Step(step)
  }
  var island = this.m_island;
  island.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
  for(b = this.m_bodyList;b;b = b.m_next) {
    b.m_flags &= ~b2Body.e_islandFlag
  }
  for(var c = this.m_contactList;c;c = c.m_next) {
    c.m_flags &= ~b2Contact.e_islandFlag
  }
  for(var j = this.m_jointList;j;j = j.m_next) {
    j.m_islandFlag = false
  }
  var stackSize = this.m_bodyCount;
  var stack = this.s_stack;
  for(var seed = this.m_bodyList;seed;seed = seed.m_next) {
    if(seed.m_flags & b2Body.e_islandFlag) {
      continue
    }
    if(seed.IsAwake() == false || seed.IsActive() == false) {
      continue
    }
    if(seed.GetType() == b2Body.b2_staticBody) {
      continue
    }
    island.Clear();
    var stackCount = 0;
    stack[stackCount++] = seed;
    seed.m_flags |= b2Body.e_islandFlag;
    while(stackCount > 0) {
      b = stack[--stackCount];
      island.AddBody(b);
      if(b.IsAwake() == false) {
        b.SetAwake(true)
      }
      if(b.GetType() == b2Body.b2_staticBody) {
        continue
      }
      var other;
      for(var ce = b.m_contactList;ce;ce = ce.next) {
        if(ce.contact.m_flags & b2Contact.e_islandFlag) {
          continue
        }
        if(ce.contact.IsSensor() == true || ce.contact.IsEnabled() == false || ce.contact.IsTouching() == false) {
          continue
        }
        island.AddContact(ce.contact);
        ce.contact.m_flags |= b2Contact.e_islandFlag;
        other = ce.other;
        if(other.m_flags & b2Body.e_islandFlag) {
          continue
        }
        stack[stackCount++] = other;
        other.m_flags |= b2Body.e_islandFlag
      }
      for(var jn = b.m_jointList;jn;jn = jn.next) {
        if(jn.joint.m_islandFlag == true) {
          continue
        }
        other = jn.other;
        if(other.IsActive() == false) {
          continue
        }
        island.AddJoint(jn.joint);
        jn.joint.m_islandFlag = true;
        if(other.m_flags & b2Body.e_islandFlag) {
          continue
        }
        stack[stackCount++] = other;
        other.m_flags |= b2Body.e_islandFlag
      }
    }
    island.Solve(step, this.m_gravity, this.m_allowSleep);
    for(var i = 0;i < island.m_bodyCount;++i) {
      b = island.m_bodies[i];
      if(b.GetType() == b2Body.b2_staticBody) {
        b.m_flags &= ~b2Body.e_islandFlag
      }
    }
  }
  for(i = 0;i < stack.length;++i) {
    if(!stack[i]) {
      break
    }
    stack[i] = null
  }
  for(b = this.m_bodyList;b;b = b.m_next) {
    if(b.IsAwake() == false || b.IsActive() == false) {
      continue
    }
    if(b.GetType() == b2Body.b2_staticBody) {
      continue
    }
    b.SynchronizeFixtures()
  }
  this.m_contactManager.FindNewContacts()
};
b2World.prototype.SolveTOI = function(step) {
  var b;
  var fA;
  var fB;
  var bA;
  var bB;
  var cEdge;
  var j;
  var island = this.m_island;
  island.Initialize(this.m_bodyCount, b2Settings.b2_maxTOIContactsPerIsland, b2Settings.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
  var queue = b2World.s_queue;
  for(b = this.m_bodyList;b;b = b.m_next) {
    b.m_flags &= ~b2Body.e_islandFlag;
    b.m_sweep.t0 = 0
  }
  var c;
  for(c = this.m_contactList;c;c = c.m_next) {
    c.m_flags &= ~(b2Contact.e_toiFlag | b2Contact.e_islandFlag)
  }
  for(j = this.m_jointList;j;j = j.m_next) {
    j.m_islandFlag = false
  }
  for(;;) {
    var minContact = null;
    var minTOI = 1;
    for(c = this.m_contactList;c;c = c.m_next) {
      if(c.IsSensor() == true || c.IsEnabled() == false || c.IsContinuous() == false) {
        continue
      }
      var toi = 1;
      if(c.m_flags & b2Contact.e_toiFlag) {
        toi = c.m_toi
      }else {
        fA = c.m_fixtureA;
        fB = c.m_fixtureB;
        bA = fA.m_body;
        bB = fB.m_body;
        if((bA.GetType() != b2Body.b2_dynamicBody || bA.IsAwake() == false) && (bB.GetType() != b2Body.b2_dynamicBody || bB.IsAwake() == false)) {
          continue
        }
        var t0 = bA.m_sweep.t0;
        if(bA.m_sweep.t0 < bB.m_sweep.t0) {
          t0 = bB.m_sweep.t0;
          bA.m_sweep.Advance(t0)
        }else {
          if(bB.m_sweep.t0 < bA.m_sweep.t0) {
            t0 = bA.m_sweep.t0;
            bB.m_sweep.Advance(t0)
          }
        }
        toi = c.ComputeTOI(bA.m_sweep, bB.m_sweep);
        b2Settings.b2Assert(0 <= toi && toi <= 1);
        if(toi > 0 && toi < 1) {
          toi = (1 - toi) * t0 + toi;
          if(toi > 1) {
            toi = 1
          }
        }
        c.m_toi = toi;
        c.m_flags |= b2Contact.e_toiFlag
      }
      if(Number.MIN_VALUE < toi && toi < minTOI) {
        minContact = c;
        minTOI = toi
      }
    }
    if(minContact == null || 1 - 100 * Number.MIN_VALUE < minTOI) {
      break
    }
    fA = minContact.m_fixtureA;
    fB = minContact.m_fixtureB;
    bA = fA.m_body;
    bB = fB.m_body;
    b2World.s_backupA.Set(bA.m_sweep);
    b2World.s_backupB.Set(bB.m_sweep);
    bA.Advance(minTOI);
    bB.Advance(minTOI);
    minContact.Update(this.m_contactManager.m_contactListener);
    minContact.m_flags &= ~b2Contact.e_toiFlag;
    if(minContact.IsSensor() == true || minContact.IsEnabled() == false) {
      bA.m_sweep.Set(b2World.s_backupA);
      bB.m_sweep.Set(b2World.s_backupB);
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      continue
    }
    if(minContact.IsTouching() == false) {
      continue
    }
    var seed = bA;
    if(seed.GetType() != b2Body.b2_dynamicBody) {
      seed = bB
    }
    island.Clear();
    var queueStart = 0;
    var queueSize = 0;
    queue[queueStart + queueSize++] = seed;
    seed.m_flags |= b2Body.e_islandFlag;
    while(queueSize > 0) {
      b = queue[queueStart++];
      --queueSize;
      island.AddBody(b);
      if(b.IsAwake() == false) {
        b.SetAwake(true)
      }
      if(b.GetType() != b2Body.b2_dynamicBody) {
        continue
      }
      for(cEdge = b.m_contactList;cEdge;cEdge = cEdge.next) {
        if(island.m_contactCount == island.m_contactCapacity) {
          break
        }
        if(cEdge.contact.m_flags & b2Contact.e_islandFlag) {
          continue
        }
        if(cEdge.contact.IsSensor() == true || cEdge.contact.IsEnabled() == false || cEdge.contact.IsTouching() == false) {
          continue
        }
        island.AddContact(cEdge.contact);
        cEdge.contact.m_flags |= b2Contact.e_islandFlag;
        var other = cEdge.other;
        if(other.m_flags & b2Body.e_islandFlag) {
          continue
        }
        if(other.GetType() != b2Body.b2_staticBody) {
          other.Advance(minTOI);
          other.SetAwake(true)
        }
        queue[queueStart + queueSize] = other;
        ++queueSize;
        other.m_flags |= b2Body.e_islandFlag
      }
      for(var jEdge = b.m_jointList;jEdge;jEdge = jEdge.next) {
        if(island.m_jointCount == island.m_jointCapacity) {
          continue
        }
        if(jEdge.joint.m_islandFlag == true) {
          continue
        }
        other = jEdge.other;
        if(other.IsActive() == false) {
          continue
        }
        island.AddJoint(jEdge.joint);
        jEdge.joint.m_islandFlag = true;
        if(other.m_flags & b2Body.e_islandFlag) {
          continue
        }
        if(other.GetType() != b2Body.b2_staticBody) {
          other.Advance(minTOI);
          other.SetAwake(true)
        }
        queue[queueStart + queueSize] = other;
        ++queueSize;
        other.m_flags |= b2Body.e_islandFlag
      }
    }
    var subStep = b2World.s_timestep;
    subStep.warmStarting = false;
    subStep.dt = (1 - minTOI) * step.dt;
    subStep.inv_dt = 1 / subStep.dt;
    subStep.dtRatio = 0;
    subStep.velocityIterations = step.velocityIterations;
    subStep.positionIterations = step.positionIterations;
    island.SolveTOI(subStep);
    var i = 0;
    for(i = 0;i < island.m_bodyCount;++i) {
      b = island.m_bodies[i];
      b.m_flags &= ~b2Body.e_islandFlag;
      if(b.IsAwake() == false) {
        continue
      }
      if(b.GetType() != b2Body.b2_dynamicBody) {
        continue
      }
      b.SynchronizeFixtures();
      for(cEdge = b.m_contactList;cEdge;cEdge = cEdge.next) {
        cEdge.contact.m_flags &= ~b2Contact.e_toiFlag
      }
    }
    for(i = 0;i < island.m_contactCount;++i) {
      c = island.m_contacts[i];
      c.m_flags &= ~(b2Contact.e_toiFlag | b2Contact.e_islandFlag)
    }
    for(i = 0;i < island.m_jointCount;++i) {
      j = island.m_joints[i];
      j.m_islandFlag = false
    }
    this.m_contactManager.FindNewContacts()
  }
};
b2World.prototype.DrawJoint = function(joint) {
  var b1 = joint.GetBodyA();
  var b2 = joint.GetBodyB();
  var xf1 = b1.m_xf;
  var xf2 = b2.m_xf;
  var x1 = xf1.position;
  var x2 = xf2.position;
  var p1 = joint.GetAnchorA();
  var p2 = joint.GetAnchorB();
  var color = b2World.s_jointColor;
  switch(joint.m_type) {
    case b2Joint.e_distanceJoint:
      this.m_debugDraw.DrawSegment(p1, p2, color);
      break;
    case b2Joint.e_pulleyJoint:
      var pulley = joint;
      var s1 = pulley.GetGroundAnchorA();
      var s2 = pulley.GetGroundAnchorB();
      this.m_debugDraw.DrawSegment(s1, p1, color);
      this.m_debugDraw.DrawSegment(s2, p2, color);
      this.m_debugDraw.DrawSegment(s1, s2, color);
      break;
    case b2Joint.e_mouseJoint:
      this.m_debugDraw.DrawSegment(p1, p2, color);
      break;
    default:
      if(b1 != this.m_groundBody) {
        this.m_debugDraw.DrawSegment(x1, p1, color)
      }
      this.m_debugDraw.DrawSegment(p1, p2, color);
      if(b2 != this.m_groundBody) {
        this.m_debugDraw.DrawSegment(x2, p2, color)
      }
  }
};
b2World.prototype.DrawShape = function(shape, xf, color) {
  switch(shape.m_type) {
    case b2Shape.e_circleShape:
      var circle = shape;
      var center = b2Math.MulX(xf, circle.m_p);
      var radius = circle.m_radius;
      var axis = xf.R.col1;
      this.m_debugDraw.DrawSolidCircle(center, radius, axis, color);
      break;
    case b2Shape.e_polygonShape:
      var i = 0;
      var poly = shape;
      var vertexCount = poly.GetVertexCount();
      var localVertices = poly.GetVertices();
      var vertices = new Array(vertexCount);
      for(i = 0;i < vertexCount;++i) {
        vertices[i] = b2Math.MulX(xf, localVertices[i])
      }
      this.m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);
      break;
    case b2Shape.e_edgeShape:
      var edge = shape;
      this.m_debugDraw.DrawSegment(b2Math.MulX(xf, edge.GetVertex1()), b2Math.MulX(xf, edge.GetVertex2()), color);
      break
  }
};
b2World.prototype.SetDestructionListener = function(listener) {
  this.m_destructionListener = listener
};
b2World.prototype.SetContactFilter = function(filter) {
  this.m_contactManager.m_contactFilter = filter
};
b2World.prototype.SetContactListener = function(listener) {
  this.m_contactManager.m_contactListener = listener
};
b2World.prototype.SetDebugDraw = function(debugDraw) {
  this.m_debugDraw = debugDraw
};
b2World.prototype.SetBroadPhase = function(broadPhase) {
  var oldBroadPhase = this.m_contactManager.m_broadPhase;
  this.m_contactManager.m_broadPhase = broadPhase;
  for(var b = this.m_bodyList;b;b = b.m_next) {
    for(var f = b.m_fixtureList;f;f = f.m_next) {
      f.m_proxy = broadPhase.CreateProxy(oldBroadPhase.GetFatAABB(f.m_proxy), f)
    }
  }
};
b2World.prototype.Validate = function() {
  this.m_contactManager.m_broadPhase.Validate()
};
b2World.prototype.GetProxyCount = function() {
  return this.m_contactManager.m_broadPhase.GetProxyCount()
};
b2World.prototype.CreateBody = function(def) {
  if(this.IsLocked() == true) {
    return null
  }
  var b = new b2Body(def, this);
  b.m_prev = null;
  b.m_next = this.m_bodyList;
  if(this.m_bodyList) {
    this.m_bodyList.m_prev = b
  }
  this.m_bodyList = b;
  ++this.m_bodyCount;
  return b
};
b2World.prototype.DestroyBody = function(b) {
  if(this.IsLocked() == true) {
    return
  }
  var jn = b.m_jointList;
  while(jn) {
    var jn0 = jn;
    jn = jn.next;
    if(this.m_destructionListener) {
      this.m_destructionListener.SayGoodbyeJoint(jn0.joint)
    }
    this.DestroyJoint(jn0.joint)
  }
  var coe = b.m_controllerList;
  while(coe) {
    var coe0 = coe;
    coe = coe.nextController;
    coe0.controller.RemoveBody(b)
  }
  var ce = b.m_contactList;
  while(ce) {
    var ce0 = ce;
    ce = ce.next;
    this.m_contactManager.Destroy(ce0.contact)
  }
  b.m_contactList = null;
  var f = b.m_fixtureList;
  while(f) {
    var f0 = f;
    f = f.m_next;
    if(this.m_destructionListener) {
      this.m_destructionListener.SayGoodbyeFixture(f0)
    }
    f0.DestroyProxy(this.m_contactManager.m_broadPhase);
    f0.Destroy()
  }
  b.m_fixtureList = null;
  b.m_fixtureCount = 0;
  if(b.m_prev) {
    b.m_prev.m_next = b.m_next
  }
  if(b.m_next) {
    b.m_next.m_prev = b.m_prev
  }
  if(b == this.m_bodyList) {
    this.m_bodyList = b.m_next
  }
  --this.m_bodyCount
};
b2World.prototype.CreateJoint = function(def) {
  var j = b2Joint.Create(def, null);
  j.m_prev = null;
  j.m_next = this.m_jointList;
  if(this.m_jointList) {
    this.m_jointList.m_prev = j
  }
  this.m_jointList = j;
  ++this.m_jointCount;
  j.m_edgeA.joint = j;
  j.m_edgeA.other = j.m_bodyB;
  j.m_edgeA.prev = null;
  j.m_edgeA.next = j.m_bodyA.m_jointList;
  if(j.m_bodyA.m_jointList) {
    j.m_bodyA.m_jointList.prev = j.m_edgeA
  }
  j.m_bodyA.m_jointList = j.m_edgeA;
  j.m_edgeB.joint = j;
  j.m_edgeB.other = j.m_bodyA;
  j.m_edgeB.prev = null;
  j.m_edgeB.next = j.m_bodyB.m_jointList;
  if(j.m_bodyB.m_jointList) {
    j.m_bodyB.m_jointList.prev = j.m_edgeB
  }
  j.m_bodyB.m_jointList = j.m_edgeB;
  var bodyA = def.bodyA;
  var bodyB = def.bodyB;
  if(def.collideConnected == false) {
    var edge = bodyB.GetContactList();
    while(edge) {
      if(edge.other == bodyA) {
        edge.contact.FlagForFiltering()
      }
      edge = edge.next
    }
  }
  return j
};
b2World.prototype.DestroyJoint = function(j) {
  var collideConnected = j.m_collideConnected;
  if(j.m_prev) {
    j.m_prev.m_next = j.m_next
  }
  if(j.m_next) {
    j.m_next.m_prev = j.m_prev
  }
  if(j == this.m_jointList) {
    this.m_jointList = j.m_next
  }
  var bodyA = j.m_bodyA;
  var bodyB = j.m_bodyB;
  bodyA.SetAwake(true);
  bodyB.SetAwake(true);
  if(j.m_edgeA.prev) {
    j.m_edgeA.prev.next = j.m_edgeA.next
  }
  if(j.m_edgeA.next) {
    j.m_edgeA.next.prev = j.m_edgeA.prev
  }
  if(j.m_edgeA == bodyA.m_jointList) {
    bodyA.m_jointList = j.m_edgeA.next
  }
  j.m_edgeA.prev = null;
  j.m_edgeA.next = null;
  if(j.m_edgeB.prev) {
    j.m_edgeB.prev.next = j.m_edgeB.next
  }
  if(j.m_edgeB.next) {
    j.m_edgeB.next.prev = j.m_edgeB.prev
  }
  if(j.m_edgeB == bodyB.m_jointList) {
    bodyB.m_jointList = j.m_edgeB.next
  }
  j.m_edgeB.prev = null;
  j.m_edgeB.next = null;
  b2Joint.Destroy(j, null);
  --this.m_jointCount;
  if(collideConnected == false) {
    var edge = bodyB.GetContactList();
    while(edge) {
      if(edge.other == bodyA) {
        edge.contact.FlagForFiltering()
      }
      edge = edge.next
    }
  }
};
b2World.prototype.AddController = function(c) {
  c.m_next = this.m_controllerList;
  c.m_prev = null;
  this.m_controllerList = c;
  c.m_world = this;
  this.m_controllerCount++;
  return c
};
b2World.prototype.RemoveController = function(c) {
  if(c.m_prev) {
    c.m_prev.m_next = c.m_next
  }
  if(c.m_next) {
    c.m_next.m_prev = c.m_prev
  }
  if(this.m_controllerList == c) {
    this.m_controllerList = c.m_next
  }
  this.m_controllerCount--
};
b2World.prototype.CreateController = function(controller) {
  if(controller.m_world != this) {
    throw new Error("Controller can only be a member of one world");
  }
  controller.m_next = this.m_controllerList;
  controller.m_prev = null;
  if(this.m_controllerList) {
    this.m_controllerList.m_prev = controller
  }
  this.m_controllerList = controller;
  ++this.m_controllerCount;
  controller.m_world = this;
  return controller
};
b2World.prototype.DestroyController = function(controller) {
  controller.Clear();
  if(controller.m_next) {
    controller.m_next.m_prev = controller.m_prev
  }
  if(controller.m_prev) {
    controller.m_prev.m_next = controller.m_next
  }
  if(controller == this.m_controllerList) {
    this.m_controllerList = controller.m_next
  }
  --this.m_controllerCount
};
b2World.prototype.SetWarmStarting = function(flag) {
  b2World.m_warmStarting = flag
};
b2World.prototype.SetContinuousPhysics = function(flag) {
  b2World.m_continuousPhysics = flag
};
b2World.prototype.GetBodyCount = function() {
  return this.m_bodyCount
};
b2World.prototype.GetJointCount = function() {
  return this.m_jointCount
};
b2World.prototype.GetContactCount = function() {
  return this.m_contactCount
};
b2World.prototype.SetGravity = function(gravity) {
  this.m_gravity = gravity
};
b2World.prototype.GetGravity = function() {
  return this.m_gravity
};
b2World.prototype.GetGroundBody = function() {
  return this.m_groundBody
};
b2World.prototype.Step = function(dt, velocityIterations, positionIterations) {
  if(this.m_flags & b2World.e_newFixture) {
    this.m_contactManager.FindNewContacts();
    this.m_flags &= ~b2World.e_newFixture
  }
  this.m_flags |= b2World.e_locked;
  var step = b2World.s_timestep2;
  step.dt = dt;
  step.velocityIterations = velocityIterations;
  step.positionIterations = positionIterations;
  if(dt > 0) {
    step.inv_dt = 1 / dt
  }else {
    step.inv_dt = 0
  }
  step.dtRatio = this.m_inv_dt0 * dt;
  step.warmStarting = b2World.m_warmStarting;
  this.m_contactManager.Collide();
  if(step.dt > 0) {
    this.Solve(step)
  }
  if(b2World.m_continuousPhysics && step.dt > 0) {
    this.SolveTOI(step)
  }
  if(step.dt > 0) {
    this.m_inv_dt0 = step.inv_dt
  }
  this.m_flags &= ~b2World.e_locked
};
b2World.prototype.ClearForces = function() {
  for(var body = this.m_bodyList;body;body = body.m_next) {
    body.m_force.SetZero();
    body.m_torque = 0
  }
};
b2World.prototype.DrawDebugData = function() {
  if(this.m_debugDraw == null) {
    return
  }
  this.m_debugDraw.Clear();
  var flags = this.m_debugDraw.GetFlags();
  var i = 0;
  var b;
  var f;
  var s;
  var j;
  var bp;
  var invQ = new b2Vec2;
  var x1 = new b2Vec2;
  var x2 = new b2Vec2;
  var xf;
  var b1 = new b2AABB;
  var b2 = new b2AABB;
  var vs = [new b2Vec2, new b2Vec2, new b2Vec2, new b2Vec2];
  var color = new b2Color(0, 0, 0);
  if(flags & b2DebugDraw.e_shapeBit) {
    for(b = this.m_bodyList;b;b = b.m_next) {
      xf = b.m_xf;
      for(f = b.GetFixtureList();f;f = f.m_next) {
        s = f.GetShape();
        if(b.IsActive() == false) {
          color.Set(0.5, 0.5, 0.3);
          this.DrawShape(s, xf, color)
        }else {
          if(b.GetType() == b2Body.b2_staticBody) {
            color.Set(0.5, 0.9, 0.5);
            this.DrawShape(s, xf, color)
          }else {
            if(b.GetType() == b2Body.b2_kinematicBody) {
              color.Set(0.5, 0.5, 0.9);
              this.DrawShape(s, xf, color)
            }else {
              if(b.IsAwake() == false) {
                color.Set(0.6, 0.6, 0.6);
                this.DrawShape(s, xf, color)
              }else {
                color.Set(0.9, 0.7, 0.7);
                this.DrawShape(s, xf, color)
              }
            }
          }
        }
      }
    }
  }
  if(flags & b2DebugDraw.e_jointBit) {
    for(j = this.m_jointList;j;j = j.m_next) {
      this.DrawJoint(j)
    }
  }
  if(flags & b2DebugDraw.e_controllerBit) {
    for(var c = this.m_controllerList;c;c = c.m_next) {
      c.Draw(this.m_debugDraw)
    }
  }
  if(flags & b2DebugDraw.e_pairBit) {
    color.Set(0.3, 0.9, 0.9);
    for(var contact = this.m_contactManager.m_contactList;contact;contact = contact.GetNext()) {
      var fixtureA = contact.GetFixtureA();
      var fixtureB = contact.GetFixtureB();
      var cA = fixtureA.GetAABB().GetCenter();
      var cB = fixtureB.GetAABB().GetCenter();
      this.m_debugDraw.DrawSegment(cA, cB, color)
    }
  }
  if(flags & b2DebugDraw.e_aabbBit) {
    bp = this.m_contactManager.m_broadPhase;
    vs = [new b2Vec2, new b2Vec2, new b2Vec2, new b2Vec2];
    for(b = this.m_bodyList;b;b = b.GetNext()) {
      if(b.IsActive() == false) {
        continue
      }
      for(f = b.GetFixtureList();f;f = f.GetNext()) {
        var aabb = bp.GetFatAABB(f.m_proxy);
        vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);
        vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);
        vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);
        vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);
        this.m_debugDraw.DrawPolygon(vs, 4, color)
      }
    }
  }
  if(flags & b2DebugDraw.e_centerOfMassBit) {
    for(b = this.m_bodyList;b;b = b.m_next) {
      xf = b2World.s_xf;
      xf.R = b.m_xf.R;
      xf.position = b.GetWorldCenter();
      this.m_debugDraw.DrawTransform(xf)
    }
  }
};
b2World.prototype.QueryAABB = function(callback, aabb) {
  var broadPhase = this.m_contactManager.m_broadPhase;
  function WorldQueryWrapper(proxy) {
    return callback(broadPhase.GetUserData(proxy))
  }
  broadPhase.Query(WorldQueryWrapper, aabb)
};
b2World.prototype.QueryShape = function(callback, shape, transform) {
  if(transform == null) {
    transform = new b2Transform;
    transform.SetIdentity()
  }
  var broadPhase = this.m_contactManager.m_broadPhase;
  function WorldQueryWrapper(proxy) {
    var fixture = broadPhase.GetUserData(proxy);
    if(b2Shape.TestOverlap(shape, transform, fixture.GetShape(), fixture.GetBody().GetTransform())) {
      return callback(fixture)
    }
    return true
  }
  var aabb = new b2AABB;
  shape.ComputeAABB(aabb, transform);
  broadPhase.Query(WorldQueryWrapper, aabb)
};
b2World.prototype.QueryPoint = function(callback, p) {
  var broadPhase = this.m_contactManager.m_broadPhase;
  function WorldQueryWrapper(proxy) {
    var fixture = broadPhase.GetUserData(proxy);
    if(fixture.TestPoint(p)) {
      return callback(fixture)
    }
    return true
  }
  var aabb = new b2AABB;
  aabb.lowerBound.Set(p.x - b2Settings.b2_linearSlop, p.y - b2Settings.b2_linearSlop);
  aabb.upperBound.Set(p.x + b2Settings.b2_linearSlop, p.y + b2Settings.b2_linearSlop);
  broadPhase.Query(WorldQueryWrapper, aabb)
};
b2World.prototype.RayCast = function(callback, point1, point2) {
  var broadPhase = this.m_contactManager.m_broadPhase;
  var output = new b2RayCastOutput;
  function RayCastWrapper(input, proxy) {
    var userData = broadPhase.GetUserData(proxy);
    var fixture = userData;
    var hit = fixture.RayCast(output, input);
    if(hit) {
      var fraction = output.fraction;
      var point = new b2Vec2((1 - fraction) * point1.x + fraction * point2.x, (1 - fraction) * point1.y + fraction * point2.y);
      return callback(fixture, point, output.normal, fraction)
    }
    return input.maxFraction
  }
  var input = new b2RayCastInput(point1, point2);
  broadPhase.RayCast(RayCastWrapper, input)
};
b2World.prototype.RayCastOne = function(point1, point2) {
  var result;
  function RayCastOneWrapper(fixture, point, normal, fraction) {
    result = fixture;
    return fraction
  }
  this.RayCast(RayCastOneWrapper, point1, point2);
  return result
};
b2World.prototype.RayCastAll = function(point1, point2) {
  var result = new Array;
  function RayCastAllWrapper(fixture, point, normal, fraction) {
    result[result.length] = fixture;
    return 1
  }
  this.RayCast(RayCastAllWrapper, point1, point2);
  return result
};
b2World.prototype.GetBodyList = function() {
  return this.m_bodyList
};
b2World.prototype.GetJointList = function() {
  return this.m_jointList
};
b2World.prototype.GetContactList = function() {
  return this.m_contactList
};
b2World.prototype.IsLocked = function() {
  return(this.m_flags & b2World.e_locked) > 0
};
b2World.prototype.s_stack = new Array;
b2World.prototype.m_flags = 0;
b2World.prototype.m_contactManager = new b2ContactManager;
b2World.prototype.m_contactSolver = new b2ContactSolver;
b2World.prototype.m_island = new b2Island;
b2World.prototype.m_bodyList = null;
b2World.prototype.m_jointList = null;
b2World.prototype.m_contactList = null;
b2World.prototype.m_bodyCount = 0;
b2World.prototype.m_contactCount = 0;
b2World.prototype.m_jointCount = 0;
b2World.prototype.m_controllerList = null;
b2World.prototype.m_controllerCount = 0;
b2World.prototype.m_gravity = null;
b2World.prototype.m_allowSleep = null;
b2World.prototype.m_groundBody = null;
b2World.prototype.m_destructionListener = null;
b2World.prototype.m_debugDraw = null;
b2World.prototype.m_inv_dt0 = null;if(typeof exports !== "undefined") {
  exports.b2BoundValues = b2BoundValues;
  exports.b2Math = b2Math;
  exports.b2DistanceOutput = b2DistanceOutput;
  exports.b2Mat33 = b2Mat33;
  exports.b2ContactPoint = b2ContactPoint;
  exports.b2PairManager = b2PairManager;
  exports.b2PositionSolverManifold = b2PositionSolverManifold;
  exports.b2OBB = b2OBB;
  exports.b2CircleContact = b2CircleContact;
  exports.b2PulleyJoint = b2PulleyJoint;
  exports.b2Pair = b2Pair;
  exports.b2TimeStep = b2TimeStep;
  exports.b2FixtureDef = b2FixtureDef;
  exports.b2World = b2World;
  exports.b2PrismaticJoint = b2PrismaticJoint;
  exports.b2Controller = b2Controller;
  exports.b2ContactID = b2ContactID;
  exports.b2RevoluteJoint = b2RevoluteJoint;
  exports.b2JointDef = b2JointDef;
  exports.b2Transform = b2Transform;
  exports.b2GravityController = b2GravityController;
  exports.b2EdgeAndCircleContact = b2EdgeAndCircleContact;
  exports.b2EdgeShape = b2EdgeShape;
  exports.b2BuoyancyController = b2BuoyancyController;
  exports.b2LineJointDef = b2LineJointDef;
  exports.b2Contact = b2Contact;
  exports.b2DistanceJoint = b2DistanceJoint;
  exports.b2Body = b2Body;
  exports.b2DestructionListener = b2DestructionListener;
  exports.b2PulleyJointDef = b2PulleyJointDef;
  exports.b2ContactEdge = b2ContactEdge;
  exports.b2ContactConstraint = b2ContactConstraint;
  exports.b2ContactImpulse = b2ContactImpulse;
  exports.b2DistanceJointDef = b2DistanceJointDef;
  exports.b2ContactResult = b2ContactResult;
  exports.b2EdgeChainDef = b2EdgeChainDef;
  exports.b2Vec2 = b2Vec2;
  exports.b2Vec3 = b2Vec3;
  exports.b2DistanceProxy = b2DistanceProxy;
  exports.b2FrictionJointDef = b2FrictionJointDef;
  exports.b2PolygonContact = b2PolygonContact;
  exports.b2TensorDampingController = b2TensorDampingController;
  exports.b2ContactFactory = b2ContactFactory;
  exports.b2WeldJointDef = b2WeldJointDef;
  exports.b2ConstantAccelController = b2ConstantAccelController;
  exports.b2GearJointDef = b2GearJointDef;
  exports.ClipVertex = ClipVertex;
  exports.b2SeparationFunction = b2SeparationFunction;
  exports.b2ManifoldPoint = b2ManifoldPoint;
  exports.b2Color = b2Color;
  exports.b2PolygonShape = b2PolygonShape;
  exports.b2DynamicTreePair = b2DynamicTreePair;
  exports.b2ContactConstraintPoint = b2ContactConstraintPoint;
  exports.b2FrictionJoint = b2FrictionJoint;
  exports.b2ContactFilter = b2ContactFilter;
  exports.b2ControllerEdge = b2ControllerEdge;
  exports.b2Distance = b2Distance;
  exports.b2Fixture = b2Fixture;
  exports.b2DynamicTreeNode = b2DynamicTreeNode;
  exports.b2MouseJoint = b2MouseJoint;
  exports.b2DistanceInput = b2DistanceInput;
  exports.b2BodyDef = b2BodyDef;
  exports.b2DynamicTreeBroadPhase = b2DynamicTreeBroadPhase;
  exports.b2Settings = b2Settings;
  exports.b2Proxy = b2Proxy;
  exports.b2Point = b2Point;
  exports.b2BroadPhase = b2BroadPhase;
  exports.b2Manifold = b2Manifold;
  exports.b2WorldManifold = b2WorldManifold;
  exports.b2PrismaticJointDef = b2PrismaticJointDef;
  exports.b2RayCastOutput = b2RayCastOutput;
  exports.b2ConstantForceController = b2ConstantForceController;
  exports.b2TimeOfImpact = b2TimeOfImpact;
  exports.b2CircleShape = b2CircleShape;
  exports.b2MassData = b2MassData;
  exports.b2Joint = b2Joint;
  exports.b2GearJoint = b2GearJoint;
  exports.b2DynamicTree = b2DynamicTree;
  exports.b2JointEdge = b2JointEdge;
  exports.b2LineJoint = b2LineJoint;
  exports.b2NullContact = b2NullContact;
  exports.b2ContactListener = b2ContactListener;
  exports.b2RayCastInput = b2RayCastInput;
  exports.b2TOIInput = b2TOIInput;
  exports.Features = Features;
  exports.b2FilterData = b2FilterData;
  exports.b2Island = b2Island;
  exports.b2ContactManager = b2ContactManager;
  exports.b2ContactSolver = b2ContactSolver;
  exports.b2Simplex = b2Simplex;
  exports.b2AABB = b2AABB;
  exports.b2Jacobian = b2Jacobian;
  exports.b2Bound = b2Bound;
  exports.b2RevoluteJointDef = b2RevoluteJointDef;
  exports.b2PolyAndEdgeContact = b2PolyAndEdgeContact;
  exports.b2SimplexVertex = b2SimplexVertex;
  exports.b2WeldJoint = b2WeldJoint;
  exports.b2Collision = b2Collision;
  exports.b2Mat22 = b2Mat22;
  exports.b2SimplexCache = b2SimplexCache;
  exports.b2PolyAndCircleContact = b2PolyAndCircleContact;
  exports.b2MouseJointDef = b2MouseJointDef;
  exports.b2Shape = b2Shape;
  exports.b2Segment = b2Segment;
  exports.b2ContactRegister = b2ContactRegister;
  exports.b2DebugDraw = b2DebugDraw;
  exports.b2Sweep = b2Sweep
}
;

}};
__resources__["/__builtin__/libs/cocos2d/ActionManager.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    console = require('system').console,
    Timer = require('./Scheduler').Timer,
    Scheduler = require('./Scheduler').Scheduler,
    events = require('events');

var ActionManager = BObject.extend(/** @lends cocos.ActionManager# */{
    targets: null,
    currentTarget: null,
    currentTargetSalvaged: null,

    /**
     * <p>A singleton that manages all the actions. Normally you
     * won't need to use this singleton directly. 99% of the cases you will use the
     * cocos.nodes.Node interface, which uses this singleton. But there are some cases where
     * you might need to use this singleton. Examples:</p>
     *
     * <ul>
     * <li>When you want to run an action where the target is different from a cocos.nodes.Node</li>
     * <li>When you want to pause / resume the actions</li>
     * </ul>
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     * @singleton
     */
    init: function () {
        ActionManager.superclass.init.call(this);

        Scheduler.get('sharedScheduler').scheduleUpdate({target: this, priority: 0, paused: false});
        this.targets = [];
    },

    /**
     * Adds an action with a target. If the target is already present, then the
     * action will be added to the existing target. If the target is not
     * present, a new instance of this target will be created either paused or
     * paused, and the action will be added to the newly created target. When
     * the target is paused, the queued actions won't be 'ticked'.
     *
     * @opt {cocos.nodes.Node} target Node to run the action on
     */
    addAction: function (opts) {

        var targetID = opts.target.get('id');
        var element = this.targets[targetID];

        if (!element) {
            element = this.targets[targetID] = {
                paused: false,
                target: opts.target,
                actions: []
            };
        }

        element.actions.push(opts.action);

        opts.action.startWithTarget(opts.target);
    },

    /**
     * Remove an action
     *
     * @param {cocos.actions.Action} action Action to remove
     */
    removeAction: function (action) {
        var targetID = action.originalTarget.get('id'),
            element = this.targets[targetID];

        if (!element) {
            return;
        }

        var actionIndex = element.actions.indexOf(action);

        if (actionIndex == -1) {
            return;
        }

        if (this.currentTarget == element) {
            element.currentActionSalvaged = true;
        } 
        
        element.actions[actionIndex] = null;
        element.actions.splice(actionIndex, 1); // Delete array item

        if (element.actions.length === 0) {
            if (this.currentTarget == element) {
                this.set('currentTargetSalvaged', true);
            }
        }
            
    },

    /**
     * Fetch an action belonging to a cocos.nodes.Node
     *
     * @returns {cocos.actions.Action}
     *
     * @opts {cocos.nodes.Node} target Target of the action
     * @opts {String} tag Tag of the action
     */
    getActionFromTarget: function(opts) {
        var tag = opts.tag,
            targetID = opts.target.get('id');

        var element = this.targets[targetID];
        if (!element) {
            return null;
        }
        for (var i = 0; i < element.actions.length; i++ ) {
            if (element.actions[i] && 
                (element.actions[i].get('tag') === tag)) {
                return element.actions[i];
            }
        }
        // Not found
        return null;
    },
     
    /**
     * Remove all actions for a cocos.nodes.Node
     *
     * @param {cocos.nodes.Node} target Node to remove all actions for
     */
    removeAllActionsFromTarget: function (target) {
        var targetID = target.get('id');

        var element = this.targets[targetID];
        if (!element) {
            return;
        }
        // Delete everything in array but don't replace it incase something else has a reference
        element.actions.splice(0, element.actions.length);
    },

    /**
     * @private
     */
    update: function (dt) {
        var self = this;
        util.each(this.targets, function (currentTarget, i) {

            if (!currentTarget) {
                return;
            }
            self.currentTarget = currentTarget;

            if (!currentTarget.paused) {
                util.each(currentTarget.actions, function (currentAction, j) {
                    if (!currentAction) {
                        return;
                    }

                    currentTarget.currentAction = currentAction;
                    currentTarget.currentActionSalvaged = false;

                    currentTarget.currentAction.step(dt);

                    if (currentTarget.currentAction.get('isDone')) {
                        events.trigger(currentTarget.currentAction, 'actionComplete');
                    
                        currentTarget.currentAction.stop();

                        var a = currentTarget.currentAction;
                        currentTarget.currentAction = null;
                        self.removeAction(a);
                    }

                    currentTarget.currentAction = null;

                });
            }

            if (self.currentTargetSalvaged && currentTarget.actions.length === 0) {
                self.targets[i] = null;
                delete self.targets[i];
            }
        });
    },

    pauseTarget: function (target) {
    },

    resumeTarget: function (target) {
        // TODO
    }
});

util.extend(ActionManager, /** @lends cocos.ActionManager */{
    /**
     * Singleton instance of cocos.ActionManager
     * @getter sharedManager
     * @type cocos.ActionManager
     */
    get_sharedManager: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});

exports.ActionManager = ActionManager;

}};
__resources__["/__builtin__/libs/cocos2d/actions/Action.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    console = require('system').console,
    geo = require('geometry'),
    ccp = geo.ccp;

/** 
 * @memberOf cocos.actions
 * @class Base class for Actions
 * @extends BObject
 * @constructor
 */
var Action = BObject.extend(/** @lends cocos.actions.Action# */{
    /**
     * The Node the action is being performed on
     * @type cocos.nodes.Node
     */
    target: null,
    originalTarget: null,
    
    /**
     * Unique tag to identify the action
     * @type *
     */
    tag: null,
    
    /**
     * Called every frame with it's delta time.
     *
     * @param {Float} dt The delta time
     */
    step: function (dt) {
        window.console.warn("Action.step() Override me");
    },

    /**
     * Called once per frame.
     *
     * @param {Float} time How much of the animation has played. 0.0 = just started, 1.0 just finished.
     */
    update: function (time) {
        window.console.warn("Action.update() Override me");
    },

    /**
     * Called before the action start. It will also set the target.
     *
     * @param {cocos.nodes.Node} target The Node to run the action on
     */
    startWithTarget: function (target) {
        this.target = this.originalTarget = target;
    },

    /**
     * Called after the action has finished. It will set the 'target' to nil.
     * <strong>Important</strong>: You should never call cocos.actions.Action#stop manually.
     * Instead, use cocos.nodes.Node#stopAction(action)
     */
    stop: function () {
        this.target = null;
    },

    /**
     * @getter isDone
     * @type {Boolean} 
     */
    get_isDone: function (key) {
        return true;
    },


    /**
     * Returns a copy of this Action but in reverse
     *
     * @returns {cocos.actions.Action} A new Action in reverse
     */
    reverse: function () {
    }
});

var RepeatForever = Action.extend(/** @lends cocos.actions.RepeatForever# */{
    other: null,

    /**
     * @memberOf cocos.actions
     * @class Repeats an action forever. To repeat the an action for a limited
     * number of times use the cocos.Repeat action.
     * @extends cocos.actions.Action
     * @param {cocos.actions.Action} action An action to repeat forever
     * @constructs
     */
    init: function (action) {
        RepeatForever.superclass.init(this, action);

        this.other = action;
    },

    startWithTarget: function (target) {
        RepeatForever.superclass.startWithTarget.call(this, target);

        this.other.startWithTarget(this.target);
    },

    step: function (dt) {
        this.other.step(dt);
        if (this.other.get('isDone')) {
            var diff = dt - this.other.get('duration') - this.other.get('elapsed');
            this.other.startWithTarget(this.target);

            this.other.step(diff);
        }
    },

    get_isDone: function () {
        return false;
    },

    reverse: function () {
        return RepeatForever.create(this.other.reverse());
    },

    copy: function () {
        return RepeatForever.create(this.other.copy());
    }
});

var FiniteTimeAction = Action.extend(/** @lends cocos.actions.FiniteTimeAction# */{
    /**
     * Number of seconds to run the Action for
     * @type Float
     */
    duration: 2,

    /** 
     * Repeats an action a number of times. To repeat an action forever use the
     * cocos.RepeatForever action.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.Action
     */
    init: function () {
        FiniteTimeAction.superclass.init.call(this);
    },

    /** @ignore */
    reverse: function () {
        console.log('FiniteTimeAction.reverse() Override me');
    }
});

var Speed = Action.extend(/** @lends cocos.actions.Speed# */{
    other: null,
    
    /** 
     * speed of the inner function
     * @type Float
     */
    speed: 1.0,
    
    /** 
     * Changes the speed of an action, making it take longer (speed>1)
     * or less (speed<1) time.
     * Useful to simulate 'slow motion' or 'fast forward' effect.
     * @warning This action can't be Sequenceable because it is not an IntervalAction
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.Action
     */
    init: function(opts) {
        Speed.superclass.init.call(this, opts);
        
        this.other = opts.action;
        this.speed = opts.speed;
    },
    
    startWithTarget: function(target) {
        Speed.superclass.startWithTarget.call(this, target);
        this.other.startWithTarget(this.target);
    },
    
    setSpeed: function(speed) {
        this.speed = speed;
    },
    
    stop: function() {
        this.other.stop();
        Speed.superclass.stop.call(this);
    },
    
    step: function(dt) {
        this.other.step(dt * this.speed);
    },
    
    get_isDone: function() {
        return this.other.get_isDone();
    },
    
    copy: function() {
        return Speed.create({action: this.other.copy(), speed: this.speed});
    },
    
    reverse: function() {
        return Speed.create({action: this.other.reverse(), speed: this.speed});
    }
});

var Follow = Action.extend(/** @lends cocos.actions.Follow# */{
    /**
     * node to follow
     */
    followedNode: null,
    
    /**
     * whether camera should be limited to certain area
     * @type {Boolean}
     */
    boundarySet: false,
    
    /**
     * if screensize is bigger than the boundary - update not needed 
     * @type {Boolean}
     */
    boundaryFullyCovered: false,
    
    /**
     * fast access to the screen dimensions 
     * @type {geometry.Point}
     */
    halfScreenSize: null,
    fullScreenSize: null,
    
    /**
     * world boundaries
     * @type {Float}
     */
    leftBoundary: 0,
    rightBoundary: 0,
    topBoundary: 0,
    bottomBoundary: 0,
    
    /** 
     * @class Follow an action that "follows" a node.
     *
     * Eg:
     * layer.runAction(cocos.actions.Follow.create({target: hero}))
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.Action
     *
     * @opt {cocos.nodes.Node} target
     * @opt {geometry.Rect} worldBoundary
     */
    init: function(opts) {
        Follow.superclass.init.call(this, opts);
        
        this.followedNode = opts.target;
        
        var s = require('../Director').Director.get('sharedDirector').get('winSize');
        this.fullScreenSize = geo.ccp(s.width, s.height);
        this.halfScreenSize = geo.ccpMult(this.fullScreenSize, geo.ccp(0.5, 0.5));
        
        if (opts.worldBoundary !== undefined) {
            this.boundarySet = true;
            this.leftBoundary = -((opts.worldBoundary.origin.x + opts.worldBoundary.size.width) - this.fullScreenSize.x);
            this.rightBoundary = -opts.worldBoundary.origin.x;
            this.topBoundary = -opts.worldBoundary.origin.y;
            this.bottomBoundary = -((opts.worldBoundary.origin.y+opts.worldBoundary.size.height) - this.fullScreenSize.y);
            
            if (this.rightBoundary < this.leftBoundary) {
                // screen width is larger than world's boundary width
                //set both in the middle of the world
                this.rightBoundary = this.leftBoundary = (this.leftBoundary + this.rightBoundary) / 2;
            }
            if (this.topBoundary < this.bottomBoundary)
            {
                // screen width is larger than world's boundary width
                //set both in the middle of the world
                this.topBoundary = this.bottomBoundary = (this.topBoundary + this.bottomBoundary) / 2;
            }
            if ((this.topBoundary == this.bottomBoundary) && (this.leftBoundary == this.rightBoundary)) {
                this.boundaryFullyCovered = true;
            }
        }
    },
    
    step: function(dt) {
        if (this.boundarySet) {
            // whole map fits inside a single screen, no need to modify the position - unless map boundaries are increased
            if (this.boundaryFullyCovered) {
                return;
            }
            var tempPos = geo.ccpSub(this.halfScreenSize, this.followedNode.get('position'));
            this.target.set('position', ccp(
                Math.min(Math.max(tempPos.x, this.leftBoundary), this.rightBoundary),
                Math.min(Math.max(tempPos.y, this.bottomBoundary), this.topBoundary))
            );
        } else {
            this.target.set('position', geo.ccpSub(this.halfScreenSize, this.followedNode.get('position')));
        }
    },
    
    get_isDone: function() {
        return !this.followedNode.get('isRunning');
    }
});


exports.Action = Action;
exports.RepeatForever = RepeatForever;
exports.FiniteTimeAction = FiniteTimeAction;
exports.Speed = Speed;
exports.Follow = Follow;

}};
__resources__["/__builtin__/libs/cocos2d/actions/ActionEase.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    ActionInterval = require('./ActionInterval').ActionInterval,
    geo = require('geometry'),
    ccp = geo.ccp;

var ActionEase = ActionInterval.extend(/** @lends cocos.actions.ActionEase# */{
    other: null,
    
    /**
     * @class Base class for Easing actions
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {cocos.actions.ActionInterval} action
     */
    init: function(opts) {
        if (!opts.action) {
            throw "Ease: action argument must be non-nil";
        }
        ActionEase.superclass.init.call(this, {duration: opts.action.duration});
        
        this.other = opts.action;
    },
    
    startWithTarget: function(target) {
        ActionEase.superclass.startWithTarget.call(this, target);
        this.other.startWithTarget(this.target);
    },
    
    stop: function() {
        this.other.stop();
        ActionEase.superclass.stop.call(this);
    },
    /*
    update: function(t) {
        this.other.update(t);
    },
    */
    copy: function() {
        return ActionEase.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return ActionEase.create({action: this.other.reverse()});
    }
});

var EaseRate = ActionEase.extend(/** @lends cocos.actions.EaseRate# */{
    /**
     * rate value for the actions 
     * @type {Float} 
     */
    rate: 0,
    
    /**
    * @class Base class for Easing actions with rate parameter
    *
    * @memberOf cocos.actions
    * @constructs
    * @extends cocos.actions.ActionEase
    *
    * @opt {cocos.actions.ActionInterval} action
    * @opt {Float} rate
    */
    init: function(opts) {
        EaseRate.superclass.init.call(this, opts);

        this.rate = opts.rate;
    },
    
    copy: function() {
        return EaseRate.create({action: this.other.copy(), rate: this.rate});
    },
    
    reverse: function() {
        return EaseRate.create({action: this.other.reverse(), rate: 1 / this.rate});
    }
});

/**
 * @class EaseIn action with a rate
 */
var EaseIn = EaseRate.extend(/** @lends cocos.actions.EaseIn# */{
    update: function(t) {
        this.other.update(Math.pow(t, this.rate));
    },
    
    copy: function() {
        return EaseIn.create({action: this.other.copy(), rate: this.rate});
    },
    
    reverse: function() {
        return EaseIn.create({action: this.other.reverse(), rate: 1 / this.rate});
    }
});

/**
 * @class EaseOut action with a rate
 */
var EaseOut = EaseRate.extend(/** @lends cocos.actions.EaseOut# */{
    update: function(t) {
        this.other.update(Math.pow(t, 1/this.rate));
    },
    
    copy: function() {
        return EaseOut.create({action: this.other.copy(), rate: this.rate});
    },
    
    reverse: function() {
        return EaseOut.create({action: this.other.reverse(), rate: 1 / this.rate});
    }
});

/**
 * @class EaseInOut action with a rate
 */
var EaseInOut = EaseRate.extend(/** @lends cocos.actions.EaseInOut# */{
    update: function(t) {
        var sign = 1;
        var r = Math.floor(this.rate);
        if (r % 2 == 0) {
            sign = -1;
        }
        t *= 2;
        if (t < 1) {
            this.other.update(0.5 * Math.pow(t, this.rate));
        } else {
            this.other.update(sign * 0.5 * (Math.pow(t-2, this.rate) + sign * 2));
        }
    },
    
    copy: function() {
        return EaseInOut.create({action: this.other.copy(), rate: this.rate});
    },
    
    reverse: function() {
        return EaseInOut.create({action: this.other.reverse(), rate: this.rate});
    }
});

/**
 * @class EaseExponentialIn action
 */
var EaseExponentialIn = ActionEase.extend(/** @lends cocos.actions.EaseExponentialIn# */{
    update: function(t) {
        this.other.update((t == 0) ? 0 : (Math.pow(2, 10 * (t/1 - 1)) - 1 * 0.001));
    },
    
    copy: function() {
        return EaseExponentialIn.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return exports.EaseExponentialOut.create({action: this.other.reverse()});
    }
});

/**
 * @class EaseExponentialOut action
 */
var EaseExponentialOut = ActionEase.extend(/** @lends cocos.actions.EaseExponentialOut# */{
    update: function(t) {
        this.other.update((t == 1) ? 1 : (-Math.pow(2, -10 * t/1) + 1));
    },
    
    copy: function() {
        return EaseExponentialOut.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return exports.EaseExponentialIn.create({action: this.other.reverse()});
    }
});

/**
 * @class EaseExponentialInOut action
 */
var EaseExponentialInOut = ActionEase.extend(/** @lends cocos.actions.EaseExponentialInOut# */{
    update: function(t) {
        t /= 0.5;
        if (t < 1) {
            t = 0.5 * Math.pow(2, 10 * (t - 1));
        } else {
            t = 0.5 * (-Math.pow(2, -10 * (t - 1)) + 2);
        }
        this.other.update(t);
    },
    
    copy: function() {
        return EaseExponentialInOut.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return EaseExponentialInOut.create({action: this.other.reverse()});
    }
});

/**
 * @class EaseSineIn action
 */
var EaseSineIn = ActionEase.extend(/** @lends cocos.actions.EaseSineIn# */{
    update: function(t) {
        this.other.update(-1 * Math.cos(t * Math.PI_2) + 1);
    },
    
    copy: function() {
        return EaseSineIn.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return exports.EaseSineOut.create({action: this.other.reverse()});
    }
});

/**
 * @class EaseSineOut action
 */
var EaseSineOut = ActionEase.extend(/** @lends cocos.actions.EaseSineOut# */{
    update: function(t) {
        this.other.update(Math.sin(t * Math.PI_2));
    },
    
    copy: function() {
        return EaseSineOut.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return exports.EaseSineIn.create({action: this.other.reverse()});
    }
});

/**
 * @class EaseSineInOut action
 */
var EaseSineInOut = ActionEase.extend(/** @lends cocos.actions.EaseSineInOut# */{
    update: function(t) {
        this.other.update(-0.5 * (Math.cos(t * Math.PI) - 1));
    },
    
    copy: function() {
        return EaseSineInOut.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return EaseSineInOut.create({action: this.other.reverse()});
    }
});

var EaseElastic = ActionEase.extend(/** @lends cocos.actions.EaseElastic# */{
    /**
    * period of the wave in radians. default is 0.3
    * @type {Float}
    */
    period: 0.3,

    /**
    * @class EaseElastic Ease Elastic abstract class
    *
    * @memberOf cocos.actions
    * @constructs
    * @extends cocos.actions.ActionEase
    *
    * @opt {cocos.actions.ActionInterval} action
    * @opt {Float} period
    */
    init: function(opts) {
        EaseElastic.superclass.init.call(this, {action: opts.action});

        if (opts.period !== undefined) {
            this.period = opts.period;
        }
    },

    copy: function() {
        return EaseElastic.create({action: this.other.copy(), period: this.period});
    },

    reverse: function() {
        window.console.warn("EaseElastic reverse(): Override me");
        return null;
    }
});

var EaseElasticIn = EaseElastic.extend(/** @lends cocos.actions.EaseElasticIn# */{
    /** 
     * @class EaseElasticIn Ease Elastic In action
     */
    update: function(t) {
        var newT = 0;
        if (t == 0 || t == 1) {
            newT = t;
        } else {
            var s = this.period / 4;
            t -= 1;
            newT = -Math.pow(2, 10 * t) * Math.sin((t - s) * Math.PI*2 / this.period);
        }
        this.other.update(newT);
    },
    
    // Wish we could use base class's copy
    copy: function() {
        return EaseElasticIn.create({action: this.other.copy(), period: this.period});
    },
    
    reverse: function() {
        return exports.EaseElasticOut.create({action: this.other.reverse(), period: this.period});
    }
});

var EaseElasticOut = EaseElastic.extend(/** @lends cocos.actions.EaseElasticOut# */{
    /** 
     * @class EaseElasticOut Ease Elastic Out action
     */
    update: function(t) {
        var newT = 0;
        if (t == 0 || t == 1) {
            newT = t;
        } else {
            var s = this.period / 4;
            newT = Math.pow(2, -10 * t) * Math.sin((t - s) * Math.PI*2 / this.period) + 1;
        }
        this.other.update(newT);
    },
    
    copy: function() {
        return EaseElasticOut.create({action: this.other.copy(), period: this.period});
    },
    
    reverse: function() {
        return exports.EaseElasticIn.create({action: this.other.reverse(), period: this.period});
    }
});

var EaseElasticInOut = EaseElastic.extend(/** @lends cocos.actions.EaseElasticInOut# */{
    /** 
     * @class EaseElasticInOut Ease Elastic InOut action
     */
    update: function(t) {
        var newT = 0;
        if (t == 0 || t == 1) {
            newT = t;
        } else {
            t *= 2;
            if (this.period == 0) {
                this.period = 0.3 * 1.5;
            }
            var s = this.period / 4;
            
            t -= 1;
            if (t < 0) {
                newT = -0.5 * Math.pow(2, 10 * t) * Math.sin((t - s) * Math.PI*2 / this.period);
            } else {
                newT = Math.pow(2, -10 * t) * Math.sin((t - s) * Math.PI*2 / this.period) * 0.5 + 1;
            }
        }
        this.other.update(newT);
    },
    
    copy: function() {
        return EaseElasticInOut.create({action: this.other.copy(), period: this.period});
    },
    
    reverse: function() {
        return EaseElasticInOut.create({action: this.other.reverse(), period: this.period});
    }
});

var EaseBounce = ActionEase.extend(/** @lends cocos.actions.EaseBounce# */{
    /** 
     * @class EaseBounce abstract class
     */
    bounceTime: function(t) {
        // Direct cut & paste from CCActionEase.m, obviously.
        // Glad someone else figured out all this math...
        if (t < 1 / 2.75) {
            return 7.5625 * t * t;
        }
        else if (t < 2 / 2.75) {
            t -= 1.5 / 2.75;
            return 7.5625 * t * t + 0.75;
        }
        else if (t < 2.5 / 2.75) {
            t -= 2.25 / 2.75;
            return 7.5625 * t * t + 0.9375;
        }

        t -= 2.625 / 2.75;
        return 7.5625 * t * t + 0.984375;
    }
});

var EaseBounceIn = EaseBounce.extend(/** @lends cocos.actions.EaseBounceIn# */{
    /** 
     * @class EaseBounceIn EaseBounceIn action
     */
    update: function(t) {
        var newT = 1 - this.bounceTime(1-t);
        this.other.update(newT);
    },
    
    copy: function() {
        return EaseBounceIn.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return exports.EaseBounceOut.create({action: this.other.reverse()});
    }
});

var EaseBounceOut = EaseBounce.extend(/** @lends cocos.actions.EaseBounceOut# */{
    /** 
     * @class EaseBounceOut EaseBounceOut action
     */
    update: function(t) {
        var newT = this.bounceTime(t);
        this.other.update(newT);
    },
    
    copy: function() {
        return EaseBounceOut.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return exports.EaseBounceIn.create({action: this.other.reverse()});
    }
});

var EaseBounceInOut = EaseBounce.extend(/** @lends cocos.actions.EaseBounceInOut# */{
    /** 
     * @class EaseBounceInOut EaseBounceInOut action
     */
    update: function(t) {
        var newT = 0;
        if (t < 0.5) {
            t *= 2;
            newT = (1 - this.bounceTime(1 - t)) * 0.5;
        } else {
            newT = this.bounceTime(t * 2 - 1) * 0.5 + 0.5;
        }
        this.other.update(newT);
    },
    
    copy: function() {
        return EaseBounceInOut.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return EaseBounceInOut.create({action: this.other.reverse()});
    }
});

var EaseBackIn = ActionEase.extend(/** @lends cocos.actions.EaseBackIn# */{
    /** 
     * @class EaseBackIn EaseBackIn action
     */
    update: function(t) {
        var overshoot = 1.70158;
        this.other.update(t * t * ((overshoot + 1) * t - overshoot));
    },
    
    copy: function() {
        return EaseBackIn.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return exports.EaseBackOut.create({action: this.other.reverse()});
    }
});

var EaseBackOut = ActionEase.extend(/** @lends cocos.actions.EaseBackOut# */{
    /** 
     * @class EaseBackOut EaseBackOut action
     */
    update: function(t) {
        var overshoot = 1.70158;
        t -= 1;
        this.other.update(t * t * ((overshoot + 1) * t + overshoot) + 1);
    },
    
    copy: function() {
        return EaseBackOut.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return exports.EaseBackIn.create({action: this.other.reverse()});
    }
});

var EaseBackInOut = ActionEase.extend(/** @lends cocos.actions.EaseBackInOut# */{
    /** 
     * @class EaseBackInOut EaseBackInOut action
     */
    update: function(t) {
        // Where do these constants come from?
        var overshoot = 1.70158 * 1.525;
        t *= 2;
        if (t < 1) {
            this.other.update((t * t * ((overshoot + 1) * t - overshoot)) / 2);
        } else {
            t -= 2;
            this.other.update((t * t * ((overshoot + 1) * t + overshoot)) / 2 + 1);
        }
    },
    
    copy: function() {
        return EaseBackInOut.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return EaseBackInOut.create({action: this.other.reverse()});
    }
});

exports.ActionEase = ActionEase;
exports.EaseRate = EaseRate;
exports.EaseIn = EaseIn;
exports.EaseOut = EaseOut;
exports.EaseInOut = EaseInOut;
exports.EaseExponentialIn = EaseExponentialIn;
exports.EaseExponentialOut = EaseExponentialOut;
exports.EaseExponentialInOut = EaseExponentialInOut;
exports.EaseSineIn = EaseSineIn;
exports.EaseSineOut = EaseSineOut;
exports.EaseSineInOut = EaseSineInOut;
exports.EaseElastic = EaseElastic;
exports.EaseElasticIn = EaseElasticIn;
exports.EaseElasticOut = EaseElasticOut;
exports.EaseElasticInOut = EaseElasticInOut;
exports.EaseBounce = EaseBounce;
exports.EaseBounceIn = EaseBounceIn;
exports.EaseBounceOut = EaseBounceOut;
exports.EaseBounceInOut = EaseBounceInOut;
exports.EaseBackIn = EaseBackIn;
exports.EaseBackOut = EaseBackOut;
exports.EaseBackInOut = EaseBackInOut;


}};
__resources__["/__builtin__/libs/cocos2d/actions/ActionInstant.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    act = require('./Action'),
    ccp = require('geometry').ccp;

var ActionInstant = act.FiniteTimeAction.extend(/** @lends cocos.actions.ActionInstant */{
    /**
     * @class Base class for actions that triggers instantly. They have no duration.
     *
     * @memberOf cocos.actions
     * @extends cocos.actions.FiniteTimeAction
     * @constructs
     */
    init: function (opts) {
        ActionInstant.superclass.init.call(this, opts);

        this.duration = 0;
    },
    
    get_isDone: function () {
        return true;
    },
    
    step: function (dt) {
        this.update(1);
    },
    
    update: function (t) {
        // ignore
    },
    
    copy: function() {
        return this;
    },
    
    reverse: function () {
        return this.copy();
    }
});

var Show = ActionInstant.extend(/** @lends cocos.actions.Show# */{
    /** 
    * @class Show Show the node
    **/
    startWithTarget: function(target) {
        Show.superclass.startWithTarget.call(this, target);
        this.target.set('visible', true);
    },

    copy: function() {
        return Show.create();
    },
    
    reverse: function() {
        return exports.Hide.create();
    }
});

var Hide = ActionInstant.extend(/** @lends cocos.actions.Hide# */{
    /** 
    * @class Hide Hide the node
    **/
    startWithTarget: function(target) {
        Show.superclass.startWithTarget.call(this, target);
        this.target.set('visible', false);
    },

    copy: function() {
        return Hide.create();
    },
    
    reverse: function() {
        return exports.Show.create();
    }
});

var ToggleVisibility = ActionInstant.extend(/** @lends cocos.actions.ToggleVisibility# */{
    /** 
    * @class ToggleVisibility Toggles the visibility of a node
    **/
    startWithTarget: function(target) {
        ToggleVisibility.superclass.startWithTarget.call(this, target);
        var vis = this.target.get('visible');
        this.target.set('visible', !vis);
    },
    
    copy: function() {
        return ToggleVisibility.create();
    }
});

var FlipX = ActionInstant.extend(/** @lends cocos.actions.FlipX# */{
    flipX: false,

    /**
     * @class FlipX Flips a sprite horizontally
     *
     * @memberOf cocos.actions
     * @extends cocos.actions.ActionInstant
     * @constructs
     *
     * @opt {Boolean} flipX Should the sprite be flipped
     */
    init: function (opts) {
        FlipX.superclass.init.call(this, opts);

        this.flipX = opts.flipX;
    },
    
    startWithTarget: function (target) {
        FlipX.superclass.startWithTarget.call(this, target);

        target.set('flipX', this.flipX);
    },
    
    reverse: function () {
        return FlipX.create({flipX: !this.flipX});
    },
    
    copy: function () {
        return FlipX.create({flipX: this.flipX});
    }
});

var FlipY = ActionInstant.extend(/** @lends cocos.actions.FlipY# */{
    flipY: false,

    /**
     * @class FlipY Flips a sprite vertically
     *
     * @memberOf cocos.actions
     * @extends cocos.actions.ActionInstant
     * @constructs
     *
     * @opt {Boolean} flipY Should the sprite be flipped
     */
    init: function (opts) {
        FlipY.superclass.init.call(this, opts);

        this.flipY = opts.flipY;
    },
    
    startWithTarget: function (target) {
        FlipY.superclass.startWithTarget.call(this, target);

        target.set('flipY', this.flipY);
    },
    
    reverse: function () {
        return FlipY.create({flipY: !this.flipY});
    },
    
    copy: function () {
        return FlipY.create({flipY: this.flipY});
    }
});

var Place = ActionInstant.extend(/** @lends cocos.actions.Place# */{
    position: null,
    
    /**
	 * @class Place Places the node in a certain position
	 *
     * @memberOf cocos.actions
     * @extends cocos.actions.ActionInstant
     * @constructs
     *
     * @opt {geometry.Point} position
     */
    init: function(opts) {
        Place.superclass.init.call(this, opts);
        this.set('position', util.copy(opts.position));
    },
    
    startWithTarget: function(target) {
        Place.superclass.startWithTarget.call(this, target);
        this.target.set('position', this.position);
    },
    
    copy: function() {
        return Place.create({position: this.position});
    }
});

var CallFunc = ActionInstant.extend(/** @lends cocos.actions.CallFunc# */{
	callback: null,
    target: null,
    method: null,
    
	/**
	 * @class CallFunc Calls a 'callback'
	 *
     * @memberOf cocos.actions
     * @extends cocos.actions.ActionInstant
     * @constructs
     *
     * @opt {BObject} target
     * @opt {String|Function} method
     */
	init: function(opts) {
		CallFunc.superclass.init.call(this, opts);
		
		// Save target & method so that copy() can recreate callback
		this.target = opts.target;
		this.method = opts.method;
		this.callback = util.callback(this.target, this.method);
	},
	
	startWithTarget: function(target) {
		CallFunc.superclass.startWithTarget.call(this, target);
		this.execute(target);
	},
	
	execute: function(target) {
	    // Pass target to callback
		this.callback.call(this, target);
	},
	
	copy: function() {
	    return CallFunc.create({target: this.target, method: this.method});
	}
});

exports.ActionInstant = ActionInstant;
exports.Show = Show;
exports.Hide = Hide;
exports.ToggleVisibility = ToggleVisibility;
exports.FlipX = FlipX;
exports.FlipY = FlipY;
exports.Place = Place;
exports.CallFunc = CallFunc;


}};
__resources__["/__builtin__/libs/cocos2d/actions/ActionInterval.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    act = require('./Action'),
    geo = require('geometry'),
    ccp = geo.ccp;


var ActionInterval = act.FiniteTimeAction.extend(/** @lends cocos.actions.ActionInterval# */{
    /**
     * Number of seconds that have elapsed
     * @type Float
     */
    elapsed: 0.0,

    _firstTick: true,

    /**
     * Base class actions that do have a finite time duration.
     *
     * Possible actions:
     *
     * - An action with a duration of 0 seconds
     * - An action with a duration of 35.5 seconds Infinite time actions are valid
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.FiniteTimeAction
     *
     * @opt {Float} duration Number of seconds to run action for
     */
    init: function (opts) {
        ActionInterval.superclass.init.call(this, opts);

        var dur = opts.duration || 0;
        if (dur === 0) {
            dur = 0.0000001;
        }

        this.set('duration', dur);
        this.set('elapsed', 0);
        this._firstTick = true;
    },

    get_isDone: function () {
        return (this.elapsed >= this.duration);
    },

    step: function (dt) {
        if (this._firstTick) {
            this._firstTick = false;
            this.elapsed = 0;
        } else {
            this.elapsed += dt;
        }

        this.update(Math.min(1, this.elapsed / this.duration));
    },

    startWithTarget: function (target) {
        ActionInterval.superclass.startWithTarget.call(this, target);

        this.elapsed = 0.0;
        this._firstTick = true;
    },

    copy: function() {
        throw "copy() not implemented";
    },
    
    reverse: function () {
        throw "Reverse Action not implemented";
    }
});

var DelayTime = ActionInterval.extend(/** @lends cocos.actions.DelayTime# */{
    /**
     * @class DelayTime Delays the action a certain amount of seconds
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     */
    update: function (t) {
        if (t === 1.0) {
            this.stop();
        }
    },

    copy: function () {
        return DelayTime.create({duration: this.get('duration')});
    },

    reverse: function () {
        return DelayTime.create({duration: this.get('duration')});
    }
});


var ScaleTo = ActionInterval.extend(/** @lends cocos.actions.ScaleTo# */{
    /**
     * Current X Scale
     * @type Float
     */
    scaleX: 1,

    /**
     * Current Y Scale
     * @type Float
     */
    scaleY: 1,

    /**
     * Initial X Scale
     * @type Float
     */
    startScaleX: 1,

    /**
     * Initial Y Scale
     * @type Float
     */
    startScaleY: 1,

    /**
     * Final X Scale
     * @type Float
     */
    endScaleX: 1,

    /**
     * Final Y Scale
     * @type Float
     */
    endScaleY: 1,

    /**
     * Delta X Scale
     * @type Float
     * @private
     */
    deltaX: 0.0,

    /**
     * Delta Y Scale
     * @type Float
     * @private
     */
    deltaY: 0.0,

    /**
     * @class ScaleTo Scales a cocos.Node object to a zoom factor by modifying it's scale attribute.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {Float} [scale] Size to scale Node to
     * @opt {Float} [scaleX] Size to scale width of Node to
     * @opt {Float} [scaleY] Size to scale height of Node to
     */
    init: function (opts) {
        ScaleTo.superclass.init.call(this, opts);

        if (opts.scale !== undefined) {
            this.endScaleX = this.endScaleY = opts.scale;
        } else {
            this.endScaleX = opts.scaleX;
            this.endScaleY = opts.scaleY;
        }


    },

    startWithTarget: function (target) {
        ScaleTo.superclass.startWithTarget.call(this, target);

        this.startScaleX = this.target.get('scaleX');
        this.startScaleY = this.target.get('scaleY');
        this.deltaX = this.endScaleX - this.startScaleX;
        this.deltaY = this.endScaleY - this.startScaleY;
    },

    update: function (t) {
        if (!this.target) {
            return;
        }

        this.target.set('scaleX', this.startScaleX + this.deltaX * t);
        this.target.set('scaleY', this.startScaleY + this.deltaY * t);
    },

    copy: function () {
        return ScaleTo.create({duration: this.get('duration'),
                                 scaleX: this.get('endScaleX'),
                                 scaleY: this.get('endScaleY')});
    }
});

var ScaleBy = ScaleTo.extend(/** @lends cocos.actions.ScaleBy# */{
    /**
     * @class ScaleBy Scales a cocos.Node object to a zoom factor by modifying it's scale attribute.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ScaleTo
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {Float} [scale] Size to scale Node by
     * @opt {Float} [scaleX] Size to scale width of Node by
     * @opt {Float} [scaleY] Size to scale height of Node by
     */
    init: function (opts) {
        ScaleBy.superclass.init.call(this, opts);
    },

    startWithTarget: function (target) {
        ScaleBy.superclass.startWithTarget.call(this, target);

        this.deltaX = this.startScaleX * this.endScaleX - this.startScaleX;
        this.deltaY = this.startScaleY * this.endScaleY - this.startScaleY;
    },

    reverse: function () {
        return ScaleBy.create({duration: this.get('duration'), scaleX: 1 / this.endScaleX, scaleY: 1 / this.endScaleY});
    }
});


var RotateTo = ActionInterval.extend(/** @lends cocos.actions.RotateTo# */{
    /**
     * Final angle
     * @type Float
     */
    dstAngle: 0,

    /**
     * Initial angle
     * @type Float
     */
    startAngle: 0,

    /**
     * Angle delta
     * @type Float
     */
    diffAngle: 0,

    /**
     * @class RotateTo Rotates a cocos.Node object to a certain angle by modifying its rotation
     * attribute. The direction will be decided by the shortest angle.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {Float} angle Angle in degrees to rotate to
     */
    init: function (opts) {
        RotateTo.superclass.init.call(this, opts);

        this.dstAngle = opts.angle;
    },

    startWithTarget: function (target) {
        RotateTo.superclass.startWithTarget.call(this, target);

        this.startAngle = target.get('rotation');

        if (this.startAngle > 0) {
            this.startAngle = (this.startAngle % 360);
        } else {
            this.startAngle = (this.startAngle % -360);
        }

        this.diffAngle = this.dstAngle - this.startAngle;
        if (this.diffAngle > 180) {
            this.diffAngle -= 360;
        } else if (this.diffAngle < -180) {
            this.diffAngle += 360;
        }
    },

    update: function (t) {
        this.target.set('rotation', this.startAngle + this.diffAngle * t);
    },

    copy: function () {
        return RotateTo.create({duration: this.get('duration'), angle: this.get('dstAngle')});
    }
});

var RotateBy = RotateTo.extend(/** @lends cocos.actions.RotateBy# */{
    /**
     * Number of degrees to rotate by
     * @type Float
     */
    angle: 0,

    /**
     * @class RotateBy Rotates a cocos.Node object to a certain angle by modifying its rotation
     * attribute. The direction will be decided by the shortest angle.
     *
     * @memberOf cocos.action
     * @constructs
     * @extends cocos.actions.RotateTo
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {Float} angle Angle in degrees to rotate by
     */
    init: function (opts) {
        RotateBy.superclass.init.call(this, opts);

        this.angle = opts.angle;
    },

    startWithTarget: function (target) {
        RotateBy.superclass.startWithTarget.call(this, target);

        this.startAngle = this.target.get('rotation');
    },

    update: function (t) {
        this.target.set('rotation', this.startAngle + this.angle * t);
    },

    copy: function () {
        return RotateBy.create({duration: this.get('duration'), angle: this.angle});
    },
    
    reverse: function () {
        return RotateBy.create({duration: this.get('duration'), angle: -this.angle});
    }
});

var MoveTo = ActionInterval.extend(/** @lends cocos.actions.MoveTo# */{
    delta: null,
    startPosition: null,
    endPosition: null,

    /**
     * @class MoveTo Animates moving a cocos.nodes.Node object to a another point.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {geometry.Point} position Destination position
     */
    init: function (opts) {
        MoveTo.superclass.init.call(this, opts);

        this.set('endPosition', util.copy(opts.position));
    },

    startWithTarget: function (target) {
        MoveTo.superclass.startWithTarget.call(this, target);

        this.set('startPosition', util.copy(target.get('position')));
        this.set('delta', geo.ccpSub(this.get('endPosition'), this.get('startPosition')));
    },

    update: function (t) {
        var startPosition = this.get('startPosition'),
            delta = this.get('delta');
        this.target.set('position', ccp(startPosition.x + delta.x * t, startPosition.y + delta.y * t));
    },
    
    copy: function() {
        return MoveTo.create({duration: this.get('duration'), position: this.get('endPosition')});
    }
});

var MoveBy = MoveTo.extend(/** @lends cocos.actions.MoveBy# */{
    /**
     * @class MoveBy Animates moving a cocos.node.Node object by a given number of pixels
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.MoveTo
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {geometry.Point} position Number of pixels to move by
     */
    init: function (opts) {
        MoveBy.superclass.init.call(this, opts);

        this.set('delta', util.copy(opts.position));
    },

    startWithTarget: function (target) {
        var dTmp = this.get('delta');
        MoveBy.superclass.startWithTarget.call(this, target);
        this.set('delta', dTmp);
    },
    
    copy: function() {
         return MoveBy.create({duration: this.get('duration'), position: this.get('delta')});
    },
    
    reverse: function() {
        var delta = this.get('delta');
        return MoveBy.create({duration: this.get('duration'), position: geo.ccp(-delta.x, -delta.y)});
    }
});

var JumpBy = ActionInterval.extend(/** @lends cocos.actions.JumpBy# */{
    /**
     * Number of pixels to jump by
     * @type geometry.Point
     */
    delta: null,
    
    /**
     * Height of jump
     * @type Float
     */
    height: 0,
    
    /**
     * Number of times to jump
     * @type Integer
     */
    jumps: 0,
    
    /**
     * Starting point
     * @type geometry.Point
     */
    startPosition: null,
    
    /**
     * @class JumpBy Moves a CCNode object simulating a parabolic jump movement by modifying it's position attribute.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {geometry.Point} startPosition Point at which jump starts
     * @opt {geometry.Point} delta Number of pixels to jump by
     * @opt {Float} height Height of jump
     * @opt {Int} jumps Number of times to repeat
     */
    init: function(opts) {
        JumpBy.superclass.init.call(this, opts);
        
        this.delta  = util.copy(opts.delta);
        this.height = opts.height;
        this.jumps  = opts.jumps;
    },
    
    copy: function() {
        return JumpBy.create({duration: this.duration, 
                                 delta: this.delta,
                                height: this.height,
                                 jumps: this.jumps});
    },
    
    startWithTarget: function(target) {
        JumpBy.superclass.startWithTarget.call(this, target);
        this.set('startPosition', target.get('position'));
    },
    
    update: function(t) {
        // parabolic jump
        var frac = (t * this.jumps) % 1.0;
        var y = this.height * 4 * frac * (1 - frac);
        y += this.delta.y * t;
        var x = this.delta.x * t;
        this.target.set('position', geo.ccp(this.startPosition.x + x, this.startPosition.y + y));
    },
    
    reverse: function() {
        return JumpBy.create({duration: this.duration,
                                 delta: geo.ccp(-this.delta.x, -this.delta.y),
                                height: this.height,
                                 jumps: this.jumps});
    }
});

var JumpTo = JumpBy.extend(/** @lends cocos.actions.JumpTo# */{
    /**
     * @class JumpTo Moves a Node object to a parabolic position simulating a jump 
     * movement by modifying it's position attribute.
     *
     * @memberOf cocos.actions
     * @extends cocos.actions.JumpBy
     */
    startWithTarget: function(target) {
        JumpTo.superclass.startWithTarget.call(this, target);
        this.delta = geo.ccp(this.delta.x - this.startPosition.x, this.delta.y - this.startPosition.y);
    }
});

var BezierBy = ActionInterval.extend(/** @lends cocos.actions.BezierBy# */{
    /**
     * @type {geometry.BezierConfig}
     */
    config: null,
    
    startPosition: null,
    
    /**
     * @class BezierBy An action that moves the target with a cubic Bezier curve by a certain distance.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opts {geometry.BezierConfig} bezier Bezier control points object
     * @opts {Float} duration
     */
    init: function(opts) {
        BezierBy.superclass.init.call(this, opts);
        
        this.config = util.copy(opts.bezier);
    },
    
    startWithTarget: function(target) {
        BezierBy.superclass.startWithTarget.call(this, target);
        this.set('startPosition', this.target.get('position'));
    },
    
    update: function(t) {
        var c = this.get('config');
        var xa = 0,
            xb = c.controlPoint1.x,
            xc = c.controlPoint2.x,
            xd = c.endPosition.x,
            ya = 0,
            yb = c.controlPoint1.y,
            yc = c.controlPoint2.y,
            yd = c.endPosition.y;
        
        var x = BezierBy.bezierat(xa, xb, xc, xd, t);
        var y = BezierBy.bezierat(ya, yb, yc, yd, t);
        
        this.target.set('position', geo.ccpAdd(this.get('startPosition'), geo.ccp(x, y)));
    },
    
    copy: function() {
        return BezierBy.create({bezier: this.get('config'), duration: this.get('duration')});
    },
    
    reverse: function() {
        var c = this.get('config'),
            bc = new geo.BezierConfig();
            
        bc.endPosition = geo.ccpNeg(c.endPosition);
        bc.controlPoint1 = geo.ccpAdd(c.controlPoint2, geo.ccpNeg(c.endPosition));
        bc.controlPoint2 = geo.ccpAdd(c.controlPoint1, geo.ccpNeg(c.endPosition));
        
        return BezierBy.create({bezier: bc, duration: this.get('duration')});
    }
});

util.extend(BezierBy, {
    /**
     * Bezier cubic formula
     * ((1 - t) + t)3 = 1 
     */
    bezierat: function(a, b, c, d, t) {
       return Math.pow(1-t, 3) * a + 
            3 * t * Math.pow(1-t, 2) * b +
            3 * Math.pow(t, 2) * (1 - t) * c +
            Math.pow(t, 3) * d;
    }
});

var BezierTo = BezierBy.extend(/** @lends cocos.actions.BezierTo# */{
    /**
     * @class BezierTo An action that moves the target with a cubic Bezier curve to a destination point.
     *
     * @memberOf cocos.actions
     * @extends cocos.actions.BezierBy
     */
    startWithTarget: function(target) {
        BezierTo.superclass.startWithTarget.call(this, target);
        
        var c = this.get('config');
        c.controlPoint1 = geo.ccpSub(c.controlPoint1, this.get('startPosition'));
        c.controlPoint2 = geo.ccpSub(c.controlPoint2, this.get('startPosition'));
        c.endPosition = geo.ccpSub(c.endPosition, this.get('startPosition'));
    }
});

var Blink = ActionInterval.extend(/** @lends cocos.actions.Blink# */{
    /**
     * @type {Integer}
     */
    times: 1,
    
    /**
     * @class Blink Blinks a Node object by modifying it's visible attribute
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opts {Integer} blinks Number of times to blink
     * @opts {Float} duration
     */
    init: function(opts) {
        Blink.superclass.init.call(this, opts);
        this.times = opts.blinks;
    },
    
    update: function(t) {
        if (! this.get_isDone()) {
            var slice = 1 / this.times;
            var m = t % slice;
            this.target.set('visible', (m > slice/2));
        }
    },
    
    copy: function() {
        return Blink.create({duration: this.get('duration'), blinks: this.get('times')});
    },
    
    reverse: function() {
        return this.copy();
    }
});

var FadeOut = ActionInterval.extend(/** @lends cocos.actions.FadeOut# */{
   /**
    * @class FadeOut Fades out a cocos.nodes.Node to zero opacity
    *
    * @memberOf cocos.actions
    * @extends cocos.actions.ActionInterval
    */     
    update: function (t) {
        var target = this.get('target');
        if (!target) return;
        target.set('opacity', 255 - (255 * t));
    },

    copy: function () {
        return FadeOut.create({duration: this.get('duration')});
    },
    
    reverse: function () {
        return exports.FadeIn.create({duration: this.get('duration')});
    }
});


var FadeIn = ActionInterval.extend(/** @lends cocos.actions.FadeIn# */{
    /**
     * @class FadeIn Fades in a cocos.nodes.Node to 100% opacity
     *
     * @memberOf cocos.actions
     * @extends cocos.actions.ActionInterval
     */
    update: function (t) {
        var target = this.get('target');
        if (!target) return;
        target.set('opacity', t * 255);
    },

    copy: function () {
        return FadeIn.create({duration: this.get('duration')});
    },
    
    reverse: function () {
        return exports.FadeOut.create({duration: this.get('duration')});
    }
});

var FadeTo = ActionInterval.extend(/** @lends cocos.actions.FadeTo# */{
    /**
     * The final opacity
     * @type Float
     */
    toOpacity: null,

    /**
     * The initial opacity
     * @type Float
     */
    fromOpacity: null,

    /**
     * @class FadeTo Fades a cocos.nodes.Node to a given opacity
     *
     * @memberOf cocos.actions
     * @constructor
     * @extends cocos.actions.ActionInterval
     */
    init: function (opts) {
        FadeTo.superclass.init.call(this, opts);
        this.set('toOpacity', opts.toOpacity);
    },

    startWithTarget: function (target) {
        FadeTo.superclass.startWithTarget.call(this, target);
        this.set('fromOpacity', this.target.get('opacity'));
    },

    update: function (t) {
        var target = this.get('target');
        if (!target) return;

        target.set('opacity', this.fromOpacity + ( this.toOpacity - this.fromOpacity ) * t);
    },
    
    copy: function() {
        return FadeTo.create({duration: this.get('duration'), toOpacity: this.get('toOpacity')});
    }
});

var Sequence = ActionInterval.extend(/** @lends cocos.actions.Sequence# */{
    /**
     * Array of actions to run
     * @type cocos.nodes.Node[]
     */
    actions: null,

    split: 0,
    last: 0,
    
    /**
     * Runs a pair of actions sequentially, one after another
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {cocos.actions.FiniteTimeAction} one 1st action to run
     * @opt {cocos.actions.FiniteTimeAction} two 2nd action to run
     */
    init: function (opts) {
        if (!opts.one) {
            throw "Sequence argument one must be non-nil";
        }
        if (!opts.two) {
            throw "Sequence argument two must be non-nil";
        }
        this.actions = [];
        
        var d = opts.one.get('duration') + opts.two.get('duration');
        
        Sequence.superclass.init.call(this, {duration: d});
        
        this.actions[0] = opts.one;
        this.actions[1] = opts.two;
    },
    
    startWithTarget: function (target) {
        Sequence.superclass.startWithTarget.call(this, target);
        this.split = this.actions[0].get('duration') / this.get('duration');
        this.last = -1;
    },

    stop: function () {
        this.actions[0].stop();
        this.actions[1].stop();
        Sequence.superclass.stop.call(this);
    },

    update: function (t) {
        // This is confusing but will hopefully work better in conjunction
        // with modifer actions like Repeat & Spawn...
        var found = 0;
        var new_t = 0;
        
        if (t >= this.split) {
            found = 1;
            if (this.split == 1) {
                new_t = 1;
            } else {
                new_t = (t - this.split) / (1 - this.split);
            }
        } else {
            found = 0;
            if (this.split != 0) {
                new_t = t / this.split;
            } else {
                new_t = 1;
            }
        }
        if (this.last == -1 && found == 1) {
            this.actions[0].startWithTarget(this.target);
            this.actions[0].update(1);
            this.actions[0].stop();
        }
        if (this.last != found) {
            if (this.last != -1) {
                this.actions[this.last].update(1);
                this.actions[this.last].stop();
            }
            this.actions[found].startWithTarget(this.target);
        }
        this.actions[found].update(new_t);
        this.last = found;
    },

    copy: function () {
        // Constructor will copy actions 
        return Sequence.create({actions: this.get('actions')});
    },

    reverse: function() {
        return Sequence.create({actions: [this.actions[1].reverse(), this.actions[0].reverse()]});
    }
});

util.extend(Sequence, {
    /** 
     * Override BObject.create in order to implement recursive construction
     * of actions array
     */
    create: function() {
        // Don't copy actions array, copy the actions
        var actions = arguments[0].actions;
        var prev = actions[0].copy();
        
        // Recursively create Sequence with pair of actions
        for (var i=1; i<actions.length; i++) {
            var now = actions[i].copy();
            if (now) {
                prev = this.initFromPair(prev, now);
            } else {
                break;
            }
        }
        return prev;
    },
    
    /** 
     * Create sequence object from a pair of actions
     */
    initFromPair: function(a1, a2) {
        var ret = new this();
        ret.init.apply(ret, [{one: a1, two: a2}]);
        return ret;
    }
});

var Repeat = ActionInterval.extend(/** @lends cocos.actions.Repeat# */{
    times: 1,
    total: 0,
    other: null,
    
    /**
     * @class Repeat Repeats an action a number of times.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {cocos.actions.FiniteTimeAction} action Action to repeat
     * @opt {Number} times Number of times to repeat
     */
     init: function(opts) {
         var d = opts.action.get('duration') * opts.times;

         Repeat.superclass.init.call(this, {duration: d});
         
         this.times = opts.times;
         this.other = opts.action.copy();
         this.total = 0;
     },
     
     startWithTarget: function(target) {
         this.total = 0;
         Repeat.superclass.startWithTarget.call(this, target);
         this.other.startWithTarget(target);
     },
     
     stop: function() {
         this.other.stop();
         Repeat.superclass.stop.call(this);
     },
     
     update: function(dt) {
         var t = dt * this.times;
         
         if (t > (this.total+1)) {
             this.other.update(1);
             this.total += 1;
             this.other.stop();
             this.other.startWithTarget(this.target);
             
             // If repeat is over
             if (this.total == this.times) {
                 // set it in the original position
                 this.other.update(0);
             } else {
                 // otherwise start next repeat
                 this.other.update(t - this.total);
             }
         } else {
             var r = t % 1.0;
             
             // fix last repeat position otherwise it could be 0
             if (dt == 1) {
                 r = 1;
                 this.total += 1;
             }
             this.other.update(Math.min(r, 1));
         }
     },
     
     get_isDone: function() {
         return this.total == this.times;
     },
     
     copy: function() {
         // Constructor copies action
         return Repeat.create({action: this.other, times: this.times});
     },
     
     reverse: function() {
         return Repeat.create({action: this.other.reverse(), times: this.times});
     }
});

var Spawn = ActionInterval.extend(/** @lends cocos.actions.Spawn# */{
    one: null,
    two: null,

    /**
     * @class Spawn Executes multiple actions simultaneously
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {cocos.actions.FiniteTimeAction} one: first action to spawn
     * @opt {cocos.actions.FiniteTimeAction} two: second action to spawn
     */
    init: function (opts) {
        var action1 = opts.one, 
            action2 = opts.two;
            
        if (!action1 || !action2) {
            throw "cocos.actions.Spawn: required actions missing";
        }
        var d1 = action1.get('duration'), 
            d2 = action2.get('duration');
        
        Spawn.superclass.init.call(this, {duration: Math.max(d1, d2)});
        
        this.set('one', action1);
        this.set('two', action2);
        
        if (d1 > d2) {
            this.set('two', Sequence.create({actions: [
                action2, 
                DelayTime.create({duration: d1-d2})
            ]}));
        } else if (d1 < d2) {
            this.set('one', Sequence.create({actions: [
                action1,
                DelayTime.create({duration: d2-d1})
            ]}));
        }
    },
    
    startWithTarget: function (target) {
        Spawn.superclass.startWithTarget.call(this, target);
        this.get('one').startWithTarget(this.target);
        this.get('two').startWithTarget(this.target);
    },
    
    stop: function () {
        this.get('one').stop();
        this.get('two').stop();
        Spawn.superclass.stop.call(this);
    },
    
    step: function (dt) {
        if (this._firstTick) {
            this._firstTick = false;
            this.elapsed = 0;
        } else {
            this.elapsed += dt;
        }
        this.get('one').step(dt);
        this.get('two').step(dt);
    },
    
    update: function (t) {
        this.get('one').update(t);
        this.get('two').update(t);
    },
    
    copy: function () {
        return Spawn.create({one: this.get('one').copy(), two: this.get('two').copy()});
    },
    
    reverse: function () {
        return Spawn.create({one: this.get('one').reverse(), two: this.get('two').reverse()});
    }
});

util.extend(Spawn, {
    /**
     * Helper class function to create Spawn object from array of actions
     *
     * @opt {Array} actions: list of actions to run simultaneously
     */
    initWithActions: function (opts) {
        var now, prev = opts.actions.shift();
        while (opts.actions.length > 0) {
            now = opts.actions.shift();
            if (now) {
                prev = this.create({one: prev, two: now});
            } else {
                break;
            }
        }
        return prev;
    }
});

var Animate = ActionInterval.extend(/** @lends cocos.actions.Animate# */{
    animation: null,
    restoreOriginalFrame: true,
    origFrame: null,


    /**
     * Animates a sprite given the name of an Animation
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {cocos.Animation} animation Animation to run
     * @opt {Boolean} [restoreOriginalFrame=true] Return to first frame when finished
     */
    init: function (opts) {
        this.animation = opts.animation;
        this.restoreOriginalFrame = opts.restoreOriginalFrame !== false;
        opts.duration = this.animation.frames.length * this.animation.delay;

        Animate.superclass.init.call(this, opts);
    },

    startWithTarget: function (target) {
        Animate.superclass.startWithTarget.call(this, target);

        if (this.restoreOriginalFrame) {
            this.set('origFrame', this.target.get('displayedFrame'));
        }
    },

    stop: function () {
        if (this.target && this.restoreOriginalFrame) {
            var sprite = this.target;
            sprite.set('displayFrame', this.origFrame);
        }

        Animate.superclass.stop.call(this);
    },

    update: function (t) {
        var frames = this.animation.get('frames'),
            numberOfFrames = frames.length,
            idx = Math.floor(t * numberOfFrames);

        if (idx >= numberOfFrames) {
            idx = numberOfFrames - 1;
        }

        var sprite = this.target;
        if (!sprite.isFrameDisplayed(frames[idx])) {
            sprite.set('displayFrame', frames[idx]);
        }
    },

    copy: function () {
        return Animate.create({animation: this.animation, restoreOriginalFrame: this.restoreOriginalFrame});
    }

});

exports.ActionInterval = ActionInterval;
exports.DelayTime = DelayTime;
exports.ScaleTo = ScaleTo;
exports.ScaleBy = ScaleBy;
exports.RotateTo = RotateTo;
exports.RotateBy = RotateBy;
exports.MoveTo = MoveTo;
exports.MoveBy = MoveBy;
exports.JumpBy = JumpBy;
exports.JumpTo = JumpTo;
exports.BezierBy = BezierBy;
exports.BezierTo = BezierTo;
exports.Blink = Blink;
exports.FadeIn = FadeIn;
exports.FadeOut = FadeOut;
exports.FadeTo = FadeTo;
exports.Spawn = Spawn;
exports.Sequence = Sequence;
exports.Repeat = Repeat;
exports.Animate = Animate;

}};
__resources__["/__builtin__/libs/cocos2d/actions/index.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    path = require('path');

var modules = 'Action ActionInterval ActionInstant ActionEase'.w();

/**
 * @memberOf cocos
 * @namespace Actions used to animate or change a Node
 */
var actions = {};

util.each(modules, function (mod, i) {
    util.extend(actions, require('./' + mod));
});

module.exports = actions;

}};
__resources__["/__builtin__/libs/cocos2d/Animation.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util');

var Animation = BObject.extend(/** @lends cocos.Animation# */{
    name: null,
    delay: 0.0,
    frames: null,

    /** 
     * A cocos.Animation object is used to perform animations on the Sprite objects.
     * 
     * The Animation object contains cocos.SpriteFrame objects, and a possible delay between the frames.
     * You can animate a cocos.Animation object by using the cocos.actions.Animate action.
     * 
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @opt {cocos.SpriteFrame[]} frames Frames to animate
     * @opt {Float} [delay=0.0] Delay between each frame
     * 
     * @example
     * var animation = cocos.Animation.create({frames: [f1, f2, f3], delay: 0.1});
     * sprite.runAction(cocos.actions.Animate.create({animation: animation}));
     */
    init: function (opts) {
        Animation.superclass.init.call(this, opts);

        this.frames = opts.frames || [];
        this.delay  = opts.delay  || 0.0;
    }
});

exports.Animation = Animation;

}};
__resources__["/__builtin__/libs/cocos2d/AnimationCache.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    Plist = require('Plist').Plist;

var AnimationCache = BObject.extend(/** @lends cocos.AnimationCache# */{
    /**
     * Cached animations
     * @type Object
     */
    animations: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     * @singleton
     */
    init: function () {
        AnimationCache.superclass.init.call(this);

        this.set('animations', {});
    },

    /**
     * Add an animation to the cache
     *
     * @opt {String} name Unique name of the animation
     * @opt {cocos.Animcation} animation Animation to cache
     */
    addAnimation: function (opts) {
        var name = opts.name,
            animation = opts.animation;

        this.get('animations')[name] = animation;
    },

    /**
     * Remove an animation from the cache
     *
     * @opt {String} name Unique name of the animation
     */
    removeAnimation: function (opts) {
        var name = opts.name;

        delete this.get('animations')[name];
    },

    /**
     * Get an animation from the cache
     *
     * @opt {String} name Unique name of the animation
     * @returns {cocos.Animation} Cached animation
     */
    getAnimation: function (opts) {
        var name = opts.name;

        return this.get('animations')[name];
    }
});

/**
 * Class methods
 */
util.extend(AnimationCache, /** @lends cocos.AnimationCache */{
    /**
     * @getter sharedAnimationCache
     * @type cocos.AnimationCache
     */
    get_sharedAnimationCache: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});

exports.AnimationCache = AnimationCache;

}};
__resources__["/__builtin__/libs/cocos2d/Director.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS SHOW_REDRAW_REGIONS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    geo = require('geometry'),
    ccp = geo.ccp,
    events    = require('events'),
    Scheduler = require('./Scheduler').Scheduler,
    EventDispatcher = require('./EventDispatcher').EventDispatcher,
    Scene = require('./nodes/Scene').Scene;


/**
 * requestAnimationFrame for smart animating
 * @see http://paulirish.com/2011/requestanimationframe-for-smart-animating/
 */
window.requestAnimFrame = (function (){
    return  window.requestAnimationFrame       || 
            window.webkitRequestAnimationFrame || 
            window.mozRequestAnimationFrame    || 
            window.oRequestAnimationFrame      || 
            window.msRequestAnimationFrame     || 
            function (callback) {
                window.setTimeout(callback, 1000 / 30);
            };
})();

window.cancelRequestAnimFrame = ( function() {
    return window.cancelAnimationFrame           ||
        window.webkitCancelRequestAnimationFrame ||
        window.mozCancelRequestAnimationFrame    ||
        window.oCancelRequestAnimationFrame      ||
        window.msCancelRequestAnimationFrame     ||
        clearTimeout
} )();

var Director = BObject.extend(/** @lends cocos.Director# */{
    backgroundColor: 'rgb(0, 0, 0)',
    canvas: null,
    context: null,
    sceneStack: null,
    winSize: null,
    isPaused: false,
    maxFrameRate: 30,
    displayFPS: false,
    preloadScene: null,
    isReady: false,
    buffer: null,
    bufferCtx: null,
    swallowKeys: true,

    // Time delta
    dt: 0,
    add: 0,
    nextDeltaTimeZero: false,
    lastUpdate: 0,

    _nextScene: null,

    /**
     * <p>Creates and handles the main view and manages how and when to execute the
     * Scenes.</p>
     *
     * <p>This class is a singleton so don't instantiate it yourself, instead use
     * cocos.Director.get('sharedDirector') to return the instance.</p>
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     * @singleton
     */
    init: function () {
        Director.superclass.init.call(this);

        this.set('sceneStack', []);
    },

    /**
     * Append to a HTML element. It will create a canvas tag
     *
     * @param {HTMLElement} view Any HTML element to add the application to
     */
    attachInView: function (view) {
        if (!view.tagName) {
            throw "Director.attachInView must be given a HTML DOM Node";
        }

        while (view.firstChild) {
            view.removeChild(view.firstChild);
        }


        var canvas = document.createElement('canvas');
        this.set('canvas', canvas);
        canvas.setAttribute('width', view.clientWidth);
        canvas.setAttribute('height', view.clientHeight);

        var context = canvas.getContext('2d');
        this.set('context', context);
        
        var buffer = document.createElement('canvas');
        this.set('buffer', buffer);
        buffer.setAttribute('width', view.clientWidth);
        buffer.setAttribute('height', view.clientHeight);
        
        this.set('bufferCtx', buffer.getContext('2d'));

        if (FLIP_Y_AXIS) {
            context.translate(0, view.clientHeight);
            context.scale(1, -1);
        }

        view.appendChild(canvas);

        this.set('winSize', {width: view.clientWidth, height: view.clientHeight});


        // Setup event handling

        // Mouse events
        var eventDispatcher = EventDispatcher.get('sharedDispatcher');
        var self = this;
        function mouseDown(evt) {
            evt.locationInWindow = ccp(evt.clientX, evt.clientY);
            evt.locationInCanvas = self.convertEventToCanvas(evt);

            function mouseDragged(evt) {
                evt.locationInWindow = ccp(evt.clientX, evt.clientY);
                evt.locationInCanvas = self.convertEventToCanvas(evt);

                eventDispatcher.mouseDragged(evt);
            }
            function mouseUp(evt) {
                evt.locationInWindow = ccp(evt.clientX, evt.clientY);
                evt.locationInCanvas = self.convertEventToCanvas(evt);

                document.body.removeEventListener('mousemove', mouseDragged, false);
                document.body.removeEventListener('mouseup',   mouseUp,   false);


                eventDispatcher.mouseUp(evt);
            }

            document.body.addEventListener('mousemove', mouseDragged, false);
            document.body.addEventListener('mouseup',   mouseUp,   false);

            eventDispatcher.mouseDown(evt);
        }
        function mouseMoved(evt) {
            evt.locationInWindow = ccp(evt.clientX, evt.clientY);
            evt.locationInCanvas = self.convertEventToCanvas(evt);

            eventDispatcher.mouseMoved(evt);
        }
        canvas.addEventListener('mousedown', mouseDown, false);
        canvas.addEventListener('mousemove', mouseMoved, false);

        var that = this;
        
        // Keyboard events
        function keyDown(evt) {
            this._keysDown = this._keysDown || {};
            eventDispatcher.keyDown(evt);
            
            if(that.swallowKeys) {
                evt.preventDefault(); 
                evt.cancelBubble = true;
                return false;
            }
        }
        function keyUp(evt) {
            eventDispatcher.keyUp(evt);
            
            if(that.swallowKeys) {
                evt.preventDefault(); 
                evt.cancelBubble = true;
                return false;
            }
        }

        document.documentElement.addEventListener('keydown', keyDown, false);
        document.documentElement.addEventListener('keyup', keyUp, false);
    },

    runPreloadScene: function () {
        var preloader = this.get('preloadScene');
        if (!preloader) {
            var PreloadScene = require('./nodes/PreloadScene').PreloadScene;
            preloader = PreloadScene.create();
            this.set('preloadScene', preloader);
        }

        events.addListener(preloader, 'complete', util.callback(this, function (preloader) {
            this.isReady = true;
            events.trigger(this, 'ready', this);
        }));

        this.pushScene(preloader);
        this.startAnimation();
    },

    /**
     * Enters the Director's main loop with the given Scene. Call it to run
     * only your FIRST scene. Don't call it if there is already a running
     * scene.
     *
     * @param {cocos.Scene} scene The scene to start
     */
    runWithScene: function (scene) {
        if (!(scene instanceof Scene)) {
            throw "Director.runWithScene must be given an instance of Scene";
        }

        if (this._runningScene) {
            throw "You can't run a Scene if another Scene is already running. Use replaceScene or pushScene instead";
        }

        this.pushScene(scene);
        this.startAnimation();
    },

    /**
     * Replaces the running scene with a new one. The running scene is
     * terminated. ONLY call it if there is a running scene.
     *
     * @param {cocos.Scene} scene The scene to replace with
     */
    replaceScene: function (scene) {
        var index = this.sceneStack.length;

        this._sendCleanupToScene = true;
        this.sceneStack.pop();
        this.sceneStack.push(scene);
        this._nextScene = scene;
    },

    /**
     * Pops out a scene from the queue. This scene will replace the running
     * one. The running scene will be deleted. If there are no more scenes in
     * the stack the execution is terminated. ONLY call it if there is a
     * running scene.
     */
    popScene: function () {
    },

    /**
     * Suspends the execution of the running scene, pushing it on the stack of
     * suspended scenes. The new scene will be executed. Try to avoid big
     * stacks of pushed scenes to reduce memory allocation. ONLY call it if
     * there is a running scene.
     *
     * @param {cocos.Scene} scene The scene to add to the stack
     */
    pushScene: function (scene) {
        this._nextScene = scene;
    },

    /**
     * The main loop is triggered again. Call this function only if
     * cocos.Directory#stopAnimation was called earlier.
     */
    startAnimation: function () {
        this.animate();
    },

    animate: function() {
        //this._animationTimer = setInterval(util.callback(this, 'drawScene'), 33);
        if(this.drawScene != null) {
            this.drawScene();
            window.requestAnimFrame(util.callback(this, 'animate'), this.canvas);
        }
    },

    /**
     * Stops the animation. Nothing will be drawn. The main loop won't be
     * triggered anymore. If you want to pause your animation call
     * cocos.Directory#pause instead.
     */
    stopAnimation: function () {
        if (this._animationTimer) {
            clearInterval(this._animationTimer);
            this._animationTimer = null;
        }
        else {
            window.cancelRequestAnimFrame()
        }
    },

    /**
     * Calculate time since last call
     * @private
     */
    calculateDeltaTime: function () {
        var now = (new Date()).getTime() / 1000;

        if (this.nextDeltaTimeZero) {
            this.dt = 0;
            this.nextDeltaTimeZero = false;
        }

        this.dt = Math.max(0, now - this.lastUpdate);

        this.lastUpdate = now;
    },

    /**
     * The main run loop
     * @private
     */
    drawScene: function () {
        this.calculateDeltaTime();
        
        this.realDt = this.dt;
        
        if(this.dt > 0.133) {
            this.dt /= 2;
        }
        if(this.dt > 0.066) {
            this.dt /= 2;
        }
        
        if (!this.isPaused) {
            Scheduler.get('sharedScheduler').tick(this.dt);
        }

        var context = this.get('context');
        //context.clearRect(0, 0, this.winSize.width, this.winSize.height);
        this.get('bufferCtx').clearRect(0, 0, this.winSize.width, this.winSize.height);

        if (this._nextScene) {
            this.setNextScene();
        }

        var rect = new geo.Rect(0, 0, this.winSize.width, this.winSize.height);

        if (rect) {
            context.beginPath();
            context.rect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
            context.clip();
            context.closePath();
        }
        
        //this._runningScene.visit(context, rect);
        this._runningScene.visit(this.get('bufferCtx'), rect);
        context.drawImage(this.buffer, 0, 0);

        if (SHOW_REDRAW_REGIONS) {
            if (rect) {
                context.beginPath();
                context.rect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
                context.fillStyle = "rgba(255, 0, 0, 0.5)";
                //context.fill();
                context.closePath();
            }
        }

        if (this.get('displayFPS')) {
            this.showFPS();
        }
    },

    /**
     * Initialises the next scene
     * @private
     */
    setNextScene: function () {
        // TODO transitions

        if (this._runningScene) {
            this._runningScene.onExit();
            if (this._sendCleanupToScene) {
                this._runningScene.cleanup();
            }
        }

        this._runningScene = this._nextScene;

        this._nextScene = null;

        this._runningScene.onEnter();
    },

    convertEventToCanvas: function (evt) {
        var x = this.canvas.offsetLeft - document.documentElement.scrollLeft,
            y = this.canvas.offsetTop - document.documentElement.scrollTop;

        var o = this.canvas;
        while ((o = o.offsetParent)) {
            x += o.offsetLeft - o.scrollLeft;
            y += o.offsetTop - o.scrollTop;
        }

        var p = geo.ccpSub(evt.locationInWindow, ccp(x, y));
        if (FLIP_Y_AXIS) {
            p.y = this.canvas.height - p.y;
        }

        return p;
    },

    showFPS: function () {
        if (!this._fpsLabel) {
            var Label = require('./nodes/Label').Label;
            this._fpsLabel = Label.create({string: '', fontSize: 16});
            this._fpsLabel.set('anchorPoint', ccp(0, 1));
            this._frames = 0;
            this._accumDt = 0;
        }


        this._frames++;
        this._accumDt += this.get('dt');
        
        if (this._accumDt > 1.0 / 3.0)  {
            var frameRate = this._frames / this._accumDt;
            this._frames = 0;
            this._accumDt = 0;

            this._fpsLabel.set('string', 'FPS: ' + (Math.round(frameRate * 100) / 100).toString());
        }


        var s = this.get('winSize');
        this._fpsLabel.set('position', ccp(10, s.height - 10));

        this._fpsLabel.visit(this.get('context'));
    }

});

/**
 * Class methods
 */
util.extend(Director, /** @lends cocos.Director */{
    /**
     * A shared singleton instance of cocos.Director
     *
     * @getter sharedDirector
     * @type cocos.Director
     */
    get_sharedDirector: function (key) {
        if (!Director._instance) {
            Director._instance = this.create();
        }

        return Director._instance;
    }
});

/**
 * @memberOf cocos
 * @class Pretends to run at a constant frame rate even if it slows down
 * @extends cocos.Director
 */
var DirectorFixedSpeed = Director.extend(/** @lends cocos.DirectorFixedSpeed */{
    /**
     * Frames per second to draw.
     * @type Integer
     */
    frameRate: 60,

    /**
     * Calculate time since last call
     * @private
     */
    calculateDeltaTime: function () {
        if (this.nextDeltaTimeZero) {
            this.dt = 0;
            this.nextDeltaTimeZero = false;
        }

        this.dt = 1.0 / this.get('frameRate');
    },

    /**
     * The main loop is triggered again. Call this function only if
     * cocos.Directory#stopAnimation was called earlier.
     */
    startAnimation: function () {
        this._animationTimer = setInterval(util.callback(this, 'drawScene'), 1000 / this.get('frameRate'));
        this.drawScene();
    }

});

exports.Director = Director;
exports.DirectorFixedSpeed = DirectorFixedSpeed;

}};
__resources__["/__builtin__/libs/cocos2d/EventDispatcher.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    geo = require('geometry');

var EventDispatcher = BObject.extend(/** @lends cocos.EventDispatcher# */{
    dispatchEvents: true,
    keyboardDelegates: null,
    mouseDelegates: null,
    _keysDown: null,
    
    /**
     * This singleton is responsible for dispatching Mouse and Keyboard events.
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     * @singleton
     */
    init: function () {
        EventDispatcher.superclass.init.call(this);

        this.keyboardDelegates = [];
        this.mouseDelegates = [];

        this._keysDown = {};
    },

    addDelegate: function (opts) {
        var delegate = opts.delegate,
            priority = opts.priority,
            flags    = opts.flags,
            list     = opts.list;

        var listElement = {
            delegate: delegate,
            priority: priority,
            flags: flags
        };

        var added = false;
        for (var i = 0; i < list.length; i++) {
            var elem = list[i];
            if (priority < elem.priority) {
                // Priority is lower, so insert before elem
                list.splice(i, 0, listElement);
                added = true;
                break;
            }
        }

        // High priority; append to array
        if (!added) {
            list.push(listElement);
        }
    },

    removeDelegate: function (opts) {
        var delegate = opts.delegate,
            list = opts.list;

        var idx = -1,
            i;
        for (i = 0; i < list.length; i++) {
            var l = list[i];
            if (l.delegate == delegate) {
                idx = i;
                break;
            }
        }
        if (idx == -1) {
            return;
        }
        list.splice(idx, 1);
    },
    removeAllDelegates: function (opts) {
        var list = opts.list;

        list.splice(0, list.length - 1);
    },

    addMouseDelegate: function (opts) {
        var delegate = opts.delegate,
            priority = opts.priority;

        var flags = 0;

        // TODO flags

        this.addDelegate({delegate: delegate, priority: priority, flags: flags, list: this.mouseDelegates});
    },

    removeMouseDelegate: function (opts) {
        var delegate = opts.delegate;

        this.removeDelegate({delegate: delegate, list: this.mouseDelegates});
    },

    removeAllMouseDelegate: function () {
        this.removeAllDelegates({list: this.mouseDelegates});
    },

    addKeyboardDelegate: function (opts) {
        var delegate = opts.delegate,
            priority = opts.priority;

        var flags = 0;

        // TODO flags

        this.addDelegate({delegate: delegate, priority: priority, flags: flags, list: this.keyboardDelegates});
    },

    removeKeyboardDelegate: function (opts) {
        var delegate = opts.delegate;

        this.removeDelegate({delegate: delegate, list: this.keyboardDelegates});
    },

    removeAllKeyboardDelegate: function () {
        this.removeAllDelegates({list: this.keyboardDelegates});
    },



    // Mouse Events

    mouseDown: function (evt) {
        if (!this.dispatchEvents) {
            return;
        }

        this._previousMouseMovePosition = geo.ccp(evt.clientX, evt.clientY);
        this._previousMouseDragPosition = geo.ccp(evt.clientX, evt.clientY);

        for (var i = 0; i < this.mouseDelegates.length; i++) {
            var entry = this.mouseDelegates[i];
            if (entry.delegate.mouseDown) {
                var swallows = entry.delegate.mouseDown(evt);
                if (swallows) {
                    break;
                }
            }
        }
    },
    mouseMoved: function (evt) {
        if (!this.dispatchEvents) {
            return;
        }

        if (this._previousMouseMovePosition) {
            evt.deltaX = evt.clientX - this._previousMouseMovePosition.x;
            evt.deltaY = evt.clientY - this._previousMouseMovePosition.y;
            if (FLIP_Y_AXIS) {
                evt.deltaY *= -1;
            }
        } else {
            evt.deltaX = 0;
            evt.deltaY = 0;
        }
        this._previousMouseMovePosition = geo.ccp(evt.clientX, evt.clientY);

        for (var i = 0; i < this.mouseDelegates.length; i++) {
            var entry = this.mouseDelegates[i];
            if (entry.delegate.mouseMoved) {
                var swallows = entry.delegate.mouseMoved(evt);
                if (swallows) {
                    break;
                }
            }
        }
    },
    mouseDragged: function (evt) {
        if (!this.dispatchEvents) {
            return;
        }

        if (this._previousMouseDragPosition) {
            evt.deltaX = evt.clientX - this._previousMouseDragPosition.x;
            evt.deltaY = evt.clientY - this._previousMouseDragPosition.y;
            if (FLIP_Y_AXIS) {
                evt.deltaY *= -1;
            }
        } else {
            evt.deltaX = 0;
            evt.deltaY = 0;
        }
        this._previousMouseDragPosition = geo.ccp(evt.clientX, evt.clientY);

        for (var i = 0; i < this.mouseDelegates.length; i++) {
            var entry = this.mouseDelegates[i];
            if (entry.delegate.mouseDragged) {
                var swallows = entry.delegate.mouseDragged(evt);
                if (swallows) {
                    break;
                }
            }
        }
    },
    mouseUp: function (evt) {
        if (!this.dispatchEvents) {
            return;
        }

        for (var i = 0; i < this.mouseDelegates.length; i++) {
            var entry = this.mouseDelegates[i];
            if (entry.delegate.mouseUp) {
                var swallows = entry.delegate.mouseUp(evt);
                if (swallows) {
                    break;
                }
            }
        }
    },

    // Keyboard events
    keyDown: function (evt) {
        var kc = evt.keyCode;
        if (!this.dispatchEvents || this._keysDown[kc]) {
            return;
        }

        this._keysDown[kc] = true;

        for (var i = 0; i < this.keyboardDelegates.length; i++) {
            var entry = this.keyboardDelegates[i];
            if (entry.delegate.keyDown) {
                var swallows = entry.delegate.keyDown(evt);
                if (swallows) {
                    break;
                }
            }
        }
    },

    keyUp: function (evt) {
        if (!this.dispatchEvents) {
            return;
        }

        var kc = evt.keyCode;
        if (this._keysDown[kc]) {
            delete this._keysDown[kc];
        }

        for (var i = 0; i < this.keyboardDelegates.length; i++) {
            var entry = this.keyboardDelegates[i];
            if (entry.delegate.keyUp) {
                var swallows = entry.delegate.keyUp(evt);
                if (swallows) {
                    break;
                }
            }
        }
    }

});

/**
 * Class methods
 */
util.extend(EventDispatcher, /** @lends cocos.EventDispatcher */{
    /**
     * A shared singleton instance of cocos.EventDispatcher
     *
     * @getter sharedDispatcher
     * @type cocos.EventDispatcher
     */
    get_sharedDispatcher: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});
exports.EventDispatcher = EventDispatcher;

}};
__resources__["/__builtin__/libs/cocos2d/index.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    path = require('path');

var modules = 'TextureAtlas Texture2D Preloader RemoteImage RemoteResource SpriteFrame SpriteFrameCache Director Animation AnimationCache Scheduler ActionManager TMXXMLParser'.w();

/**
 * @namespace All cocos2d objects live in this namespace
 */
var cocos = {
    nodes: require('./nodes'),
    actions: require('./actions')
};

util.each(modules, function (mod, i) {
    util.extend(cocos, require('./' + mod));
});

module.exports = cocos;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/AtlasNode.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var SpriteBatchNode = require('./BatchNode').SpriteBatchNode,
    TextureAtlas = require('../TextureAtlas').TextureAtlas,
    geo   = require('geometry');

var AtlasNode = SpriteBatchNode.extend(/** @lends cocos.AtlasNode# */{
    /**
     * Characters per row
     * @type Integer
     */
    itemsPerRow: 0,

    /**
     * Characters per column
     * @type Integer
     */
    itemsPerColumn: 0,

    /**
     * Width of a character
     * @type Integer
     */
    itemWidth: 0,

    /**
     * Height of a character
     * @type Integer
     */
    itemHeight: 0,


    /**
     * @type cocos.TextureAtlas
     */
     textureAtlas: null,

    /**
     * @class
     * It knows how to render a TextureAtlas object. If you are going to
     * render a TextureAtlas consider subclassing cocos.nodes.AtlasNode (or a
     * subclass of cocos.nodes.AtlasNode)
     * @memberOf cocos
     * @extends cocos.nodes.SpriteBatchNode
     * @constructs
     *
     * @opt {String} file Path to Atals image
     * @opt {Integer} itemWidth Character width
     * @opt {Integer} itemHeight Character height
     * @opt {Integer} itemsToRender Quantity of items to render
     */
    init: function (opts) {
        AtlasNode.superclass.init.call(this, opts);

        this.itemWidth = opts.itemWidth;
        this.itemHeight = opts.itemHeight;
        
        this.textureAtlas = TextureAtlas.create({file: opts.file, capacity: opts.itemsToRender});


        this._calculateMaxItems();
    },

    updateAtlasValues: function () {
        throw "cocos.nodes.AtlasNode:Abstract - updateAtlasValue not overriden";
    },

    _calculateMaxItems: function () {
        var s = this.textureAtlas.get('texture.contentSize');
        this.itemsPerColumn = s.height / this.itemHeight;
        this.itemsPerRow = s.width / this.itemWidth;
    }
});

exports.AtlasNode = AtlasNode;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/BatchNode.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray SHOW_REDRAW_REGIONS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    evt = require('events'),
    geo = require('geometry'),
    ccp = geo.ccp,
    TextureAtlas = require('../TextureAtlas').TextureAtlas,
    RenderTexture = require('./RenderTexture').RenderTexture,
    Node = require('./Node').Node;

var BatchNode = Node.extend(/** @lends cocos.nodes.BatchNode# */{
    partialDraw: false,
    contentRect: null,
    renderTexture: null,
    dirty: true,

    /**
     * Region to redraw
     * @type geometry.Rect
     */
    dirtyRegion: null,
    dynamicResize: false,

    /** @private
     * Areas that need redrawing
     *
     * Not implemented
     */
    _dirtyRects: null,


    /**
     * Draws all children to an in-memory canvas and only redraws when something changes
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {geometry.Size} size The size of the in-memory canvas used for drawing to
     * @opt {Boolean} [partialDraw=false] Draw only the area visible on screen. Small maps may be slower in some browsers if this is true.
     */
    init: function (opts) {
        BatchNode.superclass.init.call(this, opts);

        var size = opts.size || geo.sizeMake(1, 1);
        this.set('partialDraw', opts.partialDraw);

        evt.addListener(this, 'contentsize_changed', util.callback(this, this._resizeCanvas));
        
        this._dirtyRects = [];
        this.set('contentRect', geo.rectMake(0, 0, size.width, size.height));
        this.renderTexture = RenderTexture.create(size);
        this.renderTexture.sprite.set('isRelativeAnchorPoint', false);
        this.addChild({child: this.renderTexture});
    },

    addChild: function (opts) {
        BatchNode.superclass.addChild.call(this, opts);

        var child = opts.child,
            z     = opts.z;

        if (child == this.renderTexture) {
            return;
        }

        // TODO handle texture resize

        // Watch for changes in child
        var watchEvents = ['position_before_changed',
                           'scalex_before_changed',
                           'scaley_before_changed',
                           'rotation_before_changed',
                           'anchorpoint_before_changed',
                           'opacity_before_changed',
                           'visible_before_changed'];
        evt.addListener(child, watchEvents, util.callback(this, function () {
            this.addDirtyRegion(child.get('boundingBox'));
        }));

        this.addDirtyRegion(child.get('boundingBox'));
    },

    removeChild: function (opts) {
        BatchNode.superclass.removeChild.call(this, opts);

        // TODO remove istransformdirty_changed and visible_changed listeners

        this.set('dirty', true);
    },

    addDirtyRegion: function (rect) {
        // Increase rect slightly to compensate for subpixel artifacts
        rect = util.copy(rect);
        rect.origin.x -= 2;
        rect.origin.y -= 2;
        rect.size.width += 4;
        rect.size.height += 4;

        var region = this.get('dirtyRegion');
        if (!region) {
            region = rect;
        } else {
            region = geo.rectUnion(region, rect);
        }

        this.set('dirtyRegion', region);
        this.set('dirty', true);
    },

    _resizeCanvas: function (oldSize) {
        var size = this.get('contentSize');

        if (geo.sizeEqualToSize(size, oldSize)) {
            return; // No change
        }


        this.renderTexture.set('contentSize', size);
        this.set('dirty', true);
    },

    update: function () {

    },

    visit: function (context) {
        if (!this.visible) {
            return;
        }

        context.save();

        this.transform(context);

        var rect = this.get('dirtyRegion');
        // Only redraw if something changed
        if (this.dirty) {

            if (rect) {
                if (this.get('partialDraw')) {
                    // Clip region to visible area
                    var s = require('../Director').Director.get('sharedDirector').get('winSize'),
                        p = this.get('position');
                    var r = new geo.Rect(
                        0, 0,
                        s.width, s.height
                    );
                    r = geo.rectApplyAffineTransform(r, this.worldToNodeTransform());
                    rect = geo.rectIntersection(r, rect);
                }

                this.renderTexture.clear(rect);

                this.renderTexture.context.save();
                this.renderTexture.context.beginPath();
                this.renderTexture.context.rect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
                this.renderTexture.context.clip();
                this.renderTexture.context.closePath();
            } else {
                this.renderTexture.clear();
            }

            for (var i = 0, childLen = this.children.length; i < childLen; i++) {
                var c = this.children[i];
                if (c == this.renderTexture) {
                    continue;
                }

                // Draw children inside rect
                if (!rect || geo.rectOverlapsRect(c.get('boundingBox'), rect)) {
                    c.visit(this.renderTexture.context, rect);
                }
            }

            if (SHOW_REDRAW_REGIONS) {
                if (rect) {
                    this.renderTexture.context.beginPath();
                    this.renderTexture.context.rect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
                    this.renderTexture.context.fillStyle = "rgba(0, 0, 255, 0.5)";
                    this.renderTexture.context.fill();
                    this.renderTexture.context.closePath();
                }
            }

            if (rect) {
                this.renderTexture.context.restore();
            }

            this.set('dirty', false);
            this.set('dirtyRegion', null);
        }

        this.renderTexture.visit(context);

        context.restore();
    },

    draw: function (ctx) {
    },

    onEnter: function () {
        if (this.get('partialDraw')) {
            evt.addListener(this.get('parent'), 'istransformdirty_changed', util.callback(this, function () {
                var box = this.get('visibleRect');
                this.addDirtyRegion(box);
            }));
        }
    }
});

var SpriteBatchNode = BatchNode.extend(/** @lends cocos.nodes.SpriteBatchNode# */{
    textureAtlas: null,

    /**
     * @memberOf cocos.nodes
     * @class A BatchNode that accepts only Sprite using the same texture
     * @extends cocos.nodes.BatchNode
     * @constructs
     *
     * @opt {String} file (Optional) Path to image to use as sprite atlas
     * @opt {Texture2D} texture (Optional) Texture to use as sprite atlas
     * @opt {cocos.TextureAtlas} textureAtlas (Optional) TextureAtlas to use as sprite atlas
     */
    init: function (opts) {
        SpriteBatchNode.superclass.init.call(this, opts);

        var file         = opts.file,
            textureAtlas = opts.textureAtlas,
            texture      = opts.texture;

        if (file || texture) {
            textureAtlas = TextureAtlas.create({file: file, texture: texture});
        }

        this.set('textureAtlas', textureAtlas);
    },

    /**
     * @getter texture
     * @type cocos.Texture2D
     */
    get_texture: function () {
        return this.textureAtlas ? this.textureAtlas.texture : null;
    },

    set_opacity: function (newOpacity) {
        this.opacity = newOpacity;
        for (var i = 0, len = this.children.length; i < len; i++) {
            var child = this.children[i];
            child.set('opacity', newOpacity);
        }
    }

});

exports.BatchNode = BatchNode;
exports.SpriteBatchNode = SpriteBatchNode;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/index.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    path = require('path');

var modules = 'AtlasNode LabelAtlas ProgressBar PreloadScene Node Layer Scene Label Sprite TMXTiledMap BatchNode RenderTexture Menu MenuItem Transition'.w();

/** 
 * @memberOf cocos
 * @namespace All cocos2d nodes. i.e. anything that can be added to a Scene
 */
var nodes = {};

util.each(modules, function (mod, i) {
    util.extend(nodes, require('./' + mod));
});

module.exports = nodes;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Label.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    console = require('system').console,
    Director = require('../Director').Director,
    Node = require('./Node').Node,
    ccp = require('geometry').ccp;

var Label = Node.extend(/** @lends cocos.nodes.Label# */{
    string:   '',
    fontName: 'Helvetica',
    fontSize: 16,
    fontColor: 'white',

    /**
     * Renders a simple text label
     *
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {String} [string=""] The text string to draw
     * @opt {Float} [fontSize=16] The size of the font
     * @opt {String} [fontName="Helvetica"] The name of the font to use
     * @opt {String} [fontColor="white"] The color of the text
     */
    init: function (opts) {
        Label.superclass.init.call(this, opts);

        util.each('fontSize fontName fontColor string'.w(), util.callback(this, function (name) {
            // Set property on init
            if (opts[name]) {
                this.set(name, opts[name]);
            }

            // Update content size
            this._updateLabelContentSize();
        }));
    },

    /** 
     * String of the font name and size to use in a format &lt;canvas&gt; understands
     *
     * @getter font
     * @type String
     */
    get_font: function (key) {
        return this.get('fontSize') + 'px ' + this.get('fontName');
    },

    draw: function (context) {
        if (FLIP_Y_AXIS) {
            context.save();

            // Flip Y axis
            context.scale(1, -1);
            context.translate(0, -this.get('fontSize'));
        }


        context.fillStyle = this.get('fontColor');
        context.font = this.get('font');
        context.textBaseline = 'top';
        if (context.fillText) {
            context.fillText(this.get('string'), 0, 0);
        } else if (context.mozDrawText) {
            context.mozDrawText(this.get('string'));
        }

        if (FLIP_Y_AXIS) {
            context.restore();
        }
    },

    /**
     * @private
     */
    _updateLabelContentSize: function () {
        var ctx = Director.get('sharedDirector').get('context');
        var size = {width: 0, height: this.get('fontSize')};

        var prevFont = ctx.font;
        ctx.font = this.get('font');

        if (ctx.measureText) {
            var txtSize = ctx.measureText(this.get('string'));
            size.width = txtSize.width;
        } else if (ctx.mozMeasureText) {
            size.width = ctx.mozMeasureText(this.get('string'));
        }

        ctx.font = prevFont;

        this.set('contentSize', size);
    }
});

module.exports.Label = Label;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/LabelAtlas.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var AtlasNode = require('./AtlasNode').AtlasNode,
    Sprite = require('./Sprite').Sprite,
    geo   = require('geometry');

var LabelAtlas = AtlasNode.extend(/** @lends cocos.nodes.LabelAtlas# */{
    string: '',

    mapStartChar: '',

    /**
     * @memberOf cocos.nodes
     * @extends cocos.nodes.BatchNode
     * @constructs
     *
     * @opt {String} [string=] Initial text to draw
     * @opt {String} charMapFile
     * @opt {Integer} itemWidth
     * @opt {Integer} itemHeight
     * @opt {String} startCharMap Single character
     */
    init: function (opts) {
        LabelAtlas.superclass.init.call(this, {
            file: opts.charMapFile,
            itemWidth: opts.itemWidth,
            itemHeight: opts.itemHeight,
            itemsToRender: opts.string.length,
            size: new geo.Size(opts.itemWidth * opts.string.length, opts.itemHeight)
        });


        this.mapStartChar = opts.startCharMap.charCodeAt(0);
        this.set('string', opts.string);
    },

    updateAtlasValue: function () {
        var n = this.string.length,
            s = this.get('string');
    
        // FIXME this should reuse children to improve performance
        while (this.children.length > 0) {
            this.removeChild(this.children[0]);
        }
        for (var i = 0; i < n; i++) {
            var a = s.charCodeAt(i) - this.mapStartChar,
                row = (a % this.itemsPerRow),
                col = Math.floor(a / this.itemsPerRow);
    
            var left = row * this.itemWidth,
                top  = col * this.itemHeight;

            var tile = Sprite.create({rect: new geo.Rect(left, top, this.itemWidth, this.itemHeight),
                              textureAtlas: this.textureAtlas});

            tile.set('position', new geo.Point(i * this.itemWidth, 0));
            tile.set('anchorPoint', new geo.Point(0, 0));
            tile.set('opacity', this.get('opacity'));
            
            this.addChild({child: tile});
        }
    },

    set_string: function (newString) {
        this.string = newString;

        this.updateAtlasValue();
    }
});


exports.LabelAtlas = LabelAtlas;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Layer.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var Node = require('./Node').Node,
    util = require('util'),
    evt = require('events'),
    Director = require('../Director').Director,
    ccp    = require('geometry').ccp,
    EventDispatcher = require('../EventDispatcher').EventDispatcher;

var Layer = Node.extend(/** @lends cocos.nodes.Layer# */{
    isMouseEnabled: false,
    isKeyboardEnabled: false,
    mouseDelegatePriority: 0,
    keyboardDelegatePriority: 0,

    /** 
     * A fullscreen Node. You need at least 1 layer in your app to add other nodes to.
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     */
    init: function () {
        Layer.superclass.init.call(this);

        var s = Director.get('sharedDirector').get('winSize');

        this.set('isRelativeAnchorPoint', false);
        this.anchorPoint = ccp(0.5, 0.5);
        this.set('contentSize', s);

        evt.addListener(this, 'ismouseenabled_changed', util.callback(this, function () {
            if (this.isRunning) {
                if (this.isMouseEnabled) {
                    EventDispatcher.get('sharedDispatcher').addMouseDelegate({delegate: this, priority: this.get('mouseDelegatePriority')});
                } else {
                    EventDispatcher.get('sharedDispatcher').removeMouseDelegate({delegate: this});
                }
            }
        }));


        evt.addListener(this, 'iskeyboardenabled_changed', util.callback(this, function () {
            if (this.isRunning) {
                if (this.isKeyboardEnabled) {
                    EventDispatcher.get('sharedDispatcher').addKeyboardDelegate({delegate: this, priority: this.get('keyboardDelegatePriority')});
                } else {
                    EventDispatcher.get('sharedDispatcher').removeKeyboardDelegate({delegate: this});
                }
            }
        }));
    },

    onEnter: function () {
        if (this.isMouseEnabled) {
            EventDispatcher.get('sharedDispatcher').addMouseDelegate({delegate: this, priority: this.get('mouseDelegatePriority')});
        }
        if (this.isKeyboardEnabled) {
            EventDispatcher.get('sharedDispatcher').addKeyboardDelegate({delegate: this, priority: this.get('keyboardDelegatePriority')});
        }
				
        Layer.superclass.onEnter.call(this);
    },

    onExit: function () {
        if (this.isMouseEnabled) {
            EventDispatcher.get('sharedDispatcher').removeMouseDelegate({delegate: this});
        }
        if (this.isKeyboardEnabled) {
            EventDispatcher.get('sharedDispatcher').removeKeyboardDelegate({delegate: this});
        }

        Layer.superclass.onExit.call(this);
    }
});

module.exports.Layer = Layer;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Menu.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    Layer = require('./Layer').Layer,
    Director = require('../Director').Director,
    MenuItem = require('./MenuItem').MenuItem,
    geom = require('geometry'), ccp = geom.ccp;

/**
 * @private
 * @constant
 */
var kMenuStateWaiting = 0;

/**
 * @private
 * @constant
 */
var kMenuStateTrackingTouch = 1;
    

var Menu = Layer.extend(/** @lends cocos.nodes.Menu# */{
    mouseDelegatePriority: (-Number.MAX_VALUE + 1),
    state: kMenuStateWaiting,
    selectedItem: null,
    color: null,

    /**
     * A fullscreen node used to render a selection of menu options
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Layer
     *
     * @opt {cocos.nodes.MenuItem[]} items An array of MenuItems to draw on the menu
     */
    init: function (opts) {
        Menu.superclass.init.call(this, opts);

        var items = opts.items;

        this.set('isMouseEnabled', true);
        
        var s = Director.get('sharedDirector').get('winSize');

        this.set('isRelativeAnchorPoint', false);
        this.anchorPoint = ccp(0.5, 0.5);
        this.set('contentSize', s);

        this.set('position', ccp(s.width / 2, s.height / 2));


        if (items) {
            var z = 0;
            util.each(items, util.callback(this, function (item) {
                this.addChild({child: item, z: z++});
            }));
        }

        
    },

    addChild: function (opts) {
        if (!opts.child instanceof MenuItem) {
            throw "Menu only supports MenuItem objects as children";
        }

        Menu.superclass.addChild.call(this, opts);
    },

    itemForMouseEvent: function (event) {
        var location = event.locationInCanvas;

        var children = this.get('children');
        for (var i = 0, len = children.length; i < len; i++) {
            var item = children[i];

            if (item.get('visible') && item.get('isEnabled')) {
                var local = item.convertToNodeSpace(location);
                
                var r = item.get('rect');
                r.origin = ccp(0, 0);

                if (geom.rectContainsPoint(r, local)) {
                    return item;
                }

            }
        }

        return null;
    },

    mouseUp: function (event) {
        var selItem = this.get('selectedItem');

        if (selItem) {
            selItem.unselected();
            selItem.activate();
        }

        if (this.state != kMenuStateWaiting) {
            this.set('state', kMenuStateWaiting);
        }
        if (selItem) {
            return true;
        }
        return false;

    },
    mouseDown: function (event) {
        if (this.state != kMenuStateWaiting || !this.visible) {
            return false;
        }

        var selectedItem = this.itemForMouseEvent(event);
        this.set('selectedItem', selectedItem);
        if (selectedItem) {
            selectedItem.selected()
            this.set('state', kMenuStateTrackingTouch);

            return true;
        }

        return false;
    },

    mouseDragged: function (event) {
        var currentItem = this.itemForMouseEvent(event);

        if (currentItem != this.selectedItem) {
            if (this.selectedItem) {
                this.selectedItem.unselected();
            }
            this.set('selectedItem', currentItem);
            if (this.selectedItem) {
                this.selectedItem.selected();
            }
        }

        if (currentItem && this.state == kMenuStateTrackingTouch) {
            return true;
        }

        return false;
        
    }

});

exports.Menu = Menu;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/MenuItem.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    Node = require('./Node').Node,
    Sprite = require('./Sprite').Sprite,
    rectMake = require('geometry').rectMake,
    ccp = require('geometry').ccp;

var MenuItem = Node.extend(/** @lends cocos.nodes.MenuItem# */{
    isEnabled: true,
    isSelected: false,
    callback: null,

    /**
     * Base class for any buttons or options in a menu
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {Function} callback Function to call when menu item is activated
     */
    init: function (opts) {
        MenuItem.superclass.init.call(this, opts);

        var callback = opts.callback;

        this.set('anchorPoint', ccp(0.5, 0.5));
        this.set('callback', callback);
    },

    activate: function () {
        if (this.isEnabled && this.callback) {
            this.callback(this);
        }
    },

    /**
     * @getter rect
     * @type geometry.Rect
     */
    get_rect: function () {
        return rectMake(
            this.position.x - this.contentSize.width  * this.anchorPoint.x,
            this.position.y - this.contentSize.height * this.anchorPoint.y,
            this.contentSize.width,
            this.contentSize.height
        );
    },

    selected: function () {
        this.isSelected = true;
    },

    unselected: function () {
        this.isSelected = false;
    }
});

var MenuItemSprite = MenuItem.extend(/** @lends cocos.nodes.MenuItemSprite# */{
    normalImage: null,
    selectedImage: null,
    disabledImage: null,

    /**
     * A menu item that accepts any cocos.nodes.Node
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.MenuItem
     *
     * @opt {cocos.nodes.Node} normalImage Main Node to draw
     * @opt {cocos.nodes.Node} selectedImage Node to draw when menu item is selected
     * @opt {cocos.nodes.Node} disabledImage Node to draw when menu item is disabled
     */
    init: function (opts) {
        MenuItemSprite.superclass.init.call(this, opts);

        var normalImage   = opts.normalImage,
            selectedImage = opts.selectedImage,
            disabledImage = opts.disabledImage;

        this.set('normalImage', normalImage);
        this.set('selectedImage', selectedImage);
        this.set('disabledImage', disabledImage);

        this.set('contentSize', normalImage.get('contentSize'));
    },

    set_normalImage: function (image) {
        if (image != this.normalImage) {
            image.set('anchorPoint', ccp(0, 0));
            image.set('visible', true);
            this.removeChild({child: this.normalImage, cleanup: true});
            this.addChild(image);

            this.normalImage = image;
        }
    },

    set_selectedImage: function (image) {
        if (image != this.selectedImage) {
            image.set('anchorPoint', ccp(0, 0));
            image.set('visible', false);
            this.removeChild({child: this.selectedImage, cleanup: true});
            this.addChild(image);

            this.selectedImage = image;
        }
    },

    set_disabledImage: function (image) {
        if (image != this.disabledImage) {
            image.set('anchorPoint', ccp(0, 0));
            image.set('visible', false);
            this.removeChild({child: this.disabledImage, cleanup: true});
            this.addChild(image);

            this.disabledImage = image;
        }
    },

    selected: function () {
        MenuItemSprite.superclass.selected.call(this);

        if (this.selectedImage) {
            this.normalImage.set('visible',   false);
            this.selectedImage.set('visible', true);
            if (this.disabledImage) this.disabledImage.set('visible', false);
        } else {
            this.normalImage.set('visible',   true);
            if (this.disabledImage) this.disabledImage.set('visible', false);
        }
    },

    unselected: function () {
        MenuItemSprite.superclass.unselected.call(this);

        this.normalImage.set('visible',   true);
        if (this.selectedImage) this.selectedImage.set('visible', false);
        if (this.disabledImage) this.disabledImage.set('visible', false);
    },

    set_isEnabled: function (enabled) {
        this.isEnabled = enabled;

        if (enabled) {
            this.normalImage.set('visible',   true);
            if (this.selectedImage) this.selectedImage.set('visible', false);
            if (this.disabledImage) this.disabledImage.set('visible', false);
        } else {
            if (this.disabledImage) {
                this.normalImage.set('visible',   false);
                if (this.selectedImage) this.selectedImage.set('visible', false);
                this.disabledImage.set('visible', true);
            } else {
                this.normalImage.set('visible',   true);
                if (this.selectedImage) this.selectedImage.set('visible', false);
            }
        }
    }

});

var MenuItemImage = MenuItemSprite.extend(/** @lends cocos.nodes.MenuItemImage# */{

    /**
     * MenuItem that accepts image files
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.MenuItemSprite
     *
     * @opt {String} normalImage Main image file to draw
     * @opt {String} selectedImage Image file to draw when menu item is selected
     * @opt {String} disabledImage Image file to draw when menu item is disabled
     */
    init: function (opts) {
        var normalI   = opts.normalImage,
            selectedI = opts.selectedImage,
            disabledI = opts.disabledImage,
            callback  = opts.callback;

        var normalImage = Sprite.create({file: normalI}),
            selectedImage = Sprite.create({file: selectedI}),
            disabledImage = null;

        if (disabledI) {
            disabledImage = Sprite.create({file: disabledI});
        }

        return MenuItemImage.superclass.init.call(this, {normalImage: normalImage, selectedImage: selectedImage, disabledImage: disabledImage, callback: callback});
    }
});

exports.MenuItem = MenuItem;
exports.MenuItemImage = MenuItemImage;
exports.MenuItemSprite = MenuItemSprite;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Node.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    evt = require('events'),
    Scheduler = require('../Scheduler').Scheduler,
    ActionManager = require('../ActionManager').ActionManager,
    geo = require('geometry'), ccp = geo.ccp;

var Node = BObject.extend(/** @lends cocos.nodes.Node# */{
    isCocosNode: true,

    /**
     * Is the node visible
     * @type boolean
     */
    visible: true,

    /**
     * Position relative to parent node
     * @type geometry.Point
     */
    position: null,

    /**
     * Parent node
     * @type cocos.nodes.Node
     */
    parent: null,

    /**
     * Unique tag to identify the node
     * @type *
     */
    tag: null,

    /**
     * Size of the node
     * @type geometry.Size
     */
    contentSize: null,

    /**
     * Nodes Z index. i.e. draw order
     * @type Integer
     */
    zOrder: 0,

    /**
     * Anchor point for scaling and rotation. 0x0 is top left and 1x1 is bottom right
     * @type geometry.Point
     */
    anchorPoint: null,

    /**
     * Anchor point for scaling and rotation in pixels from top left
     * @type geometry.Point
     */
    anchorPointInPixels: null,

    /**
     * Rotation angle in degrees
     * @type Float
     */
    rotation: 0,

    /**
     * X scale factor
     * @type Float
     */
    scaleX: 1,

    /**
     * Y scale factor
     * @type Float
     */
    scaleY: 1,

    /**
     * Opacity of the Node. 0 is totally transparent, 255 is totally opaque
     * @type Float
     */
    opacity: 255,

    isRunning: false,
    isRelativeAnchorPoint: true,

    isTransformDirty: true,
    isInverseDirty: true,
    inverse: null,
    transformMatrix: null,

    /**
     * The child Nodes
     * @type cocos.nodes.Node[]
     */
    children: null,

    /**
     * @memberOf cocos.nodes
     * @class The base class all visual elements extend from
     * @extends BObject
     * @constructs
     */
    init: function () {
        Node.superclass.init.call(this);
        this.set('contentSize', {width: 0, height: 0});
        this.anchorPoint = ccp(0.5, 0.5);
        this.anchorPointInPixels = ccp(0, 0);
        this.position = ccp(0, 0);
        this.children = [];

        util.each(['scaleX', 'scaleY', 'rotation', 'position', 'anchorPoint', 'contentSize', 'isRelativeAnchorPoint'], util.callback(this, function (key) {
            evt.addListener(this, key.toLowerCase() + '_changed', util.callback(this, this._dirtyTransform));
        }));
        evt.addListener(this, 'anchorpoint_changed', util.callback(this, this._updateAnchorPointInPixels));
        evt.addListener(this, 'contentsize_changed', util.callback(this, this._updateAnchorPointInPixels));
    },

    /**
     * Calculates the anchor point in pixels and updates the
     * anchorPointInPixels property
     * @private
     */
    _updateAnchorPointInPixels: function () {
        var ap = this.get('anchorPoint'),
            cs = this.get('contentSize');
        this.set('anchorPointInPixels', ccp(cs.width * ap.x, cs.height * ap.y));
    },

    /**
     * Add a child Node
     *
     * @opt {cocos.nodes.Node} child The child node to add
     * @opt {Integer} [z] Z Index for the child
     * @opt {Integer|String} [tag] A tag to reference the child with
     * @returns {cocos.nodes.Node} The node the child was added to. i.e. 'this'
     */
    addChild: function (opts) {
        if (opts.isCocosNode) {
            return this.addChild({child: opts});
        }

        var child = opts.child,
            z = opts.z,
            tag = opts.tag;

        if (z === undefined || z === null) {
            z = child.get('zOrder');
        }

        //this.insertChild({child: child, z:z});
        var added = false;


        for (var i = 0, childLen = this.children.length; i < childLen; i++) {
            var c = this.children[i];
            if (c.zOrder > z) {
                added = true;
                this.children.splice(i, 0, child);
                break;
            }
        }

        if (!added) {
            this.children.push(child);
        }

        child.set('tag', tag);
        child.set('zOrder', z);
        child.set('parent', this);

        if (this.isRunning) {
            child.onEnter();
        }

        return this;
    },
    getChild: function (opts) {
        var tag = opts.tag;

        for (var i = 0; i < this.children.length; i++) {
            if (this.children[i].tag == tag) {
                return this.children[i];
            }
        }

        return null;
    },

    removeChild: function (opts) {
        if (opts.isCocosNode) {
            return this.removeChild({child: opts});
        }

        var child = opts.child,
            cleanup = opts.cleanup;

        if (!child) {
            return;
        }

        var children = this.get('children'),
            idx = children.indexOf(child);

        if (idx > -1) {
            this.detatchChild({child: child, cleanup: cleanup});
        }
    },

    removeChildren: function(opts) {
        var children = this.get('children'),
            isRunning = this.get('isRunning');
        
        // Perform cleanup on each child but can't call removeChild() 
        // due to Array.splice's destructive nature during iteration.
        for (var i = 0; i < children.length; i++) {
            if (opts.cleanup) {
                children[i].cleanup();
            }
            if (isRunning) {
                children[i].onExit();
            }
            children[i].set('parent', null);
        }
        // Now safe to empty children list
        this.children = [];
    },
    
    detatchChild: function (opts) {
        var child = opts.child,
            cleanup = opts.cleanup;

        var children = this.get('children'),
            isRunning = this.get('isRunning'),
            idx = children.indexOf(child);

        if (isRunning) {
            child.onExit();
        }

        if (cleanup) {
            child.cleanup();
        }

        child.set('parent', null);
        children.splice(idx, 1);
    },

    reorderChild: function (opts) {
        var child = opts.child,
            z     = opts.z;

        var pos = this.children.indexOf(child);
        if (pos == -1) {
            throw "Node isn't a child of this node";
        }

        child.set('zOrder', z);

        // Remove child
        this.children.splice(pos, 1);

        // Add child back at correct location
        var added = false;
        for (var i = 0, childLen = this.children.length; i < childLen; i++) {
            var c = this.children[i];
            if (c.zOrder > z) {
                added = true;
                this.children.splice(i, 0, child);
                break;
            }
        }

        if (!added) {
            this.children.push(child);
        }
    },

    /**
     * Draws the node. Override to do custom drawing. If it's less efficient to
     * draw only the area inside the rect then don't bother. The result will be
     * clipped to that area anyway.
     *
     * @param {CanvasRenderingContext2D|WebGLRenderingContext} context Canvas rendering context
     * @param {geometry.Rect} rect Rectangular region that needs redrawing. Limit drawing to this area only if it's more efficient to do so.
     */
    draw: function (context, rect) {
        // All draw code goes here
    },

    /**
     * @getter scale
     * @type Float
     */
    get_scale: function () {
        if (this.scaleX != this.scaleY) {
            throw "scaleX and scaleY aren't identical";
        }

        return this.scaleX;
    },

    /**
     * @setter scale
     * @type Float
     */
    set_scale: function (val) {
        this.set('scaleX', val);
        this.set('scaleY', val);
    },
		
    scheduleUpdate: function (opts) {
        opts = opts || {};
        var priority = opts.priority || 0;

        Scheduler.get('sharedScheduler').scheduleUpdate({target: this, priority: priority, paused: !this.get('isRunning')});
    },

    /**
     * Triggered when the node is added to a scene
     *
     * @event
     */
    onEnter: function () {
        util.each(this.children, function (child) {
            child.onEnter();
        });

        this.resumeSchedulerAndActions();
        this.set('isRunning', true);
    },

    /**
     * Triggered when the node is removed from a scene
     *
     * @event
     */
    onExit: function () {
        this.pauseSchedulerAndActions();
        this.set('isRunning', false);

        util.each(this.children, function (child) {
            child.onExit();
        });
    },

    cleanup: function () {
        this.stopAllActions();
        this.unscheduleAllSelectors();
        util.each(this.children, function (child) {
            child.cleanup();
        });
    },

    resumeSchedulerAndActions: function () {
        Scheduler.get('sharedScheduler').resumeTarget(this);
        ActionManager.get('sharedManager').resumeTarget(this);
    },
    pauseSchedulerAndActions: function () {
        Scheduler.get('sharedScheduler').pauseTarget(this);
        ActionManager.get('sharedManager').pauseTarget(this);
    },
    unscheduleSelector: function (selector) {
        Scheduler.get('sharedScheduler').unschedule({target: this, method: selector});
    },
    unscheduleAllSelectors: function () {
        Scheduler.get('sharedScheduler').unscheduleAllSelectorsForTarget(this);
    },
    stopAllActions: function () {
        ActionManager.get('sharedManager').removeAllActionsFromTarget(this);
    },

    visit: function (context, rect) {
        if (!this.visible) {
            return;
        }

        context.save();

        this.transform(context);

        // Set alpha value (global only for now)
        context.globalAlpha = this.get('opacity') / 255.0;
        
        // Adjust redraw region by nodes position
        if (rect) {
            var pos = this.get('position');
            rect = new geo.Rect(rect.origin.x - pos.x, rect.origin.y - pos.y, rect.size.width, rect.size.height);
        }

        // Draw background nodes
        util.each(this.children, function (child, i) {
            if (child.zOrder < 0) {
                child.visit(context, rect);
            }
        });
        
        this.draw(context, rect);

        // Draw foreground nodes
        util.each(this.children, function (child, i) {
            if (child.zOrder >= 0) {
                child.visit(context, rect);
            }
        });

        context.restore();
    },
    transform: function (context) {
        // Translate
        if (this.isRelativeAnchorPoint && (this.anchorPointInPixels.x !== 0 || this.anchorPointInPixels.y !== 0)) {
            context.translate(Math.round(-this.anchorPointInPixels.x), Math.round(-this.anchorPointInPixels.y));
        }

        if (this.anchorPointInPixels.x !== 0 || this.anchorPointInPixels.y !== 0) {
            context.translate(Math.round(this.position.x + this.anchorPointInPixels.x), Math.round(this.position.y + this.anchorPointInPixels.y));
        } else {
            context.translate(Math.round(this.position.x), Math.round(this.position.y));
        }

        // Rotate
        context.rotate(geo.degreesToRadians(this.get('rotation')));

        // Scale
        context.scale(this.scaleX, this.scaleY);

        if (this.anchorPointInPixels.x !== 0 || this.anchorPointInPixels.y !== 0) {
            context.translate(Math.round(-this.anchorPointInPixels.x), Math.round(-this.anchorPointInPixels.y));
        }
    },

    runAction: function (action) {
        ActionManager.get('sharedManager').addAction({action: action, target: this, paused: this.get('isRunning')});
    },
    
    /**
     * @opts {String} tag Tag of the action to return
     */
    getAction: function(opts) {
        return ActionManager.get('sharedManager').getActionFromTarget({target: this, tag: opts.tag});
    },
    
    nodeToParentTransform: function () {
        if (this.isTransformDirty) {
            this.transformMatrix = geo.affineTransformIdentity();

            if (!this.isRelativeAnchorPoint && !geo.pointEqualToPoint(this.anchorPointInPixels, ccp(0, 0))) {
                this.transformMatrix = geo.affineTransformTranslate(this.transformMatrix, this.anchorPointInPixels.x, this.anchorPointInPixels.y);
            }

            if (!geo.pointEqualToPoint(this.position, ccp(0, 0))) {
                this.transformMatrix = geo.affineTransformTranslate(this.transformMatrix, this.position.x, this.position.y);
            }

            if (this.rotation !== 0) {
                this.transformMatrix = geo.affineTransformRotate(this.transformMatrix, -geo.degreesToRadians(this.rotation));
            }
            if (!(this.scaleX == 1 && this.scaleY == 1)) {
                this.transformMatrix = geo.affineTransformScale(this.transformMatrix, this.scaleX, this.scaleY);
            }

            if (!geo.pointEqualToPoint(this.anchorPointInPixels, ccp(0, 0))) {
                this.transformMatrix = geo.affineTransformTranslate(this.transformMatrix, -this.anchorPointInPixels.x, -this.anchorPointInPixels.y);
            }

            this.set('isTransformDirty', false);

        }

        return this.transformMatrix;
    },

    parentToNodeTransform: function () {
        // TODO
    },

    nodeToWorldTransform: function () {
        var t = this.nodeToParentTransform();

        var p;
        for (p = this.get('parent'); p; p = p.get('parent')) {
            t = geo.affineTransformConcat(t, p.nodeToParentTransform());
        }

        return t;
    },

    worldToNodeTransform: function () {
        return geo.affineTransformInvert(this.nodeToWorldTransform());
    },

    convertToNodeSpace: function (worldPoint) {
        return geo.pointApplyAffineTransform(worldPoint, this.worldToNodeTransform());
    },

    /**
     * @getter boundingBox
     * @type geometry.Rect
     */
    get_boundingBox: function () {
        var cs = this.get('contentSize');
        var rect = geo.rectMake(0, 0, cs.width, cs.height);
        rect = geo.rectApplyAffineTransform(rect, this.nodeToParentTransform());
        return rect;
    },

    /**
     * @getter worldBoundingBox
     * @type geometry.Rect
     */
    get_worldBoundingBox: function () {
        var cs = this.get('contentSize');

        var rect = geo.rectMake(0, 0, cs.width, cs.height);
        rect = geo.rectApplyAffineTransform(rect, this.nodeToWorldTransform());
        return rect;
    },

    /**
     * The area of the node currently visible on screen. Returns an rect even
     * if visible is false.
     *
     * @getter visibleRect
     * @type geometry.Rect
     */
    get_visibleRect: function () {
        var s = require('../Director').Director.get('sharedDirector').get('winSize');
        var rect = new geo.Rect(
            0, 0,
            s.width, s.height
        );

        return geo.rectApplyAffineTransform(rect, this.worldToNodeTransform());
    },

    /**
     * @private
     */
    _dirtyTransform: function () {
        this.set('isTransformDirty', true);
    },

    /**
     * Schedules a custom method with an interval time in seconds.
     * If time is 0 it will be ticked every frame.
     * If time is 0, it is recommended to use 'scheduleUpdate' instead.
     * 
     * If the method is already scheduled, then the interval parameter will
     * be updated without scheduling it again.
     *
     * @opt {String|Function} method Function of method name to schedule
     * @opt {Float} [interval=0] Interval in seconds
     */
    schedule: function (opts) {
        if (typeof opts == 'string') {
            return this.schedule({method: opts, interval: 0});
        }

        opts.interval = opts.interval || 0;

        Scheduler.get('sharedScheduler').schedule({target: this, method: opts.method, interval: opts.interval, paused: this.isRunning});
    },

    /**
     * Unschedules a custom method
     *
     * @param {String|Function} method
     */
    unschedule: function (method) {
        if (!method) {
            return;
        }

        if (typeof method == 'string') {
            method = this[method];
        }
        
        Scheduler.get('sharedScheduler').unschedule({target: this, method: method});
    }

});

module.exports.Node = Node;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/PreloadScene.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var Scene       = require('./Scene').Scene,
    Director    = require('../Director').Director,
    Label       = require('./Label').Label,
    ProgressBar = require('./ProgressBar').ProgressBar,
    Preloader   = require('../Preloader').Preloader,
    RemoteResource = require('../RemoteResource').RemoteResource,
    geo         = require('geometry'),
    util        = require('util'),
    events      = require('events');

var PreloadScene = Scene.extend(/** @lends cocos.nodes.PreloadScene# */{
    progressBar: null,
    label: null,
    preloader: null,
    isReady: false, // True when both progress bar images have loaded
    emptyImage: "/__builtin__/libs/cocos2d/resources/progress-bar-empty.png",
    fullImage:  "/__builtin__/libs/cocos2d/resources/progress-bar-full.png",

    /**
     * @memberOf cocos.nodes
     * @extends cocos.nodes.Scene
     * @constructs
     */
    init: function (opts) {
        PreloadScene.superclass.init.call(this, opts);
        var size = Director.get('sharedDirector').get('winSize');

        // Setup 'please wait' label
        var label = Label.create({
            fontSize: 14,
            fontName: 'Helvetica',
            fontColor: '#ffffff',
            string: 'Please wait...'
        });
        label.set('position', new geo.Point(size.width / 2, (size.height / 2) + 32));
        this.set('label', label);
        this.addChild({child: label});

        // Setup preloader
        var preloader = Preloader.create();
        this.set('preloader', preloader);
        var self = this;

        // Listen for preload events
        events.addListener(preloader, 'load', function (uri, preloader) {
            var loaded = preloader.get('loaded'),
                count = preloader.get('count');
            //console.log("Loaded: %d%% -- %d of %d -- %s", (loaded / count) * 100, loaded, count, uri);
            events.trigger(self, 'load', uri, preloader);
        });

        events.addListener(preloader, 'complete', function (preloader) {
            events.trigger(self, 'complete', preloader);
        });


        // Load the images used by the progress bar
        var emptyImage = resource(this.get('emptyImage')),
            fullImage  = resource(this.get('fullImage'));


        var loaded = 0;
        function imageLoaded() {
            if (loaded == 2) {
                this.isReady = true;
                this.createProgressBar();
                if (this.get('isRunning')) {
                    preloader.load();
                }
            }
        }

        if (emptyImage instanceof RemoteResource) {
            events.addListener(emptyImage, 'load', util.callback(this, function() {
                loaded++;
                imageLoaded.call(this);
            }));
            emptyImage.load();
        } else {
            loaded++;
            imageLoaded.call(this);
        }
        if (fullImage instanceof RemoteResource) {
            events.addListener(fullImage, 'load', util.callback(this, function() {
                loaded++;
                imageLoaded.call(this);
            }));
            fullImage.load();
        } else {
            loaded++;
            imageLoaded.call(this);
        }

    },

    createProgressBar: function () {
        var preloader = this.get('preloader'),
            size = Director.get('sharedDirector').get('winSize');

        var progressBar = ProgressBar.create({
            emptyImage: "/__builtin__/libs/cocos2d/resources/progress-bar-empty.png",
            fullImage:  "/__builtin__/libs/cocos2d/resources/progress-bar-full.png"
        });

        progressBar.set('position', new geo.Point(size.width / 2, size.height / 2));

        this.set('progressBar', progressBar);
        this.addChild({child: progressBar});

        progressBar.bindTo('maxValue', preloader, 'count');
        progressBar.bindTo('value',    preloader, 'loaded');
    },

    onEnter: function () {
        PreloadScene.superclass.onEnter.call(this);
        var preloader = this.get('preloader');

        // Preload everything
        if (this.isReady) {
            preloader.load();
        }
    }
});

exports.PreloadScene = PreloadScene;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/ProgressBar.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var Node   = require('./Node').Node,
    util   = require('util'),
    geo    = require('geometry'),
    events = require('events'),
    Sprite = require('./Sprite').Sprite;

var ProgressBar = Node.extend(/** @lends cocos.nodes.ProgressBar# */{
    emptySprite: null,
    fullSprite: null,
    maxValue: 100,
    value: 0,

    /**
     * @memberOf cocos.nodes
     * @extends cocos.nodes.Node
     * @constructs
     */
    init: function (opts) {
        ProgressBar.superclass.init.call(this, opts);
        var size = new geo.Size(272, 32);
        this.set('contentSize', size);

        var s;
        if (opts.emptyImage) {
            s = Sprite.create({file: opts.emptyImage, rect: new geo.Rect(0, 0, size.width, size.height)});
            s.set('anchorPoint', new geo.Point(0, 0));
            this.set('emptySprite', s);
            this.addChild({child: s});
        }
        if (opts.fullImage) {
            s = Sprite.create({file: opts.fullImage, rect: new geo.Rect(0, 0, 0, size.height)});
            s.set('anchorPoint', new geo.Point(0, 0));
            this.set('fullSprite', s);
            this.addChild({child: s});
        }

        events.addListener(this, 'maxvalue_changed', util.callback(this, 'updateImages'));
        events.addListener(this, 'value_changed', util.callback(this, 'updateImages'));

        this.updateImages();
    },

    updateImages: function () {
        var empty = this.get('emptySprite'),
            full  = this.get('fullSprite'),
            value = this.get('value'),
            size  = this.get('contentSize'),
            maxValue = this.get('maxValue'),
            ratio = (value / maxValue);

        var diff = Math.round(size.width * ratio);
        if (diff === 0) {
            full.set('visible', false);
        } else {
            full.set('visible', true);
            full.set('rect', new geo.Rect(0, 0, diff, size.height));
            full.set('contentSize', new geo.Size(diff, size.height));
        }

        if ((size.width - diff) === 0) {
            empty.set('visible', false);
        } else {
            empty.set('visible', true);
            empty.set('rect', new geo.Rect(diff, 0, size.width - diff, size.height));
            empty.set('position', new geo.Point(diff, 0));
            empty.set('contentSize', new geo.Size(size.width - diff, size.height));
        }
    }
});

exports.ProgressBar = ProgressBar;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/RenderTexture.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    evt = require('events'),
    Node = require('./Node').Node,
    geo = require('geometry'),
    Sprite = require('./Sprite').Sprite,
    TextureAtlas = require('../TextureAtlas').TextureAtlas,
    ccp = geo.ccp;

var RenderTexture = Node.extend(/** @lends cocos.nodes.RenderTexture# */{
    canvas: null,
    context: null,
    sprite: null,

    /** 
     * An in-memory canvas which can be drawn to in the background before drawing on screen
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {Integer} width The width of the canvas
     * @opt {Integer} height The height of the canvas
     */
    init: function (opts) {
        RenderTexture.superclass.init.call(this, opts);

        var width = opts.width,
            height = opts.height;

        evt.addListener(this, 'contentsize_changed', util.callback(this, this._resizeCanvas));

        this.canvas = document.createElement('canvas');
        this.context = this.canvas.getContext('2d');

        var atlas = TextureAtlas.create({canvas: this.canvas});
        this.sprite = Sprite.create({textureAtlas: atlas, rect: {origin: ccp(0, 0), size: {width: width, height: height}}});

        this.set('contentSize', geo.sizeMake(width, height));
        this.addChild(this.sprite);
        this.set('anchorPoint', ccp(0, 0));
        this.sprite.set('anchorPoint', ccp(0, 0));

    },

    /**
     * @private
     */
    _resizeCanvas: function () {
        var size = this.get('contentSize'),
            canvas = this.get('canvas');

        canvas.width  = size.width;
        canvas.height = size.height;
        if (FLIP_Y_AXIS) {
            this.context.scale(1, -1);
            this.context.translate(0, -canvas.height);
        }

        var s = this.get('sprite');
        if (s) {
            s.set('textureRect', {rect: geo.rectMake(0, 0, size.width, size.height)});
        }
    },

    /**
     * Clear the canvas
     */
    clear: function (rect) {
        if (rect) {
            this.context.clearRect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
        } else {
            this.canvas.width = this.canvas.width;
            if (FLIP_Y_AXIS) {
                this.context.scale(1, -1);
                this.context.translate(0, -this.canvas.height);
            }
        }
    }
});

module.exports.RenderTexture = RenderTexture;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Scene.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var Node = require('./Node').Node,
    geo = require('geometry');

var Scene = Node.extend(/** @lends cocos.nodes.Scene */{
    /**
     * Everything in your view will be a child of this object. You need at least 1 scene per app.
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     */
    init: function () {
        Scene.superclass.init.call(this);


        var Director = require('../Director').Director;
        var s = Director.get('sharedDirector').get('winSize');
        this.set('isRelativeAnchorPoint', false);
        this.anchorPoint = new geo.Point(0.5, 0.5);
        this.set('contentSize', s);
    }

});

module.exports.Scene = Scene;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Sprite.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    evt = require('events'),
    Director = require('../Director').Director,
    TextureAtlas = require('../TextureAtlas').TextureAtlas,
    Node = require('./Node').Node,
    geo = require('geometry'),
    ccp = geo.ccp;

var Sprite = Node.extend(/** @lends cocos.nodes.Sprite# */{
    textureAtlas: null,
    rect: null,
    dirty: true,
    recursiveDirty: true,
    quad: null,
    flipX: false,
    flipY: false,
    offsetPosition: null,
    unflippedOffsetPositionFromCenter: null,
    untrimmedSize: null,

    /**
     * A small 2D graphics than can be animated
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {String} file Path to image to use as sprite atlas
     * @opt {Rect} [rect] The rect in the sprite atlas image file to use as the sprite
     */
    init: function (opts) {
        Sprite.superclass.init.call(this, opts);

        opts = opts || {};

        var file         = opts.file,
            textureAtlas = opts.textureAtlas,
            texture      = opts.texture,
            frame        = opts.frame,
            spritesheet  = opts.spritesheet,
            rect         = opts.rect;

        this.set('offsetPosition', ccp(0, 0));
        this.set('unflippedOffsetPositionFromCenter', ccp(0, 0));


        if (frame) {
            texture = frame.get('texture');
            rect    = frame.get('rect');
        }

        util.each(['scale', 'scaleX', 'scaleY', 'rect', 'flipX', 'flipY', 'contentSize'], util.callback(this, function (key) {
            evt.addListener(this, key.toLowerCase() + '_changed', util.callback(this, this._updateQuad));
        }));
        evt.addListener(this, 'textureatlas_changed', util.callback(this, this._updateTextureQuad));

        if (file || texture) {
            textureAtlas = TextureAtlas.create({file: file, texture: texture});
        } else if (spritesheet) {
            textureAtlas = spritesheet.get('textureAtlas');
            this.set('useSpriteSheet', true);
        } else if (!textureAtlas) {
            //throw "Sprite has no texture";
        }

        if (!rect && textureAtlas) {
            rect = {origin: ccp(0, 0), size: {width: textureAtlas.texture.size.width, height: textureAtlas.texture.size.height}};
        }

        if (rect) {
            this.set('rect', rect);
            this.set('contentSize', rect.size);

            this.quad = {
                drawRect: {origin: ccp(0, 0), size: rect.size},
                textureRect: rect
            };
        }

        this.set('textureAtlas', textureAtlas);

        if (frame) {
            this.set('displayFrame', frame);
        }
    },

    /**
     * @private
     */
    _updateTextureQuad: function (obj, key, texture, oldTexture) {
        if (oldTexture) {
            oldTexture.removeQuad({quad: this.get('quad')});
        }

        if (texture) {
            texture.insertQuad({quad: this.get('quad')});
        }
    },

    /**
     * @setter textureCoords
     * @type geometry.Rect
     */
    set_textureCoords: function (rect) {
        var quad = this.get('quad');
        if (!quad) {
            quad = {
                drawRect: geo.rectMake(0, 0, 0, 0), 
                textureRect: geo.rectMake(0, 0, 0, 0)
            };
        }

        quad.textureRect = util.copy(rect);

        this.set('quad', quad);
    },

    /**
     * @setter textureRect
     * @type geometry.Rect
     */
    set_textureRect: function (opts) {
        var rect = opts.rect,
            rotated = !!opts.rotated,
            untrimmedSize = opts.untrimmedSize || rect.size;

        this.set('contentSize', untrimmedSize);
        this.set('rect', util.copy(rect));
        this.set('textureCoords', rect);

        var quad = this.get('quad');

        var relativeOffset = util.copy(this.get('unflippedOffsetPositionFromCenter'));

        if (this.get('flipX')) {
            relativeOffset.x = -relativeOffset.x;
        }
        if (this.get('flipY')) {
            relativeOffset.y = -relativeOffset.y;
        }

        var offsetPosition = util.copy(this.get('offsetPosition'));
        offsetPosition.x =  relativeOffset.x + (this.get('contentSize').width  - rect.size.width) / 2;
        offsetPosition.y = -relativeOffset.y + (this.get('contentSize').height - rect.size.height) / 2;

        quad.drawRect.origin = util.copy(offsetPosition);
        quad.drawRect.size = util.copy(rect.size);
        if (this.flipX) {
            quad.drawRect.size.width *= -1;
            quad.drawRect.origin.x = -rect.size.width;
        }
        if (this.flipY) {
            quad.drawRect.size.height *= -1;
            quad.drawRect.origin.y = -rect.size.height;
        }

        this.set('quad', quad);
    },

    /**
     * @private
     */
    _updateQuad: function () {
        if (!this.get('rect')) {
            return;
        }
        if (!this.quad) {
            this.quad = {
                drawRect: geo.rectMake(0, 0, 0, 0), 
                textureRect: geo.rectMake(0, 0, 0, 0)
            };
        }

        var relativeOffset = util.copy(this.get('unflippedOffsetPositionFromCenter'));

        if (this.get('flipX')) {
            relativeOffset.x = -relativeOffset.x;
        }
        if (this.get('flipY')) {
            relativeOffset.y = -relativeOffset.y;
        }

        var offsetPosition = util.copy(this.get('offsetPosition'));
        offsetPosition.x = relativeOffset.x + (this.get('contentSize').width  - this.get('rect').size.width) / 2;
        offsetPosition.y = relativeOffset.y + (this.get('contentSize').height - this.get('rect').size.height) / 2;

        this.quad.textureRect = util.copy(this.rect);
        this.quad.drawRect.origin = util.copy(offsetPosition);
        this.quad.drawRect.size = util.copy(this.rect.size);

        if (this.flipX) {
            this.quad.drawRect.size.width *= -1;
            this.quad.drawRect.origin.x = -this.rect.size.width;
        }
        if (this.flipY) {
            this.quad.drawRect.size.height *= -1;
            this.quad.drawRect.origin.y = -this.rect.size.height;
        }
    },

    updateTransform: function (ctx) {
        if (!this.useSpriteSheet) {
            throw "updateTransform is only valid when Sprite is being rendered using a SpriteSheet";
        }

        if (!this.visible) {
            this.set('dirty', false);
            this.set('recursiveDirty', false);
            return;
        }

        // TextureAtlas has hard reference to this quad so we can just update it directly
        this.quad.drawRect.origin = {
            x: this.position.x - this.anchorPointInPixels.x * this.scaleX,
            y: this.position.y - this.anchorPointInPixels.y * this.scaleY
        };
        this.quad.drawRect.size = {
            width: this.rect.size.width * this.scaleX,
            height: this.rect.size.height * this.scaleY
        };

        this.set('dirty', false);
        this.set('recursiveDirty', false);
    },

    draw: function (ctx) {
        if (!this.quad) {
            return;
        }
        this.get('textureAtlas').drawQuad(ctx, this.quad);
    },

    isFrameDisplayed: function (frame) {
        if (!this.rect || !this.textureAtlas) {
            return false;
        }
        return (frame.texture === this.textureAtlas.texture && geo.rectEqualToRect(frame.rect, this.rect));
    },


    /**
     * @setter displayFrame
     * @type cocos.SpriteFrame
     */
    set_displayFrame: function (frame) {
        if (!frame) {
            delete this.quad;
            return;
        }
        this.set('unflippedOffsetPositionFromCenter', util.copy(frame.offset));


        // change texture
        if (!this.textureAtlas || frame.texture !== this.textureAtlas.texture) {
            this.set('textureAtlas', TextureAtlas.create({texture: frame.texture}));
        }

        this.set('textureRect', {rect: frame.rect, rotated: frame.rotated, untrimmedSize: frame.originalSize});
    }
});

module.exports.Sprite = Sprite;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/TMXLayer.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    SpriteBatchNode = require('./BatchNode').SpriteBatchNode,
    Sprite = require('./Sprite').Sprite,
    TMXOrientationOrtho = require('../TMXOrientation').TMXOrientationOrtho,
    TMXOrientationHex   = require('../TMXOrientation').TMXOrientationHex,
    TMXOrientationIso   = require('../TMXOrientation').TMXOrientationIso,
    geo    = require('geometry'),
    ccp    = geo.ccp,
    Node = require('./Node').Node;

var TMXLayer = SpriteBatchNode.extend(/** @lends cocos.nodes.TMXLayer# */{
    layerSize: null,
    layerName: '',
    tiles: null,
    tilset: null,
    layerOrientation: 0,
    mapTileSize: null,
    properties: null,

    /** 
     * A tile map layer loaded from a TMX file. This will probably automatically be made by cocos.TMXTiledMap
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.SpriteBatchNode
     *
     * @opt {cocos.TMXTilesetInfo} tilesetInfo
     * @opt {cocos.TMXLayerInfo} layerInfo
     * @opt {cocos.TMXMapInfo} mapInfo
     */
    init: function (opts) {
        var tilesetInfo = opts.tilesetInfo,
            layerInfo = opts.layerInfo,
            mapInfo = opts.mapInfo;

        var size = layerInfo.get('layerSize'),
            totalNumberOfTiles = size.width * size.height;

        var tex = null;
        if (tilesetInfo) {
            tex = tilesetInfo.sourceImage;
        }

        TMXLayer.superclass.init.call(this, {file: tex});

        this.set('anchorPoint', ccp(0, 0));

        this.layerName = layerInfo.get('name');
        this.layerSize = layerInfo.get('layerSize');
        this.tiles = layerInfo.get('tiles');
        this.minGID = layerInfo.get('minGID');
        this.maxGID = layerInfo.get('maxGID');
        this.opacity = layerInfo.get('opacity');
        this.properties = util.copy(layerInfo.properties);

        this.tileset = tilesetInfo;
        this.mapTileSize = mapInfo.get('tileSize');
        this.layerOrientation = mapInfo.get('orientation');

        var offset = this.calculateLayerOffset(layerInfo.get('offset'));
        this.set('position', offset);

        this.set('contentSize', geo.sizeMake(this.layerSize.width * this.mapTileSize.width, (this.layerSize.height * (this.mapTileSize.height - 1)) + this.tileset.tileSize.height));
    },

    calculateLayerOffset: function (pos) {
        var ret = ccp(0, 0);

        switch (this.layerOrientation) {
        case TMXOrientationOrtho:
            ret = ccp(pos.x * this.mapTileSize.width, pos.y * this.mapTileSize.height);
            break;
        case TMXOrientationIso:
            // TODO
            break;
        case TMXOrientationHex:
            // TODO
            break;
        }

        return ret;
    },

    setupTiles: function () {
        this.tileset.bindTo('imageSize', this.get('texture'), 'contentSize');


        for (var y = 0; y < this.layerSize.height; y++) {
            for (var x = 0; x < this.layerSize.width; x++) {
                
                var pos = x + this.layerSize.width * y,
                    gid = this.tiles[pos];
                
                if (gid !== 0) {
                    this.appendTile({gid: gid, position: ccp(x, y)});
                    
                    // Optimization: update min and max GID rendered by the layer
                    this.minGID = Math.min(gid, this.minGID);
                    this.maxGID = Math.max(gid, this.maxGID);
                }
            }
        }
    },
    appendTile: function (opts) {
        var gid = opts.gid,
            pos = opts.position;

        var z = pos.x + pos.y * this.layerSize.width;
            
        var rect = this.tileset.rectForGID(gid);
        var tile = Sprite.create({rect: rect, textureAtlas: this.textureAtlas});
        tile.set('position', this.positionAt(pos));
        tile.set('anchorPoint', ccp(0, 0));
        tile.set('opacity', this.get('opacity'));
        
        this.addChild({child: tile, z: 0, tag: z});
    },
    positionAt: function (pos) {
        switch (this.layerOrientation) {
        case TMXOrientationOrtho:
            return this.positionForOrthoAt(pos);
        case TMXOrientationIso:
            return this.positionForIsoAt(pos);
        /*
        case TMXOrientationHex:
            // TODO
        */
        default:
            return ccp(0, 0);
        }
    },
    positionForOrthoAt: function (pos) {
        var overlap = this.mapTileSize.height - this.tileset.tileSize.height;
        var x = Math.floor(pos.x * this.mapTileSize.width + 0.49);
        var y;
        if (FLIP_Y_AXIS) {
            y = Math.floor((this.get('layerSize').height - pos.y - 1) * this.mapTileSize.height + 0.49);
        } else {
            y = Math.floor(pos.y * this.mapTileSize.height + 0.49) + overlap;
        }
        return ccp(x, y);
    },

    positionForIsoAt: function (pos) {
        var mapTileSize = this.get('mapTileSize'),
            layerSize = this.get('layerSize');

        if (FLIP_Y_AXIS) {
            return ccp(
                mapTileSize.width  / 2 * (layerSize.width + pos.x - pos.y - 1),
                mapTileSize.height / 2 * ((layerSize.height * 2 - pos.x - pos.y) - 2)
            );
        } else {
            throw "Isometric tiles without FLIP_Y_AXIS is currently unsupported";
        }
    },

    /**
     * Get the tile at a specifix tile coordinate
     *
     * @param {geometry.Point} pos Position of tile to get in tile coordinates (not pixels)
     * @returns {cocos.nodes.Sprite} The tile
     */
    tileAt: function (pos) {
        var layerSize = this.get('layerSize'),
            tiles = this.get('tiles');

        if (pos.x < 0 || pos.y < 0 || pos.x >= layerSize.width || pos.y >= layerSize.height) {
            throw "TMX Layer: Invalid position";
        }

        var tile,
            gid = this.tileGIDAt(pos);

        // if GID is 0 then no tile exists at that point
        if (gid) {
            var z = pos.x + pos.y * layerSize.width;
            tile = this.getChild({tag: z});
        }

        return tile;
    },


    tileGID: function (pos) {
        var tilesPerRow = this.get('layerSize').width,
            tilePos = pos.x + (pos.y * tilesPerRow);

        return this.tiles[tilePos];
    },
    tileGIDAt: function (pos) {
        return this.tileGID(pos);
    },

    removeTile: function (pos) {
        var gid = this.tileGID(pos);
        if (gid === 0) {
            // Tile is already blank
            return;
        }

        var tiles = this.get('tiles'),
            tilesPerRow = this.get('layerSize').width,
            tilePos = pos.x + (pos.y * tilesPerRow);


        tiles[tilePos] = 0;

        var sprite = this.getChild({tag: tilePos});
        if (sprite) {
            this.removeChild({child: sprite});
        }
    }
});

exports.TMXLayer = TMXLayer;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/TMXTiledMap.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray console*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    geo = require('geometry'),
    ccp = geo.ccp,
    Node = require('./Node').Node,
    TMXOrientationOrtho = require('../TMXOrientation').TMXOrientationOrtho,
    TMXOrientationHex   = require('../TMXOrientation').TMXOrientationHex,
    TMXOrientationIso   = require('../TMXOrientation').TMXOrientationIso,
    TMXLayer   = require('./TMXLayer').TMXLayer,
    TMXMapInfo = require('../TMXXMLParser').TMXMapInfo;

var TMXTiledMap = Node.extend(/** @lends cocos.nodes.TMXTiledMap# */{
    mapSize: null,
    tileSize: null,
    mapOrientation: 0,
    objectGroups: null,
    properties: null,
    tileProperties: null,

    /**
     * A TMX Map loaded from a .tmx file
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {String} file The file path of the TMX map to load
     */
    init: function (opts) {
        TMXTiledMap.superclass.init.call(this, opts);

        this.set('anchorPoint', ccp(0, 0));

        var mapInfo = TMXMapInfo.create(opts.file);

        this.mapSize        = mapInfo.get('mapSize');
        this.tileSize       = mapInfo.get('tileSize');
        this.mapOrientation = mapInfo.get('orientation');
        this.objectGroups   = mapInfo.get('objectGroups');
        this.properties     = mapInfo.get('properties');
        this.tileProperties = mapInfo.get('tileProperties');

        // Add layers to map
        var idx = 0;
        util.each(mapInfo.layers, util.callback(this, function (layerInfo) {
            if (layerInfo.get('visible')) {
                var child = this.parseLayer({layerInfo: layerInfo, mapInfo: mapInfo});
                this.addChild({child: child, z: idx, tag: idx});

                var childSize   = child.get('contentSize');
                var currentSize = this.get('contentSize');
                currentSize.width  = Math.max(currentSize.width,  childSize.width);
                currentSize.height = Math.max(currentSize.height, childSize.height);
                this.set('contentSize', currentSize);

                idx++;
            }
        }));
    },
    
    parseLayer: function (opts) {
        var tileset = this.tilesetForLayer(opts);
        var layer = TMXLayer.create({tilesetInfo: tileset, layerInfo: opts.layerInfo, mapInfo: opts.mapInfo});

        layer.setupTiles();

        return layer;
    },

    tilesetForLayer: function (opts) {
        var layerInfo = opts.layerInfo,
            mapInfo = opts.mapInfo,
            size = layerInfo.get('layerSize');

        // Reverse loop
        var tileset;
        for (var i = mapInfo.tilesets.length - 1; i >= 0; i--) {
            tileset = mapInfo.tilesets[i];

            for (var y = 0; y < size.height; y++) {
                for (var x = 0; x < size.width; x++) {
                    var pos = x + size.width * y, 
                        gid = layerInfo.tiles[pos];

                    if (gid !== 0 && gid >= tileset.firstGID) {
                        return tileset;
                    }
                } // for (var x
            } // for (var y
        } // for (var i

        //console.log("cocos2d: Warning: TMX Layer '%s' has no tiles", layerInfo.name);
        return tileset;
    },

    /**
     * Get a layer
     *
     * @opt {String} name The name of the layer to get
     * @returns {cocos.nodes.TMXLayer} The layer requested
     */
    getLayer: function (opts) {
        var layerName = opts.name,
            layer = null;

        this.get('children').forEach(function (item) {
            if (item instanceof TMXLayer && item.layerName == layerName) {
                layer = item;
            }
        });
        if (layer !== null) {
            return layer;
        }
    },
    
    /**
     * Return the ObjectGroup for the secific group
     *
     * @opt {String} name The object group name
     * @returns {cocos.TMXObjectGroup} The object group
     */
    getObjectGroup: function (opts) {
        var objectGroupName = opts.name,
            objectGroup = null;

        this.objectGroups.forEach(function (item) {
            if (item.name == objectGroupName) {
                objectGroup = item;
            }
        });
        if (objectGroup !== null) {
            return objectGroup;
        }
    },

    /**
     * @deprected Since v0.2. You should now use cocos.TMXTiledMap#getObjectGroup.
     */
    objectGroupNamed: function (opts) {
        console.warn('TMXTiledMap#objectGroupNamed is deprected. Use TMXTiledMap#getObjectGroup instread');
        return this.getObjectGroup(opts);
    }
});

exports.TMXTiledMap = TMXTiledMap;


}};
__resources__["/__builtin__/libs/cocos2d/nodes/Transition.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var geo             = require('geometry'),
    util            = require('util'),
    actions         = require('../actions'),
    Scene           = require('./Scene').Scene,
    Director        = require('../Director').Director,
    EventDispatcher = require('../EventDispatcher').EventDispatcher,
    Scheduler       = require('../Scheduler').Scheduler;

/** Orientation Type used by some transitions
 */
var tOrientation = {
    kOrientationLeftOver: 0,
    kOrientationRightOver: 1,
    kOrientationUpOver: 0,
    kOrientationDownOver: 1
};

/**
 */
var TransitionScene = Scene.extend(/** @lends cocos.nodes.TransitionScene */{
    /**
     * Incoming scene
     * @type {cocos.nodes.Scene}
     */
    inScene: null,

    /**
     * Outgoing (current) scene
     * @type {cocos.nodes.Scene}
     */
    outScene: null,

    /**
     * transition duration
     * @type Float
     */
    duration: null,

    inSceneOnTop: null,
    sendCleanupToScene: null,

    /**
     * @class Base class for Transition scenes
     * @memberOf cocos.nodes
     * @extends cocos.nodes.Scene
     * @constructs
     *
     * @opt {Float} duration How long the transition should last
     * @opt {cocos.nodes.Scene} scene Income scene
     */
    init: function (opts) {
        TransitionScene.superclass.init.call(this, opts);

        this.set('duration', opts.duration);
        if (!opts.scene) {
            throw "TransitionScene requires scene property";
        }
        this.set('inScene', opts.scene);
        this.set('outScene', Director.get('sharedDirector')._runningScene);

        if (this.inScene == this.outScene) {
            throw "Incoming scene must be different from the outgoing scene";
        }
        EventDispatcher.get('sharedDispatcher').set('dispatchEvents', false);
        this.sceneOrder();
    },

    /**
     * Called after the transition finishes
     */
    finish: function () {
        var is = this.get('inScene'),
            os = this.get('outScene');

        /* clean up */
        is.set('visible', true);
        is.set('position', geo.PointZero());
        is.set('scale', 1.0);
        is.set('rotation', 0);

        os.set('visible', false);
        os.set('position', geo.PointZero());
        os.set('scale', 1.0);
        os.set('rotation', 0);

        Scheduler.get('sharedScheduler').schedule({
            target: this,
            method: this.setNewScene,
            interval: 0
        });
    },

    /**
     * Used by some transitions to hide the outer scene
     */
    hideOutShowIn: function () {
        this.get('inScene').set('visible', true);
        this.get('outScene').set('visible', false);
    },
    
    setNewScene: function (dt) {
        var dir = Director.get('sharedDirector');
        
        this.unscheduleSelector(this.setNewScene);
        // Save 'send cleanup to scene'
        // Not sure if it's cool to be accessing all these Director privates like this...
        this.set('sendCleanupToScene', dir._sendCleanupToScene);
        
        dir.replaceScene(this.get('inScene'));
        
        // enable events while transitions
        EventDispatcher.get('sharedDispatcher').set('dispatchEvents', true);

        // issue #267 
        this.get('outScene').set('visible', true);
    },

    sceneOrder: function () {
        this.set('inSceneOnTop', true);
    },

    draw: function (context, rect) {
        if (this.get('inSceneOnTop')) {
            this.get('outScene').visit(context, rect);
            this.get('inScene').visit(context, rect);
        } else {
            this.get('inScene').visit(context, rect);
            this.get('outScene').visit(context, rect);
        }
    },
    
    onEnter: function () {
        TransitionScene.superclass.onEnter.call(this);
        this.get('inScene').onEnter();
        // outScene_ should not receive the onEnter callback
    },

    onExit: function () {
        TransitionScene.superclass.onExit.call(this);
        this.get('outScene').onExit();
        // inScene_ should not receive the onExit callback
        // only the onEnterTransitionDidFinish
        if (this.get('inScene').hasOwnProperty('onEnterTransitionDidFinish')) {
            this.get('inScene').onEnterTransitionDidFinish();
        }
    },

    cleanup: function () {
        TransitionScene.superclass.cleanup.call(this);

        if (this.get('sendCleanupToScene')) {
            this.get('outScene').cleanup();
        }
    }
});

/**
 * @class Rotate and zoom out the outgoing scene, and then rotate and zoom in the incoming 
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionScene
 */
var TransitionRotoZoom = TransitionScene.extend(/** @lends cocos.nodes.TransitionRotoZoom */{
    onEnter: function() {
        TransitionRotoZoom.superclass.onEnter.call(this);
        
        var dur = this.get('duration');
        this.get('inScene').set('scale', 0.001);
        this.get('outScene').set('scale', 1.0);
        
        this.get('inScene').set('anchorPoint', geo.ccp(0.5, 0.5));
        this.get('outScene').set('anchorPoint', geo.ccp(0.5, 0.5));
        
        var outzoom = [
            actions.Spawn.initWithActions({actions: [
                actions.ScaleBy.create({scale: 0.001, duration: dur/2}),
                actions.RotateBy.create({angle: 360*2, duration: dur/2})
                ]}),
            actions.DelayTime.create({duration: dur/2})];
        
        // Can't nest sequences or reverse them very easily, so incoming scene actions must be put 
        // together manually for now...
        var inzoom = [
            actions.DelayTime.create({duration: dur/2}),
            
            actions.Spawn.initWithActions({actions: [
                actions.ScaleTo.create({scale: 1.0, duration: dur/2}),
                actions.RotateBy.create({angle: -360*2, duration: dur/2})
                ]}),
            actions.CallFunc.create({
                target: this,
                method: this.finish
            })
        ];
        
        // Sequence init() copies actions
        this.get('outScene').runAction(actions.Sequence.create({actions: outzoom}));
        this.get('inScene').runAction(actions.Sequence.create({actions: inzoom}));
    }
});

/**
 * @class Move in from to the left the incoming scene.
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionScene
 */
var TransitionMoveInL = TransitionScene.extend(/** @lends cocos.nodes.TransitionMoveInL */{
    onEnter: function () {
        TransitionMoveInL.superclass.onEnter.call(this);

        this.initScenes();

        this.get('inScene').runAction(actions.Sequence.create({actions: [
            this.action(),
            actions.CallFunc.create({
                target: this,
                method: this.finish
            })]
        }));
    },
    
    action: function () {
        return actions.MoveTo.create({
            position: geo.ccp(0, 0),
            duration: this.get('duration')
        });
    },
    
    initScenes: function () {
        var s = Director.get('sharedDirector').get('winSize');
        this.get('inScene').set('position', geo.ccp(-s.width, 0));
    }
});
    
/**
 * @class Move in from to the right the incoming scene.
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionMoveInL
 */
var TransitionMoveInR = TransitionMoveInL.extend(/** @lends cocos.nodes.TransitionMoveInR */{
    initScenes: function () {
        var s = Director.get('sharedDirector').get('winSize');
        this.get('inScene').set('position', geo.ccp(s.width, 0));
    }
});

/**
 * @class Move the incoming scene in from the top.
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionMoveInL
 */
var TransitionMoveInT = TransitionMoveInL.extend(/** @lends cocos.nodes.TransitionMoveInT */{
    initScenes: function () {
        var s = Director.get('sharedDirector').get('winSize');
        this.get('inScene').set('position', geo.ccp(0, s.height));
    }
});

/**
 * @class Move the incoming scene in from the bottom.
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionMoveInL
 */
var TransitionMoveInB = TransitionMoveInL.extend(/** @lends cocos.nodes.TransitionMoveInB */{
    initScenes: function () {
        var s = Director.get('sharedDirector').get('winSize');
        this.get('inScene').set('position', geo.ccp(0, -s.height));
    }
});

/**
 * @class Slide in the incoming scene from the left.
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionScene
 */
var TransitionSlideInL = TransitionScene.extend(/** @lends cocos.nodes.TransitionSlideInL */{
    onEnter: function () {
        TransitionSlideInL.superclass.onEnter.call(this);

        this.initScenes();

        var movein = this.action();
        var moveout = this.action();
        var outAction = actions.Sequence.create({
            actions: [
            moveout, 
            actions.CallFunc.create({
                target: this,
                method: this.finish
            })]
        });
        this.get('inScene').runAction(movein);
        this.get('outScene').runAction(outAction);
    },

    sceneOrder: function () {
        this.set('inSceneOnTop', false);
    },

    initScenes: function () {
        var s = Director.get('sharedDirector').get('winSize');
        this.get('inScene').set('position', geo.ccp(-s.width, 0));
    },
    
    action: function () {
        var s = Director.get('sharedDirector').get('winSize');
        return actions.MoveBy.create({
            position: geo.ccp(s.width, 0),
            duration: this.get('duration')
        });
    }
});

/** 
 * @class Slide in the incoming scene from the right.
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionSlideInL
 */
var TransitionSlideInR = TransitionSlideInL.extend(/** @lends cocos.nodes.TransitionSlideInR */{
    sceneOrder: function () {
        this.set('inSceneOnTop', true);
    },

    initScenes: function () {
        var s = Director.get('sharedDirector').get('winSize');
        this.get('inScene').set('position', geo.ccp(s.width, 0));
    },
    
    action: function () {
        var s = Director.get('sharedDirector').get('winSize');
        return actions.MoveBy.create({
            position: geo.ccp(-s.width, 0),
            duration: this.get('duration')
        });
    }
});

/**
 * @class Slide in the incoming scene from the top.
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionSlideInL
 */
var TransitionSlideInT = TransitionSlideInL.extend(/** @lends cocos.nodes.TransitionSlideInT */{
    sceneOrder: function () {
        this.set('inSceneOnTop', false);
    },

    initScenes: function () {
        var s = Director.get('sharedDirector').get('winSize');
        this.get('inScene').set('position', geo.ccp(0, s.height));
    },
    
    action: function () {
        var s = Director.get('sharedDirector').get('winSize');
        return actions.MoveBy.create({
            position: geo.ccp(0, -s.height),
            duration: this.get('duration')
        });
    }
});

/**
 * @class Slide in the incoming scene from the bottom.
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionSlideInL
 */
var TransitionSlideInB = TransitionSlideInL.extend(/** @lends cocos.nodes.TransitionSlideInB */{
    sceneOrder: function () {
        this.set('inSceneOnTop', true);
    },

    initScenes: function () {
        var s = Director.get('sharedDirector').get('winSize');
        this.get('inScene').set('position', geo.ccp(0, -s.height));
    },
    
    action: function () {
        var s = Director.get('sharedDirector').get('winSize');
        return actions.MoveBy.create({
            position: geo.ccp(0, s.height),
            duration: this.get('duration')
        });
    }
});

exports.TransitionScene = TransitionScene;
exports.TransitionRotoZoom = TransitionRotoZoom;
exports.TransitionMoveInL = TransitionMoveInL;
exports.TransitionMoveInR = TransitionMoveInR;
exports.TransitionMoveInT = TransitionMoveInT;
exports.TransitionMoveInB = TransitionMoveInB;
exports.TransitionSlideInL = TransitionSlideInL;
exports.TransitionSlideInR = TransitionSlideInR;
exports.TransitionSlideInT = TransitionSlideInT;
exports.TransitionSlideInB = TransitionSlideInB;

}};
__resources__["/__builtin__/libs/cocos2d/Preloader.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    events = require('events');

var Preloader = BObject.extend(/** @lends cocos.Preloader# */{
    /**
     * Total number of resources.
     * @type Integer
     */
    count: -1,

    /**
     * Number of resources that have finished loading
     * @type Integer
     */
    loaded: 0,

    _listeners: null,

    /**
     * @class Preloads all remote resources
     * @memberOf cocos
     * @extends BObject
     * @constructs
     */
    init: function (opts) {
        Preloader.superclass.init.call(this, opts);

        this._listeners = {};
        this.set('count', Object.keys(__remote_resources__).length);
    },

    load: function() {
        this.set('loaded', 0);
        this.set('count', Object.keys(__remote_resources__).length);

        for (var uri in __remote_resources__) {
            if (__remote_resources__.hasOwnProperty(uri)) {
                if (__resources__[uri]) {
                    // Already loaded
                    this.didLoadResource(uri);
                    continue;
                }
                var file = resource(uri);

                // Notify when a resource has loaded
                this._listeners[uri] = events.addListener(file, 'load', util.callback(this, (function(uri) {
                    return function () { this.didLoadResource(uri); };
                })(uri)));

                file.load()
            }
        }
    },
    
    didLoadResource: function(uri) {
        this.set('loaded', this.get('loaded') +1);
        if (this._listeners[uri]) {
            events.removeListener(this._listeners[uri]);
        }
        events.trigger(this, 'load', uri, this);

        if (this.get('loaded') >= this.get('count')) {
            events.trigger(this, 'complete', this);
        }
    }
});

exports.Preloader = Preloader;

}};
__resources__["/__builtin__/libs/cocos2d/RemoteImage.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    events = require('events'),
    RemoteResource = require('./RemoteResource').RemoteResource;

var RemoteImage = RemoteResource.extend(/** @lends cocos.RemoteImage# */{
    /**
     * @memberOf cocos
     * @extends cocos.RemoteResource
     * @constructs
     */
    init: function (opts) {
        RemoteImage.superclass.init.call(this, opts);
    },

    /**
     * Load a remote image
     * @returns Image
     */
    load: function () {
        var img = new Image();
        var self = this;
        img.onload = function () {
            var path = self.get('path');

            var r = __remote_resources__[path];
            __resources__[path] = util.copy(r);
            __resources__[path].data = img;
            __resources__[path].meta.remote = true;

            events.trigger(self, 'load', self);
        };
        
        img.src = this.get('url');

        return img;
    }
});

exports.RemoteImage = RemoteImage;

}};
__resources__["/__builtin__/libs/cocos2d/RemoteResource.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    events = require('events');

var RemoteResource = BObject.extend(/** @lends cocos.RemoteResource# */{
    /**
     * The URL to the remote resource
     * @type String
     */
    url: null,

    /**
     * The path used to reference the resource in the app
     * @type String
     */
    path: null,

    /**
     * @memberOf cocos
     * @extends BObject
     * @constructs
     */
    init: function (opts) {
        RemoteResource.superclass.init.call(this, opts);

        this.set('url', opts.url);
        this.set('path', opts.path);
        
    },

    /**
     * Load the remote resource via ajax
     */
    load: function () {
        var self = this;

        $.ajax({
            url: this.get('url'),
            success: function (data) {
                var path = self.get('path');
                
                var r = __remote_resources__[path];
                __resources__[path] = util.copy(r);
                __resources__[path].data = data;
                __resources__[path].meta.remote = true;

                events.trigger(self, 'load', self);
            },
            error: function(jqXHR, textStatus, errorThrown) {
                events.trigger(self, 'fail', textStatus, errorThrown);
            }
        });
    }
});


exports.RemoteResource = RemoteResource;

}};
__resources__["/__builtin__/libs/cocos2d/resources/progress-bar-empty.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARAAAAAgCAYAAADaBycMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAwRJREFUeNrsnbFLW1EUxm9cpP0HLDgUC4JDhoJuOggdBYcg7Sw4BSl0K0inItSpUMSp4NxSHAqOBQfdInTIIAQMDoX4D7TNlJ6PnGtOg76mwUXf7wcf5N28LAfy8d6593630uv10ojMmhZNC6aqacY0ZZpMAHBX6ZouTW1T09QwnZhao/y4MoKBLJtqplXTY+oNcO+5MH01HZiOxjWQJ6YN07rpETUFKB0d077po+n8fwzkmemVaSWM6cZvpmPTqenM9MO/+0WtAe4kD0zTpjnTvGnJ//+VcM+h6b3///9pIHpVeZP6vY7MZ9Mnf6QBgPuNWhYvTM/DmHojb/3V5kYDkfO8C+ahx5Zd017qN1sAoBxocqRu2kz9dkY2kdfxSSQaiG76EF5bvpu2TV+oJUBpWTNtmZ6G15mX/nCRJsKNG8E8zjEPAHAP2E6DJuqKe0WKBrKc+rMtmV3MAwCCieyG63X3jCsDUdMkT9WqYbpHzQAgsOfekNwratlAtMJ01b9QQ0SzLTRMASDSdW/ITVN5xqwMRMvT8wpTdVeZqgWA6zhIgxkYecaiDCSu9zimRgBQQPSIBRlINQycUh8AKCB6RFUGMhMGzqgPABQQPWJGC8l+p8GW/IeJfS0AcDPaO/PTP3cnqAcAjIsM5DJcT1MSACggesSlDKQdBuaoDwAUED2iLQNphoF56gMABUSPaMpAGmFgifoAQAHRIxoyEAWoXviA8kBq1AgArqHmHpHcM05kIEpfzilDijFTEhFJ6wAQmXRvyFGH8oxWnsbVGveOf1aMWZ16AUCgngYRhx33jKvt/Eepn76cUYzZGjUDAPeCzXC9757xVyKZotsP/bPiDbcwEQDMw70g56IeulekYQNRZJmi2/OsjDIQd1L/eAd6IgDlYtL/+ztpkIfacI+4OiOGYx0AYJixj3XIcLAUQDm49YOlMhxtCVBuxj7aMrKcOFwboEzcyuHawyh8Wfmp6o0oxUxBRFOJBivAXUZhydqRr0212henXodWp7dG+fEfAQYAt2e24R/QqdsAAAAASUVORK5CYII=")};
__resources__["/__builtin__/libs/cocos2d/resources/progress-bar-full.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARAAAAAgCAYAAADaBycMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA5lJREFUeNrsnT9IlVEYxo8uUdTSYmAQBoKDQ6KTf0BocAgcLpKrgjSIBC1mRVNU6hKEOISgaxENQUNDIKh3UmxwEARFKNClpaicbs/D9x6/t4vR9eJy73l+8MDx3O9zeOE8nO8957ynoVQqhQpphXqgLqgdaoGaoHNBCFGrHEGH0B60Ba1Da9BOJS83VGAg/VABGoSuKd5C1D370HvoHbRcrYFch8agUeiKYipEchxAi9ACtHsaA7kJ3YNuuT4++AlahTagbeir/fZLsRaiJjkPNUNtUCfUa+O/wT3zAXph4/+/BsJPlcchy3VE3kCvbUojhKhvmLIYhm67PuZGntinzT8NhM4z7cyD05Y5aD5kyRYhRBpwcWQcmghZOiOayJSfiXgD4UMv3WfLZ+gp9Nb906vQANQHddg7FxVrIWqWHzZR2IRWoI/QF/f7EPQIuuE+Z+7aO38ZyDPogZt53Hfmwe8hJlRHoG7FXIi6pQgthSxxWnImMuNmIs+hh2w0Wkd/yFZbInPOPC7bZ80rmYcQdU+3jfVpG/vBvGDOPTNqnnFsIEyaxKVaJkzn3cyDM5FJxVWIpJi0sR9XY+bNG4J5RSEaCHeYDtoPnLJwtSUmTMdkHkIkbSJj1j4yb4ifNfSMVhoIt6fHHabMrsalWiZMRxRDIZJmxLwgmDfEFRh6Rg8NxO/3WHXtgaCchxCp021ecJJHdNFA2l3Hhmv3KXZCiDIv8B7RTgNpcR3brt2huAkhyrzAe0QL94H8DvmR/AshP9fyPWiTmBAi22x2ydo8O/PT2keNio0QolpoIIfu72bX3lV4hBBlXuA94pAGsuc62lx7U3ETQpR5gfeIPRrIluvodO0VxU0IUeYF3iO2aCDrrqPXtXkqr6jYCZE0RfOCkzxinQbCAqr71sF6IAVr80jvkuInRNIshfx4f8E8IphnrNFAWH05VhniwRlWIorLujzSO6sYCpEks+YBwTxhOOSH6+gZO3EZl3vcD6zNMmbj1ubBmRmZiBBJmsdMyA/PjYe8xOGBecbxcf7lkFVfjrCM2ZC1v4WsjNmdoJyIEPVO0cb6lI39YF4w4Z5ZNM9QSUMhEufMShoSFVUWQpBTF1WO6FoHIdKm6msd/ExEF0sJUf+c+cVSEV1tKUTaVH21pac/6HJtIVLiTC7XLofFl1k/lbkRVjFjIaKmkG86E0LUHlwc4Yl8HqrluTjmOrg7faeSl/8IMABgRvK9Q/ireQAAAABJRU5ErkJggg==")};
__resources__["/__builtin__/libs/cocos2d/Scheduler.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util');

/** @ignore */
function HashUpdateEntry() {
    this.timers = [];
    this.timerIndex = 0;
    this.currentTimer = null;
    this.currentTimerSalvaged = false;
    this.paused = false;
}

/** @ignore */
function HashMethodEntry() {
    this.timers = [];
    this.timerIndex = 0;
    this.currentTimer = null;
    this.currentTimerSalvaged = false;
    this.paused = false;
}

var Timer = BObject.extend(/** @lends cocos.Timer# */{
    callback: null,
    interval: 0,
    elapsed: -1,

    /**
     * Runs a function repeatedly at a fixed interval
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @opt {Function} callback The function to run at each interval
     * @opt {Float} interval Number of milliseconds to wait between each exectuion of callback
     */
    init: function (opts) {
        Timer.superclass.init(this, opts);

        this.set('callback', opts.callback);
        this.set('interval', opts.interval || 0);
        this.set('elapsed', -1);
    },

    /**
     * @private
     */
    update: function (dt) {
        if (this.elapsed == -1) {
            this.elapsed = 0;
        } else {
            this.elapsed += dt;
        }

        if (this.elapsed >= this.interval) {
            this.callback(this.elapsed);
            this.elapsed = 0;
        }
    }
});


var Scheduler = BObject.extend(/** @lends cocos.Scheduler# */{
    updates0: null,
    updatesNeg: null,
    updatesPos: null,
    hashForUpdates: null,
    hashForMethods: null,
    timeScale: 1.0,

    /**
     * Runs the timers
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     * @singleton
     * @private
     */
    init: function () {
        this.updates0 = [];
        this.updatesNeg = [];
        this.updatesPos = [];
        this.hashForUpdates = {};
        this.hashForMethods = {};
    },

    /**
     * The scheduled method will be called every 'interval' seconds.
     * If paused is YES, then it won't be called until it is resumed.
     * If 'interval' is 0, it will be called every frame, but if so, it recommened to use 'scheduleUpdateForTarget:' instead.
     * If the selector is already scheduled, then only the interval parameter will be updated without re-scheduling it again.
     */
    schedule: function (opts) {
        var target   = opts.target,
            method   = opts.method,
            interval = opts.interval,
            paused   = opts.paused || false;

        var element = this.hashForMethods[target.get('id')];

        if (!element) {
            element = new HashMethodEntry();
            this.hashForMethods[target.get('id')] = element;
            element.target = target;
            element.paused = paused;
        } else if (element.paused != paused) {
            throw "cocos.Scheduler. Trying to schedule a method with a pause value different than the target";
        }

        var timer = Timer.create({callback: util.callback(target, method), interval: interval});
        element.timers.push(timer);
    },

    /**
     * Schedules the 'update' selector for a given target with a given priority.
     * The 'update' selector will be called every frame.
     * The lower the priority, the earlier it is called.
     */
    scheduleUpdate: function (opts) {
        var target   = opts.target,
            priority = opts.priority,
            paused   = opts.paused;

        var i, len;
        var entry = {target: target, priority: priority, paused: paused};
        var added = false;

        if (priority === 0) {
            this.updates0.push(entry);
        } else if (priority < 0) {
            for (i = 0, len = this.updatesNeg.length; i < len; i++) {
                if (priority < this.updatesNeg[i].priority) {
                    this.updatesNeg.splice(i, 0, entry);
                    added = true;
                    break;
                }
            }

            if (!added) {
                this.updatesNeg.push(entry);
            }
        } else /* priority > 0 */{
            for (i = 0, len = this.updatesPos.length; i < len; i++) {
                if (priority < this.updatesPos[i].priority) {
                    this.updatesPos.splice(i, 0, entry);
                    added = true;
                    break;
                }
            }

            if (!added) {
                this.updatesPos.push(entry);
            }
        }

        this.hashForUpdates[target.get('id')] = entry;
    },

    /**
     * 'tick' the scheduler.
     * You should NEVER call this method, unless you know what you are doing.
     */
    tick: function (dt, add) {
        var i, len, x;
        if (this.timeScale != 1.0) {
            dt *= this.timeScale;
        }

        var entry;
        for (i = 0, len = this.updatesNeg.length; i < len; i++) {
            entry = this.updatesNeg[i];
            if (entry && !entry.paused) {
                entry.target.update(dt);
            }
        }

        for (i = 0, len = this.updates0.length; i < len; i++) {
            entry = this.updates0[i];
            if (entry && !entry.paused) {
                entry.target.update(dt);
            }
        }

        for (i = 0, len = this.updatesPos.length; i < len; i++) {
            entry = this.updatesPos[i];
            if (entry && !entry.paused) {
                entry.target.update(dt);
            }
        }

        for (x in this.hashForMethods) {
            if (this.hashForMethods.hasOwnProperty(x)) {
                entry = this.hashForMethods[x];

                if (entry) {
                    for (i = 0, len = entry.timers.length; i < len; i++) {
                        var timer = entry.timers[i];
                        if (timer) {
                            timer.update(dt);
                        }
                    }
                }
            }
        }

    },

    /**
     * Unshedules a selector for a given target.
     * If you want to unschedule the "update", use unscheduleUpdateForTarget.
     */
    unschedule: function (opts) {
        if (!opts.target || !opts.method) {
            return;
        }
        var element = this.hashForMethods[opts.target.get('id')];
        if (element) {
            for (var i=0; i<element.timers.length; i++) {
                // Compare callback function
                if (element.timers[i].callback == util.callback(opts.target, opts.method)) {
                    var timer = element.timers.splice(i, 1);
                    timer = null;
                }
            }
        }
    },

    /**
     * Unschedules the update selector for a given target
     */
    unscheduleUpdateForTarget: function (target) {
        if (!target) {
            return;
        }
        var id = target.get('id'),
            elementUpdate = this.hashForUpdates[id];
        if (elementUpdate) {
            // Remove from updates list
            if (elementUpdate.priority === 0) {
                this.updates0.splice(this.updates0.indexOf(elementUpdate), 1);
            } else if (elementUpdate.priority < 0) {
                this.updatesNeg.splice(this.updatesNeg.indexOf(elementUpdate), 1);
            } else /* priority > 0 */{
                this.updatesPos.splice(this.updatesPos.indexOf(elementUpdate), 1);
            }
        }
        // Release HashMethodEntry object
        this.hashForUpdates[id] = null;
    },

    /**
     * Unschedules all selectors from all targets.
     * You should NEVER call this method, unless you know what you are doing.
     */
    unscheduleAllSelectors: function () {
        var i, x, entry;

        // Custom selectors
        for (x in this.hashForMethods) {
            if (this.hashForMethods.hasOwnProperty(x)) {
                entry = this.hashForMethods[x];
                this.unscheduleAllSelectorsForTarget(entry.target);
            }
        }
        // Updates selectors
        for (i = 0, len = this.updatesNeg.length; i < len; i++) {
            entry = this.updatesNeg[i];
            if (entry) {
                this.unscheduleUpdateForTarget(entry.target);
            }
        }

        for (i = 0, len = this.updates0.length; i < len; i++) {
            entry = this.updates0[i];
            if (entry) {
                this.unscheduleUpdateForTarget(entry.target);
            }
        }

        for (i = 0, len = this.updatesPos.length; i < len; i++) {
            entry = this.updatesPos[i];
            if (entry) {
                this.unscheduleUpdateForTarget(entry.target);
            }
        }
    },

    /**
     * Unschedules all selectors for a given target.
     * This also includes the "update" selector.
     */
    unscheduleAllSelectorsForTarget: function (target) {
        if (!target) {
            return;
        }
        // Custom selector
        var element = this.hashForMethods[target.get('id')];
        if (element) {
            element.paused = true;
            element.timers = []; // Clear all timers
        }
        // Release HashMethodEntry object
        this.hashForMethods[target.get('id')] = null;

        // Update selector
        this.unscheduleUpdateForTarget(target);
    },

    /**
     * Pauses the target.
     * All scheduled selectors/update for a given target won't be 'ticked' until the target is resumed.
     * If the target is not present, nothing happens.
     */

    pauseTarget: function (target) {
        var element = this.hashForMethods[target.get('id')];
        if (element) {
            element.paused = true;
        }

        var elementUpdate = this.hashForUpdates[target.get('id')];
        if (elementUpdate) {
            elementUpdate.paused = true;
        }
    },

    /**
     * Resumes the target.
     * The 'target' will be unpaused, so all schedule selectors/update will be 'ticked' again.
     * If the target is not present, nothing happens.
     */

    resumeTarget: function (target) {
        var element = this.hashForMethods[target.get('id')];
        if (element) {
            element.paused = false;
        }

        var elementUpdate = this.hashForUpdates[target.get('id')];
        //console.log('foo', target.get('id'), elementUpdate);
        if (elementUpdate) {
            elementUpdate.paused = false;
        }
    }
});

util.extend(Scheduler, /** @lends cocos.Scheduler */{
    /**
     * A shared singleton instance of cocos.Scheduler
     * @getter sharedScheduler 
     * @type cocos.Scheduler
     */
    get_sharedScheduler: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});

exports.Timer = Timer;
exports.Scheduler = Scheduler;

}};
__resources__["/__builtin__/libs/cocos2d/SpriteFrame.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    geo = require('geometry'),
    ccp = geo.ccp;

var SpriteFrame = BObject.extend(/** @lends cocos.SpriteFrame# */{
    rect: null,
    rotated: false,
    offset: null,
    originalSize: null,
    texture: null,

    /**
     * Represents a single frame of animation for a cocos.Sprite
     *
     * <p>A SpriteFrame has:<br>
     * - texture: A Texture2D that will be used by the Sprite<br>
     * - rectangle: A rectangle of the texture</p>
     *
     * <p>You can modify the frame of a Sprite by doing:</p>
     * 
     * <code>var frame = SpriteFrame.create({texture: texture, rect: rect});
     * sprite.set('displayFrame', frame);</code>
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @opt {cocos.Texture2D} texture The texture to draw this frame using
     * @opt {geometry.Rect} rect The rectangle inside the texture to draw
     */
    init: function (opts) {
        SpriteFrame.superclass.init(this, opts);

        this.texture      = opts.texture;
        this.rect         = opts.rect;
        this.rotated      = !!opts.rotate;
        this.offset       = opts.offset || ccp(0, 0);
        this.originalSize = opts.originalSize || util.copy(this.rect.size);
    },

    /**
     * @ignore
     */
    toString: function () {
        return "[object SpriteFrame | TextureName=" + this.texture.get('name') + ", Rect = (" + this.rect.origin.x + ", " + this.rect.origin.y + ", " + this.rect.size.width + ", " + this.rect.size.height + ")]";
    },

    /**
     * Make a copy of this frame
     *
     * @returns {cocos.SpriteFrame} Exact copy of this object
     */
    copy: function () {
        return SpriteFrame.create({rect: this.rect, rotated: this.rotated, offset: this.offset, originalSize: this.originalSize, texture: this.texture});
    }

});

exports.SpriteFrame = SpriteFrame;

}};
__resources__["/__builtin__/libs/cocos2d/SpriteFrameCache.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    geo = require('geometry'),
    Plist = require('Plist').Plist,
    SpriteFrame = require('./SpriteFrame').SpriteFrame,
    Texture2D = require('./Texture2D').Texture2D;

var SpriteFrameCache = BObject.extend(/** @lends cocos.SpriteFrameCache# */{
    /**
     * List of sprite frames
     * @type Object
     */
    spriteFrames: null,

    /**
     * List of sprite frame aliases
     * @type Object
     */
    spriteFrameAliases: null,


    /**
     * @memberOf cocos
     * @extends BObject
     * @constructs
     * @singleton
     */
    init: function () {
        SpriteFrameCache.superclass.init.call(this);

        this.set('spriteFrames', {});
        this.set('spriteFrameAliases', {});
    },

    /**
     * Add SpriteFrame(s) to the cache
     *
     * @param {String} opts.file The filename of a Zwoptex .plist containing the frame definiitons.
     */
    addSpriteFrames: function (opts) {
        var plistPath = opts.file,
            plist = Plist.create({file: plistPath}),
            plistData = plist.get('data');


        var metaDataDict = plistData.metadata,
            framesDict = plistData.frames;

        var format = 0,
            texturePath = null;

        if (metaDataDict) {
            format = metaDataDict.format;
            // Get texture path from meta data
            texturePath = metaDataDict.textureFileName;
        }

        if (!texturePath) {
            // No texture path so assuming it's the same name as the .plist but ending in .png
            texturePath = plistPath.replace(/\.plist$/i, '.png');
        }


        var texture = Texture2D.create({file: texturePath});

        // Add frames
        for (var frameDictKey in framesDict) {
            if (framesDict.hasOwnProperty(frameDictKey)) {
                var frameDict = framesDict[frameDictKey],
                    spriteFrame = null;

                switch (format) {
                case 0:
                    var x = frameDict.x,
                        y =  frameDict.y,
                        w =  frameDict.width,
                        h =  frameDict.height,
                        ox = frameDict.offsetX,
                        oy = frameDict.offsetY,
                        ow = frameDict.originalWidth,
                        oh = frameDict.originalHeight;

                    // check ow/oh
                    if (!ow || !oh) {
                        //console.log("cocos2d: WARNING: originalWidth/Height not found on the CCSpriteFrame. AnchorPoint won't work as expected. Regenerate the .plist");
                    }

                    if (FLIP_Y_AXIS) {
                        oy *= -1;
                    }

                    // abs ow/oh
                    ow = Math.abs(ow);
                    oh = Math.abs(oh);

                    // create frame
                    spriteFrame = SpriteFrame.create({texture: texture,
                                                         rect: geo.rectMake(x, y, w, h),
                                                       rotate: false,
                                                       offset: geo.ccp(ox, oy),
                                                 originalSize: geo.sizeMake(ow, oh)});
                    break;

                case 1:
                case 2:
                    var frame      = geo.rectFromString(frameDict.frame),
                        rotated    = !!frameDict.rotated,
                        offset     = geo.pointFromString(frameDict.offset),
                        sourceSize = geo.sizeFromString(frameDict.sourceSize);

                    if (FLIP_Y_AXIS) {
                        offset.y *= -1;
                    }


                    // create frame
                    spriteFrame = SpriteFrame.create({texture: texture,
                                                         rect: frame,
                                                       rotate: rotated,
                                                       offset: offset,
                                                 originalSize: sourceSize});
                    break;

                case 3:
                    var spriteSize       = geo.sizeFromString(frameDict.spriteSize),
                        spriteOffset     = geo.pointFromString(frameDict.spriteOffset),
                        spriteSourceSize = geo.sizeFromString(frameDict.spriteSourceSize),
                        textureRect      = geo.rectFromString(frameDict.textureRect),
                        textureRotated   = frameDict.textureRotated;
                    

                    if (FLIP_Y_AXIS) {
                        spriteOffset.y *= -1;
                    }

                    // get aliases
                    var aliases = frameDict.aliases;
                    for (var i = 0, len = aliases.length; i < len; i++) {
                        var alias = aliases[i];
                        this.get('spriteFrameAliases')[frameDictKey] = alias;
                    }
                    
                    // create frame
                    spriteFrame = SpriteFrame.create({texture: texture,
                                                         rect: geo.rectMake(textureRect.origin.x, textureRect.origin.y, spriteSize.width, spriteSize.height),
                                                       rotate: textureRotated,
                                                       offset: spriteOffset,
                                                 originalSize: spriteSourceSize});
                    break;

                default:
                    throw "Unsupported Zwoptex format: " + format;
                }

                // Add sprite frame
                this.get('spriteFrames')[frameDictKey] = spriteFrame;
            }
        }
    },

    /**
     * Get a single SpriteFrame
     *
     * @param {String} opts.name The name of the sprite frame
     * @returns {cocos.SpriteFrame} The sprite frame
     */
    getSpriteFrame: function (opts) {
        var name = opts.name;

        var frame = this.get('spriteFrames')[name];

        if (!frame) {
            // No frame, look for an alias
            var key = this.get('spriteFrameAliases')[name];

            if (key) {
                frame = this.get('spriteFrames')[key];
            }

            if (!frame) {
                throw "Unable to find frame: " + name;
            }
        }

        return frame;
    }
});

/**
 * Class methods
 */
util.extend(SpriteFrameCache, /** @lends cocos.SpriteFrameCache */{
    /**
     * @field
     * @name cocos.SpriteFrameCache.sharedSpriteFrameCache
     * @type cocos.SpriteFrameCache
     */
    get_sharedSpriteFrameCache: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});

exports.SpriteFrameCache = SpriteFrameCache;

}};
__resources__["/__builtin__/libs/cocos2d/Texture2D.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    events = require('events'),
    RemoteResource = require('./RemoteResource').RemoteResource;

var Texture2D = BObject.extend(/** @lends cocos.Texture2D# */{
    imgElement: null,
    size: null,
    name: null,
    isLoaded: false,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @opt {String} [file] The file path of the image to use as a texture
     * @opt {Texture2D|HTMLImageElement} [data] Image data to read from
     */
    init: function (opts) {
        var file = opts.file,
            data = opts.data,
            texture = opts.texture;

        if (file) {
            this.name = file;
            data = resource(file);
        } else if (texture) {
            this.name = texture.get('name');
            data = texture.get('imgElement');
        }

        this.size = {width: 0, height: 0};

        if (data instanceof RemoteResource) {
            events.addListener(data, 'load', util.callback(this, this.dataDidLoad));
            this.set('imgElement', data.load());
        } else {
            this.set('imgElement', data);
            this.dataDidLoad(data);
        }
    },

    dataDidLoad: function (data) {
        this.isLoaded = true;
        this.set('size', {width: this.imgElement.width, height: this.imgElement.height});
        events.trigger(self, 'load', self);
    },

    drawAtPoint: function (ctx, point) {
        if (!this.isLoaded) {
            return;
        }
        ctx.drawImage(this.imgElement, point.x, point.y);
    },
    drawInRect: function (ctx, rect) {
        if (!this.isLoaded) {
            return;
        }
        ctx.drawImage(this.imgElement,
            rect.origin.x, rect.origin.y,
            rect.size.width, rect.size.height
        );
    },

    /**
     * @getter data
     * @type {String} Base64 encoded image data
     */
    get_data: function () {
        return this.imgElement ? this.imgElement.src : null;
    },

    /**
     * @getter contentSize
     * @type {geometry.Size} Size of the texture
     */
    get_contentSize: function () {
        return this.size;
    },

    get_pixelsWide: function () {
        return this.size.width;
    },

    get_pixelsHigh: function () {
        return this.size.height;
    }
});

exports.Texture2D = Texture2D;

}};
__resources__["/__builtin__/libs/cocos2d/TextureAtlas.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    Texture2D = require('./Texture2D').Texture2D;


/* QUAD STRUCTURE
 quad = {
     drawRect: <rect>, // Where the quad is drawn to
     textureRect: <rect>  // The slice of the texture to draw in drawRect
 }
*/

var TextureAtlas = BObject.extend(/** @lends cocos.TextureAtlas# */{
    quads: null,
    imgElement: null,
    texture: null,

    /**
     * A single texture that can represent lots of smaller images
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @opt {String} file The file path of the image to use as a texture
     * @opt {Texture2D|HTMLImageElement} [data] Image data to read from
     * @opt {CanvasElement} [canvas] A canvas to use as a texture
     */
    init: function (opts) {
        var file = opts.file,
            data = opts.data,
            texture = opts.texture,
            canvas = opts.canvas;

        if (canvas) {
            // If we've been given a canvas element then we'll use that for our image
            this.imgElement = canvas;
        } else {
            texture = Texture2D.create({texture: texture, file: file, data: data});
            this.set('texture', texture);
            this.imgElement = texture.get('imgElement');
        }

        this.quads = [];
    },

    insertQuad: function (opts) {
        var quad = opts.quad,
            index = opts.index || 0;

        this.quads.splice(index, 0, quad);
    },
    removeQuad: function (opts) {
        var index = opts.index;

        this.quads.splice(index, 1);
    },


    drawQuads: function (ctx) {
        util.each(this.quads, util.callback(this, function (quad) {
            if (!quad) {
                return;
            }

            this.drawQuad(ctx, quad);
        }));
    },

    drawQuad: function (ctx, quad) {
        var sx = quad.textureRect.origin.x,
            sy = quad.textureRect.origin.y,
            sw = quad.textureRect.size.width, 
            sh = quad.textureRect.size.height;

        var dx = quad.drawRect.origin.x,
            dy = quad.drawRect.origin.y,
            dw = quad.drawRect.size.width, 
            dh = quad.drawRect.size.height;


        var scaleX = 1;
        var scaleY = 1;

        if (FLIP_Y_AXIS) {
            dy -= dh;
            dh *= -1;
        }

            
        if (dw < 0) {
            dw *= -1;
            scaleX = -1;
        }
            
        if (dh < 0) {
            dh *= -1;
            scaleY = -1;
        }

        ctx.scale(scaleX, scaleY);

        var img = this.get('imgElement');
        ctx.drawImage(img, 
            sx, sy, // Draw slice from x,y
            sw, sh, // Draw slice size
            dx, dy, // Draw at 0, 0
            dw, dh  // Draw size
        );
        ctx.scale(1, 1);
    }
});

exports.TextureAtlas = TextureAtlas;

}};
__resources__["/__builtin__/libs/cocos2d/TMXOrientation.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

/**
 * @memberOf cocos
 * @namespace
 */
var TMXOrientation = /** @lends cocos.TMXOrientation */{
    /**
     * Orthogonal orientation
     * @constant
     */
    TMXOrientationOrtho: 1,

    /**
     * Hexagonal orientation
     * @constant
     */
    TMXOrientationHex: 2,

    /**
     * Isometric orientation
     * @constant
     */
    TMXOrientationIso: 3
};

module.exports = TMXOrientation;

}};
__resources__["/__builtin__/libs/cocos2d/TMXXMLParser.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray DOMParser console*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    path = require('path'),
    ccp = require('geometry').ccp,
    base64 = require('base64'),
    gzip   = require('gzip'),
    TMXOrientationOrtho = require('./TMXOrientation').TMXOrientationOrtho,
    TMXOrientationHex = require('./TMXOrientation').TMXOrientationHex,
    TMXOrientationIso = require('./TMXOrientation').TMXOrientationIso;

var TMXTilesetInfo = BObject.extend(/** @lends cocos.TMXTilesetInfo# */{
    name: '',
    firstGID: 0,
    tileSize: null,
    spacing: 0,
    margin: 0,
    sourceImage: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     */
    init: function () {
        TMXTilesetInfo.superclass.init.call(this);
    },

    rectForGID: function (gid) {
        var rect = {size: {}, origin: ccp(0, 0)};
        rect.size = util.copy(this.tileSize);
        
        gid = gid - this.firstGID;

        var imgSize = this.get('imageSize');
        
        var maxX = Math.floor((imgSize.width - this.margin * 2 + this.spacing) / (this.tileSize.width + this.spacing));
        
        rect.origin.x = (gid % maxX) * (this.tileSize.width + this.spacing) + this.margin;
        rect.origin.y = Math.floor(gid / maxX) * (this.tileSize.height + this.spacing) + this.margin;
        
        return rect;
    }
});

var TMXLayerInfo = BObject.extend(/** @lends cocos.TMXLayerInfo# */{
    name: '',
    layerSize: null,
    tiles: null,
    visible: true,
    opacity: 255,
    minGID: 100000,
    maxGID: 0,
    properties: null,
    offset: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     */
    init: function () {
        TMXLayerInfo.superclass.init.call(this);

        this.properties = {};
        this.offset = ccp(0, 0);
    }
});

var TMXObjectGroup = BObject.extend(/** @lends cocos.TMXObjectGroup# */{
    name: '',
    properties: null,
    offset: null,
    objects: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     */
    init: function () {
        TMXObjectGroup.superclass.init.call(this);

        this.properties = {};
        this.objects = {};
        this.offset = ccp(0, 0);
    },

    /**
     * Get the value for the specific property name
     *
     * @opt {String} name Property name
     * @returns {String} Property value
     */
    getProperty: function (opts) {
        var propertyName = opts.name;
        return this.properties[propertyName];
    },

    /**
     * @deprected Since v0.2. You should now use cocos.TMXObjectGroup#getProperty
     */
    propertyNamed: function (opts) {
        console.warn('TMXObjectGroup#propertyNamed is deprected. Use TMXTiledMap#getProperty instread');
        return this.getProperty(opts);
    },

    /**
     * Get the object for the specific object name. It will return the 1st
     * object found on the array for the given name.
     *
     * @opt {String} name Object name
     * @returns {Object} Object
     */
    getObject: function (opts) {
        var objectName = opts.name;
        var object = null;
        
        this.objects.forEach(function (item) {
            if (item.name == objectName) {
                object = item;
            }
        });
        if (object !== null) {
            return object;
        }
    },

    /**
     * @deprected Since v0.2. You should now use cocos.TMXObjectGroup#getProperty
     */
    objectNamed: function (opts) {
        console.warn('TMXObjectGroup#objectNamed is deprected. Use TMXObjectGroup#getObject instread');
        return this.getObject(opts);
    }
});

var TMXMapInfo = BObject.extend(/** @lends cocos.TMXMapInfo# */{
    filename: '',
    orientation: 0,
    mapSize: null,
    tileSize: null,
    layer: null,
    tilesets: null,
    objectGroups: null,
    properties: null,
    tileProperties: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @param {String} tmxFile The file path of the TMX file to load
     */
    init: function (tmxFile) {
        TMXMapInfo.superclass.init.call(this, tmxFile);

        this.tilesets = [];
        this.layers = [];
        this.objectGroups = [];
        this.properties = {};
        this.tileProperties = {};
        this.filename = tmxFile;

        this.parseXMLFile(tmxFile);
    },

    parseXMLFile: function (xmlFile) {
        var parser = new DOMParser(),
            doc = parser.parseFromString(resource(xmlFile), 'text/xml');

        // PARSE <map>
        var map = doc.documentElement;

        // Set Orientation
        switch (map.getAttribute('orientation')) {
        case 'orthogonal':
            this.orientation = TMXOrientationOrtho;
            break;
        case 'isometric':
            this.orientation = TMXOrientationIso;
            break;
        case 'hexagonal':
            this.orientation = TMXOrientationHex;
            break;
        default:
            throw "cocos2d: TMXFomat: Unsupported orientation: " + map.getAttribute('orientation');
        }
        this.mapSize = {width: parseInt(map.getAttribute('width'), 10), height: parseInt(map.getAttribute('height'), 10)};
        this.tileSize = {width: parseInt(map.getAttribute('tilewidth'), 10), height: parseInt(map.getAttribute('tileheight'), 10)};


        // PARSE <tilesets>
        var tilesets = map.getElementsByTagName('tileset');
        var i, j, len, jen, s;
        for (i = 0, len = tilesets.length; i < len; i++) {
            var t = tilesets[i];

            var tileset = TMXTilesetInfo.create();
            tileset.set('name', t.getAttribute('name'));
            tileset.set('firstGID', parseInt(t.getAttribute('firstgid'), 10));
            if (t.getAttribute('spacing')) {
                tileset.set('spacing', parseInt(t.getAttribute('spacing'), 10));
            }
            if (t.getAttribute('margin')) {
                tileset.set('margin', parseInt(t.getAttribute('margin'), 10));
            }

            s = {};
            s.width = parseInt(t.getAttribute('tilewidth'), 10);
            s.height = parseInt(t.getAttribute('tileheight'), 10);
            tileset.set('tileSize', s);

            // PARSE <image> We assume there's only 1
            var image = t.getElementsByTagName('image')[0];
            tileset.set('sourceImage', path.join(path.dirname(this.filename), image.getAttribute('source')));

            this.tilesets.push(tileset);
        }

        // PARSE <layers>
        var layers = map.getElementsByTagName('layer');
        for (i = 0, len = layers.length; i < len; i++) {
            var l = layers[i];
            var data = l.getElementsByTagName('data')[0];
            var layer = TMXLayerInfo.create();

            layer.set('name', l.getAttribute('name'));
            if (l.getAttribute('visible') !== false) {
                layer.set('visible', true);
            } else {
                layer.set('visible', !!parseInt(l.getAttribute('visible'), 10));
            }

            s = {};
            s.width = parseInt(l.getAttribute('width'), 10);
            s.height = parseInt(l.getAttribute('height'), 10);
            layer.set('layerSize', s);

            var opacity = l.getAttribute('opacity');
            if (!opacity && opacity !== 0) {
                layer.set('opacity', 255);
            } else {
                layer.set('opacity', 255 * parseFloat(opacity));
            }

            var x = parseInt(l.getAttribute('x'), 10),
                y = parseInt(l.getAttribute('y'), 10);
            if (isNaN(x)) {
                x = 0;
            }
            if (isNaN(y)) {
                y = 0;
            }
            layer.set('offset', ccp(x, y));


            // Firefox has a 4KB limit on node values. It will split larger
            // nodes up into multiple nodes. So, we'll stitch them back
            // together.
            var nodeValue = '';
            for (j = 0, jen = data.childNodes.length; j < jen; j++) {
                nodeValue += data.childNodes[j].nodeValue;
            }

            // Unpack the tilemap data
            var compression = data.getAttribute('compression');
            switch (compression) {
            case 'gzip':
                layer.set('tiles', gzip.unzipBase64AsArray(nodeValue, 4));
                break;
                
            // Uncompressed
            case null:
            case '': 
                layer.set('tiles', base64.decodeAsArray(nodeValue, 4));
                break;

            default: 
                throw "Unsupported TMX Tile Map compression: " + compression;
            }

            this.layers.push(layer);
        }

        // TODO PARSE <tile>

        // PARSE <objectgroup>
        var objectgroups = map.getElementsByTagName('objectgroup');
        for (i = 0, len = objectgroups.length; i < len; i++) {
            var g = objectgroups[i],
                objectGroup = TMXObjectGroup.create();

            objectGroup.set('name', g.getAttribute('name'));
            
            var properties = g.querySelectorAll('objectgroup > properties property'),
                propertiesValue = {},
                property;
            
            for (j = 0; j < properties.length; j++) {
                property = properties[j];
                if (property.getAttribute('name')) {
                    propertiesValue[property.getAttribute('name')] = property.getAttribute('value');
                }
            }
           
            objectGroup.set('properties', propertiesValue);

            var objectsArray = [],
                objects = g.querySelectorAll('object');

            for (j = 0; j < objects.length; j++) {
                var object = objects[j];
                var objectValue = {
                    x       : parseInt(object.getAttribute('x'), 10),
                    y       : parseInt(object.getAttribute('y'), 10),
                    width   : parseInt(object.getAttribute('width'), 10),
                    height  : parseInt(object.getAttribute('height'), 10)
                };
                if (object.getAttribute('name')) {
                    objectValue.name = object.getAttribute('name');
                }
                if (object.getAttribute('type')) {
                    objectValue.type = object.getAttribute('type');
                }
                properties = object.querySelectorAll('property');
                for (var k = 0; k < properties.length; k++) {
                    property = properties[k];
                    if (property.getAttribute('name')) {
                        objectValue[property.getAttribute('name')] = property.getAttribute('value');
                    }
                }
                objectsArray.push(objectValue);

            }
            objectGroup.set('objects', objectsArray);
            this.objectGroups.push(objectGroup);
        }


        // PARSE <map><property>
        var properties = doc.querySelectorAll('map > properties > property');

        for (i = 0; i < properties.length; i++) {
            var property = properties[i];
            if (property.getAttribute('name')) {
                this.properties[property.getAttribute('name')] = property.getAttribute('value');
            }
        }
    }
});

exports.TMXMapInfo = TMXMapInfo;
exports.TMXLayerInfo = TMXLayerInfo;
exports.TMXTilesetInfo = TMXTilesetInfo;
exports.TMXObjectGroup = TMXObjectGroup;

}};
__resources__["/__builtin__/libs/geometry.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util');

var RE_PAIR = /\{\s*([\d.\-]+)\s*,\s*([\d.\-]+)\s*\}/,
    RE_DOUBLE_PAIR = /\{\s*(\{[\s\d,.\-]+\})\s*,\s*(\{[\s\d,.\-]+\})\s*\}/;

Math.PI_2 = 1.57079632679489661923132169163975144     /* pi/2 */

/** @namespace */
var geometry = {
    /**
     * @class
     * A 2D point in space
     *
     * @param {Float} x X value
     * @param {Float} y Y value
     */
    Point: function (x, y) {
        /**
         * X coordinate
         * @type Float
         */
        this.x = x;

        /**
         * Y coordinate
         * @type Float
         */
        this.y = y;
    },

    /**
     * @class
     * A 2D size
     *
     * @param {Float} w Width
     * @param {Float} h Height
     */
    Size: function (w, h) {
        /**
         * Width
         * @type Float
         */
        this.width = w;

        /**
         * Height
         * @type Float
         */
        this.height = h;
    },

    /**
     * @class
     * A rectangle
     *
     * @param {Float} x X value
     * @param {Float} y Y value
     * @param {Float} w Width
     * @param {Float} h Height
     */
    Rect: function (x, y, w, h) {
        /**
         * Coordinate in 2D space
         * @type {geometry.Point}
         */
        this.origin = new geometry.Point(x, y);

        /**
         * Size in 2D space
         * @type {geometry.Size}
         */
        this.size   = new geometry.Size(w, h);
    },

    /**
     * @class
     * Transform matrix
     *
     * @param {Float} a
     * @param {Float} b
     * @param {Float} c
     * @param {Float} d
     * @param {Float} tx
     * @param {Float} ty
     */
    TransformMatrix: function (a, b, c, d, tx, ty) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
    },

    /**
     * @class 
     * Bezier curve control object
     *
     * @param {geometry.Point} controlPoint1
     * @param {geometry.Point} controlPoint2
     * @param {geometry.Point} endPoint
     */
    BezierConfig: function(p1, p2, ep) {
        this.controlPoint1 = util.copy(p1);
        this.controlPoint2 = util.copy(p2);
        this.endPosition = util.copy(ep);
    },
    
    /**
     * Creates a geometry.Point instance
     *
     * @param {Float} x X coordinate
     * @param {Float} y Y coordinate
     * @returns {geometry.Point} 
     */
    ccp: function (x, y) {
        return module.exports.pointMake(x, y);
    },

    /**
     * Add the values of two points together
     *
     * @param {geometry.Point} p1 First point
     * @param {geometry.Point} p2 Second point
     * @returns {geometry.Point} New point
     */
    ccpAdd: function (p1, p2) {
        return geometry.ccp(p1.x + p2.x, p1.y + p2.y);
    },

    /**
     * Subtract the values of two points
     *
     * @param {geometry.Point} p1 First point
     * @param {geometry.Point} p2 Second point
     * @returns {geometry.Point} New point
     */
    ccpSub: function (p1, p2) {
        return geometry.ccp(p1.x - p2.x, p1.y - p2.y);
    },

    /**
     * Muliply the values of two points together
     *
     * @param {geometry.Point} p1 First point
     * @param {geometry.Point} p2 Second point
     * @returns {geometry.Point} New point
     */
    ccpMult: function (p1, p2) {
        return geometry.ccp(p1.x * p2.x, p1.y * p2.y);
    },


    /**
     * Invert the values of a geometry.Point
     *
     * @param {geometry.Point} p Point to invert
     * @returns {geometry.Point} New point
     */
    ccpNeg: function (p) {
        return geometry.ccp(-p.x, -p.y);
    },

    /**
     * Round values on a geometry.Point to whole numbers
     *
     * @param {geometry.Point} p Point to round
     * @returns {geometry.Point} New point
     */
    ccpRound: function (p) {
        return geometry.ccp(Math.round(p.x), Math.round(p.y));
    },

    /**
     * Round up values on a geometry.Point to whole numbers
     *
     * @param {geometry.Point} p Point to round
     * @returns {geometry.Point} New point
     */
    ccpCeil: function (p) {
        return geometry.ccp(Math.ceil(p.x), Math.ceil(p.y));
    },

    /**
     * Round down values on a geometry.Point to whole numbers
     *
     * @param {geometry.Point} p Point to round
     * @returns {geometry.Point} New point
     */
    ccpFloor: function (p) {
        return geometry.ccp(Math.floor(p.x), Math.floor(p.y));
    },

    /**
     * A point at 0x0
     *
     * @returns {geometry.Point} New point at 0x0
     */
    PointZero: function () {
        return geometry.ccp(0, 0);
    },

    /**
     * @returns {geometry.Rect}
     */
    rectMake: function (x, y, w, h) {
        return new geometry.Rect(x, y, w, h);
    },

    /**
     * @returns {geometry.Rect}
     */
    rectFromString: function (str) {
        var matches = str.match(RE_DOUBLE_PAIR),
            p = geometry.pointFromString(matches[1]),
            s = geometry.sizeFromString(matches[2]);

        return geometry.rectMake(p.x, p.y, s.width, s.height);
    },

    /**
     * @returns {geometry.Size}
     */
    sizeMake: function (w, h) {
        return new geometry.Size(w, h);
    },

    /**
     * @returns {geometry.Size}
     */
    sizeFromString: function (str) {
        var matches = str.match(RE_PAIR),
            w = parseFloat(matches[1]),
            h = parseFloat(matches[2]);

        return geometry.sizeMake(w, h);
    },

    /**
     * @returns {geometry.Point}
     */
    pointMake: function (x, y) {
        return new geometry.Point(x, y);
    },

    /**
     * @returns {geometry.Point}
     */
    pointFromString: function (str) {
        var matches = str.match(RE_PAIR),
            x = parseFloat(matches[1]),
            y = parseFloat(matches[2]);

        return geometry.pointMake(x, y);
    },

    /**
     * @returns {Boolean}
     */
    rectContainsPoint: function (r, p) {
        return ((p.x >= r.origin.x && p.x <= r.origin.x + r.size.width) &&
                (p.y >= r.origin.y && p.y <= r.origin.y + r.size.height));
    },

    /**
     * Returns the smallest rectangle that contains the two source rectangles.
     *
     * @param {geometry.Rect} r1
     * @param {geometry.Rect} r2
     * @returns {geometry.Rect}
     */
    rectUnion: function (r1, r2) {
        var rect = new geometry.Rect(0, 0, 0, 0);

        rect.origin.x = Math.min(r1.origin.x, r2.origin.x);
        rect.origin.y = Math.min(r1.origin.y, r2.origin.y);
        rect.size.width = Math.max(r1.origin.x + r1.size.width, r2.origin.x + r2.size.width) - rect.origin.x;
        rect.size.height = Math.max(r1.origin.y + r1.size.height, r2.origin.y + r2.size.height) - rect.origin.y;

        return rect;
    },

    /**
     * @returns {Boolean}
     */
    rectOverlapsRect: function (r1, r2) {
        if (r1.origin.x + r1.size.width < r2.origin.x) {
            return false;
        }
        if (r2.origin.x + r2.size.width < r1.origin.x) {
            return false;
        }
        if (r1.origin.y + r1.size.height < r2.origin.y) {
            return false;
        }
        if (r2.origin.y + r2.size.height < r1.origin.y) {
            return false;
        }

        return true;
    },

    /**
     * Returns the overlapping portion of 2 rectangles
     *
     * @param {geometry.Rect} lhsRect First rectangle
     * @param {geometry.Rect} rhsRect Second rectangle
     * @returns {geometry.Rect} The overlapping portion of the 2 rectangles
     */
    rectIntersection: function (lhsRect, rhsRect) {

        var intersection = new geometry.Rect(
            Math.max(geometry.rectGetMinX(lhsRect), geometry.rectGetMinX(rhsRect)),
            Math.max(geometry.rectGetMinY(lhsRect), geometry.rectGetMinY(rhsRect)),
            0,
            0
        );

        intersection.size.width = Math.min(geometry.rectGetMaxX(lhsRect), geometry.rectGetMaxX(rhsRect)) - geometry.rectGetMinX(intersection);
        intersection.size.height = Math.min(geometry.rectGetMaxY(lhsRect), geometry.rectGetMaxY(rhsRect)) - geometry.rectGetMinY(intersection);

        return intersection;
    },

    /**
     * @returns {Boolean}
     */
    pointEqualToPoint: function (point1, point2) {
        return (point1.x == point2.x && point1.y == point2.y);
    },

    /**
     * @returns {Boolean}
     */
    sizeEqualToSize: function (size1, size2) {
        return (size1.width == size2.width && size1.height == size2.height);
    },

    /**
     * @returns {Boolean}
     */
    rectEqualToRect: function (rect1, rect2) {
        return (module.exports.sizeEqualToSize(rect1.size, rect2.size) && module.exports.pointEqualToPoint(rect1.origin, rect2.origin));
    },

    /**
     * @returns {Float}
     */
    rectGetMinX: function (rect) {
        return rect.origin.x;
    },

    /**
     * @returns {Float}
     */
    rectGetMinY: function (rect) {
        return rect.origin.y;
    },

    /**
     * @returns {Float}
     */
    rectGetMaxX: function (rect) {
        return rect.origin.x + rect.size.width;
    },

    /**
     * @returns {Float}
     */
    rectGetMaxY: function (rect) {
        return rect.origin.y + rect.size.height;
    },

    boundingRectMake: function (p1, p2, p3, p4) {
        var minX = Math.min(p1.x, p2.x, p3.x, p4.x);
        var minY = Math.min(p1.y, p2.y, p3.y, p4.y);
        var maxX = Math.max(p1.x, p2.x, p3.x, p4.x);
        var maxY = Math.max(p1.y, p2.y, p3.y, p4.y);

        return new geometry.Rect(minX, minY, (maxX - minX), (maxY - minY));
    },

    /**
     * @returns {geometry.Point}
     */
    pointApplyAffineTransform: function (point, t) {

        /*
        aPoint.x * aTransform.a + aPoint.y * aTransform.c + aTransform.tx,
        aPoint.x * aTransform.b + aPoint.y * aTransform.d + aTransform.ty
        */

        return new geometry.Point(t.a * point.x + t.c * point.y + t.tx, t.b * point.x + t.d * point.y + t.ty);

    },

    /**
     * Apply a transform matrix to a rectangle
     *
     * @param {geometry.Rect} rect Rectangle to transform
     * @param {geometry.TransformMatrix} trans TransformMatrix to apply to rectangle
     * @returns {geometry.Rect} A new transformed rectangle
     */
    rectApplyAffineTransform: function (rect, trans) {

        var p1 = geometry.ccp(geometry.rectGetMinX(rect), geometry.rectGetMinY(rect));
        var p2 = geometry.ccp(geometry.rectGetMaxX(rect), geometry.rectGetMinY(rect));
        var p3 = geometry.ccp(geometry.rectGetMinX(rect), geometry.rectGetMaxY(rect));
        var p4 = geometry.ccp(geometry.rectGetMaxX(rect), geometry.rectGetMaxY(rect));

        p1 = geometry.pointApplyAffineTransform(p1, trans);
        p2 = geometry.pointApplyAffineTransform(p2, trans);
        p3 = geometry.pointApplyAffineTransform(p3, trans);
        p4 = geometry.pointApplyAffineTransform(p4, trans);

        return geometry.boundingRectMake(p1, p2, p3, p4);
    },

    /**
     * Inverts a transform matrix
     *
     * @param {geometry.TransformMatrix} trans TransformMatrix to invert
     * @returns {geometry.TransformMatrix} New transform matrix
     */
    affineTransformInvert: function (trans) {
        var determinant = 1 / (trans.a * trans.d - trans.b * trans.c);

        return new geometry.TransformMatrix(
            determinant * trans.d,
            -determinant * trans.b,
            -determinant * trans.c,
            determinant * trans.a,
            determinant * (trans.c * trans.ty - trans.d * trans.tx),
            determinant * (trans.b * trans.tx - trans.a * trans.ty)
        );
    },

    /**
     * Multiply 2 transform matrices together
     * @param {geometry.TransformMatrix} lhs Left matrix
     * @param {geometry.TransformMatrix} rhs Right matrix
     * @returns {geometry.TransformMatrix} New transform matrix
     */
    affineTransformConcat: function (lhs, rhs) {
        return new geometry.TransformMatrix(
            lhs.a * rhs.a + lhs.b * rhs.c,
            lhs.a * rhs.b + lhs.b * rhs.d,
            lhs.c * rhs.a + lhs.d * rhs.c,
            lhs.c * rhs.b + lhs.d * rhs.d,
            lhs.tx * rhs.a + lhs.ty * rhs.c + rhs.tx,
            lhs.tx * rhs.b + lhs.ty * rhs.d + rhs.ty
        );
    },

    /**
     * @returns {Float}
     */
    degreesToRadians: function (angle) {
        return angle / 180.0 * Math.PI;
    },

    /**
     * @returns {Float}
     */
    radiansToDegrees: function (angle) {
        return angle * (180.0 / Math.PI);
    },

    /**
     * Translate (move) a transform matrix
     *
     * @param {geometry.TransformMatrix} trans TransformMatrix to translate
     * @param {Float} tx Amount to translate along X axis
     * @param {Float} ty Amount to translate along Y axis
     * @returns {geometry.TransformMatrix} A new TransformMatrix
     */
    affineTransformTranslate: function (trans, tx, ty) {
        var newTrans = util.copy(trans);
        newTrans.tx = trans.tx + trans.a * tx + trans.c * ty;
        newTrans.ty = trans.ty + trans.b * tx + trans.d * ty;
        return newTrans;
    },

    /**
     * Rotate a transform matrix
     *
     * @param {geometry.TransformMatrix} trans TransformMatrix to rotate
     * @param {Float} angle Angle in radians
     * @returns {geometry.TransformMatrix} A new TransformMatrix
     */
    affineTransformRotate: function (trans, angle) {
        var sin = Math.sin(angle),
            cos = Math.cos(angle);

        return new geometry.TransformMatrix(
            trans.a * cos + trans.c * sin,
            trans.b * cos + trans.d * sin,
            trans.c * cos - trans.a * sin,
            trans.d * cos - trans.b * sin,
            trans.tx,
            trans.ty
        );
    },

    /**
     * Scale a transform matrix
     *
     * @param {geometry.TransformMatrix} trans TransformMatrix to scale
     * @param {Float} sx X scale factor
     * @param {Float} [sy=sx] Y scale factor
     * @returns {geometry.TransformMatrix} A new TransformMatrix
     */
    affineTransformScale: function (trans, sx, sy) {
        if (sy === undefined) {
            sy = sx;
        }

        return new geometry.TransformMatrix(trans.a * sx, trans.b * sx, trans.c * sy, trans.d * sy, trans.tx, trans.ty);
    },

    /**
     * @returns {geometry.TransformMatrix} identity matrix
     */
    affineTransformIdentity: function () {
        return new geometry.TransformMatrix(1, 0, 0, 1, 0, 0);
    }
};

module.exports = geometry;

}};
__resources__["/__builtin__/libs/gzip.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/**
 * @fileoverview 
 */

/** @ignore */
var JXG = require('./JXGUtil');

/**
 * @namespace
 * Wrappers around JXG's GZip utils
 * @see JXG.Util
 */
var gzip = {
    /**
     * Unpack a gzipped byte array
     *
     * @param {Integer[]} input Byte array
     * @returns {String} Unpacked byte string
     */
    unzip: function(input) {
        return (new JXG.Util.Unzip(input)).unzip()[0][0];
    },

    /**
     * Unpack a gzipped byte string encoded as base64
     *
     * @param {String} input Byte string encoded as base64
     * @returns {String} Unpacked byte string
     */
    unzipBase64: function(input) {
        return (new JXG.Util.Unzip(JXG.Util.Base64.decodeAsArray(input))).unzip()[0][0];
    },

    /**
     * Unpack a gzipped byte string encoded as base64
     *
     * @param {String} input Byte string encoded as base64
     * @param {Integer} bytes Bytes per array item
     * @returns {Integer[]} Unpacked byte array
     */
    unzipBase64AsArray: function(input, bytes) {
        bytes = bytes || 1;

        var dec = this.unzipBase64(input),
            ar = [], i, j, len;
        for (i = 0, len = dec.length/bytes; i < len; i++){
            ar[i] = 0;
            for (j = bytes-1; j >= 0; --j){
                ar[i] += dec.charCodeAt((i *bytes) +j) << (j *8);
            }
        }
        return ar;
    },

    /**
     * Unpack a gzipped byte array
     *
     * @param {Integer[]} input Byte array
     * @param {Integer} bytes Bytes per array item
     * @returns {Integer[]} Unpacked byte array
     */
    unzipAsArray: function (input, bytes) {
        bytes = bytes || 1;

        var dec = this.unzip(input),
            ar = [], i, j, len;
        for (i = 0, len = dec.length/bytes; i < len; i++){
            ar[i] = 0;
            for (j = bytes-1; j >= 0; --j){
                ar[i] += dec.charCodeAt((i *bytes) +j) << (j *8);
            }
        }
        return ar;
    }

};

module.exports = gzip;

}};
__resources__["/__builtin__/libs/JXGUtil.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
    Copyright 2008,2009
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with JSXGraph.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * @fileoverview Utilities for uncompressing and base64 decoding
 */

/** @namespace */
var JXG = {};

/**
  * @class Util class
  * Class for gunzipping, unzipping and base64 decoding of files.
  * It is used for reading GEONExT, Geogebra and Intergeo files.
  *
  * Only Huffman codes are decoded in gunzip.
  * The code is based on the source code for gunzip.c by Pasi Ojala 
  * @see <a href="http://www.cs.tut.fi/~albert/Dev/gunzip/gunzip.c">http://www.cs.tut.fi/~albert/Dev/gunzip/gunzip.c</a>
  * @see <a href="http://www.cs.tut.fi/~albert">http://www.cs.tut.fi/~albert</a>
  */
JXG.Util = {};
                                 
/**
 * Unzip zip files
 */
JXG.Util.Unzip = function (barray){
    var outputArr = [],
        output = "",
        debug = false,
        gpflags,
        files = 0,
        unzipped = [],
        crc,
        buf32k = new Array(32768),
        bIdx = 0,
        modeZIP=false,

        CRC, SIZE,
    
        bitReverse = [
        0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
        0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
        0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
        0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
        0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
        0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
        0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
        0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
        0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
        0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
        0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
        0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
        0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
        0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
        0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
        0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
        0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
        0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
        0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
        0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
        0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
        0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
        0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
        0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
        0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
        0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
        0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
        0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
        0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
        0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
        0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
        0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
    ],
    
    cplens = [
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
    ],

    cplext = [
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99
    ], /* 99==invalid */

    cpdist = [
        0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d,
        0x0011, 0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1,
        0x0101, 0x0181, 0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01,
        0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001
    ],

    cpdext = [
        0,  0,  0,  0,  1,  1,  2,  2,
        3,  3,  4,  4,  5,  5,  6,  6,
        7,  7,  8,  8,  9,  9, 10, 10,
        11, 11, 12, 12, 13, 13
    ],
    
    border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
    
    bA = barray,

    bytepos=0,
    bitpos=0,
    bb = 1,
    bits=0,
    
    NAMEMAX = 256,
    
    nameBuf = [],
    
    fileout;
    
    function readByte(){
        bits+=8;
        if (bytepos<bA.length){
            //if (debug)
            //    document.write(bytepos+": "+bA[bytepos]+"<br>");
            return bA[bytepos++];
        } else
            return -1;
    };

    function byteAlign(){
        bb = 1;
    };
    
    function readBit(){
        var carry;
        bits++;
        carry = (bb & 1);
        bb >>= 1;
        if (bb==0){
            bb = readByte();
            carry = (bb & 1);
            bb = (bb>>1) | 0x80;
        }
        return carry;
    };

    function readBits(a) {
        var res = 0,
            i = a;
    
        while(i--) {
            res = (res<<1) | readBit();
        }
        if(a) {
            res = bitReverse[res]>>(8-a);
        }
        return res;
    };
        
    function flushBuffer(){
        //document.write('FLUSHBUFFER:'+buf32k);
        bIdx = 0;
    };
    function addBuffer(a){
        SIZE++;
        //CRC=updcrc(a,crc);
        buf32k[bIdx++] = a;
        outputArr.push(String.fromCharCode(a));
        //output+=String.fromCharCode(a);
        if(bIdx==0x8000){
            //document.write('ADDBUFFER:'+buf32k);
            bIdx=0;
        }
    };
    
    function HufNode() {
        this.b0=0;
        this.b1=0;
        this.jump = null;
        this.jumppos = -1;
    };

    var LITERALS = 288;
    
    var literalTree = new Array(LITERALS);
    var distanceTree = new Array(32);
    var treepos=0;
    var Places = null;
    var Places2 = null;
    
    var impDistanceTree = new Array(64);
    var impLengthTree = new Array(64);
    
    var len = 0;
    var fpos = new Array(17);
    fpos[0]=0;
    var flens;
    var fmax;
    
    function IsPat() {
        while (1) {
            if (fpos[len] >= fmax)
                return -1;
            if (flens[fpos[len]] == len)
                return fpos[len]++;
            fpos[len]++;
        }
    };

    function Rec() {
        var curplace = Places[treepos];
        var tmp;
        if (debug)
    		document.write("<br>len:"+len+" treepos:"+treepos);
        if(len==17) { //war 17
            return -1;
        }
        treepos++;
        len++;
    	
        tmp = IsPat();
        if (debug)
        	document.write("<br>IsPat "+tmp);
        if(tmp >= 0) {
            curplace.b0 = tmp;    /* leaf cell for 0-bit */
            if (debug)
            	document.write("<br>b0 "+curplace.b0);
        } else {
        /* Not a Leaf cell */
        curplace.b0 = 0x8000;
        if (debug)
        	document.write("<br>b0 "+curplace.b0);
        if(Rec())
            return -1;
        }
        tmp = IsPat();
        if(tmp >= 0) {
            curplace.b1 = tmp;    /* leaf cell for 1-bit */
            if (debug)
            	document.write("<br>b1 "+curplace.b1);
            curplace.jump = null;    /* Just for the display routine */
        } else {
            /* Not a Leaf cell */
            curplace.b1 = 0x8000;
            if (debug)
            	document.write("<br>b1 "+curplace.b1);
            curplace.jump = Places[treepos];
            curplace.jumppos = treepos;
            if(Rec())
                return -1;
        }
        len--;
        return 0;
    };

    function CreateTree(currentTree, numval, lengths, show) {
        var i;
        /* Create the Huffman decode tree/table */
        //document.write("<br>createtree<br>");
        if (debug)
        	document.write("currentTree "+currentTree+" numval "+numval+" lengths "+lengths+" show "+show);
        Places = currentTree;
        treepos=0;
        flens = lengths;
        fmax  = numval;
        for (i=0;i<17;i++)
            fpos[i] = 0;
        len = 0;
        if(Rec()) {
            //fprintf(stderr, "invalid huffman tree\n");
            if (debug)
            	alert("invalid huffman tree\n");
            return -1;
        }
        if (debug){
        	document.write('<br>Tree: '+Places.length);
        	for (var a=0;a<32;a++){
            	document.write("Places["+a+"].b0="+Places[a].b0+"<br>");
            	document.write("Places["+a+"].b1="+Places[a].b1+"<br>");
        	}
        }

        return 0;
    };
    
    function DecodeValue(currentTree) {
        var len, i,
            xtreepos=0,
            X = currentTree[xtreepos],
            b;

        /* decode one symbol of the data */
        while(1) {
            b=readBit();
            if (debug)
            	document.write("b="+b);
            if(b) {
                if(!(X.b1 & 0x8000)){
                	if (debug)
                    	document.write("ret1");
                    return X.b1;    /* If leaf node, return data */
                }
                X = X.jump;
                len = currentTree.length;
                for (i=0;i<len;i++){
                    if (currentTree[i]===X){
                        xtreepos=i;
                        break;
                    }
                }
                //xtreepos++;
            } else {
                if(!(X.b0 & 0x8000)){
                	if (debug)
                    	document.write("ret2");
                    return X.b0;    /* If leaf node, return data */
                }
                //X++; //??????????????????
                xtreepos++;
                X = currentTree[xtreepos];
            }
        }
        if (debug)
        	document.write("ret3");
        return -1;
    };
    
    function DeflateLoop() {
    var last, c, type, i, len;

    do {
        /*if((last = readBit())){
            fprintf(errfp, "Last Block: ");
        } else {
            fprintf(errfp, "Not Last Block: ");
        }*/
        last = readBit();
        type = readBits(2);
        switch(type) {
            case 0:
            	if (debug)
                	alert("Stored\n");
                break;
            case 1:
            	if (debug)
                	alert("Fixed Huffman codes\n");
                break;
            case 2:
            	if (debug)
                	alert("Dynamic Huffman codes\n");
                break;
            case 3:
            	if (debug)
                	alert("Reserved block type!!\n");
                break;
            default:
            	if (debug)
                	alert("Unexpected value %d!\n", type);
                break;
        }

        if(type==0) {
            var blockLen, cSum;

            // Stored 
            byteAlign();
            blockLen = readByte();
            blockLen |= (readByte()<<8);

            cSum = readByte();
            cSum |= (readByte()<<8);

            if(((blockLen ^ ~cSum) & 0xffff)) {
                document.write("BlockLen checksum mismatch\n");
            }
            while(blockLen--) {
                c = readByte();
                addBuffer(c);
            }
        } else if(type==1) {
            var j;

            /* Fixed Huffman tables -- fixed decode routine */
            while(1) {
            /*
                256    0000000        0
                :   :     :
                279    0010111        23
                0   00110000    48
                :    :      :
                143    10111111    191
                280 11000000    192
                :    :      :
                287 11000111    199
                144    110010000    400
                :    :       :
                255    111111111    511
    
                Note the bit order!
                */

            j = (bitReverse[readBits(7)]>>1);
            if(j > 23) {
                j = (j<<1) | readBit();    /* 48..255 */

                if(j > 199) {    /* 200..255 */
                    j -= 128;    /*  72..127 */
                    j = (j<<1) | readBit();        /* 144..255 << */
                } else {        /*  48..199 */
                    j -= 48;    /*   0..151 */
                    if(j > 143) {
                        j = j+136;    /* 280..287 << */
                        /*   0..143 << */
                    }
                }
            } else {    /*   0..23 */
                j += 256;    /* 256..279 << */
            }
            if(j < 256) {
                addBuffer(j);
                //document.write("out:"+String.fromCharCode(j));
                /*fprintf(errfp, "@%d %02x\n", SIZE, j);*/
            } else if(j == 256) {
                /* EOF */
                break;
            } else {
                var len, dist;

                j -= 256 + 1;    /* bytes + EOF */
                len = readBits(cplext[j]) + cplens[j];

                j = bitReverse[readBits(5)]>>3;
                if(cpdext[j] > 8) {
                    dist = readBits(8);
                    dist |= (readBits(cpdext[j]-8)<<8);
                } else {
                    dist = readBits(cpdext[j]);
                }
                dist += cpdist[j];

                /*fprintf(errfp, "@%d (l%02x,d%04x)\n", SIZE, len, dist);*/
                for(j=0;j<len;j++) {
                    var c = buf32k[(bIdx - dist) & 0x7fff];
                    addBuffer(c);
                }
            }
            } // while
        } else if(type==2) {
            var j, n, literalCodes, distCodes, lenCodes;
            var ll = new Array(288+32);    // "static" just to preserve stack
    
            // Dynamic Huffman tables 
    
            literalCodes = 257 + readBits(5);
            distCodes = 1 + readBits(5);
            lenCodes = 4 + readBits(4);
            //document.write("<br>param: "+literalCodes+" "+distCodes+" "+lenCodes+"<br>");
            for(j=0; j<19; j++) {
                ll[j] = 0;
            }
    
            // Get the decode tree code lengths
    
            //document.write("<br>");
            for(j=0; j<lenCodes; j++) {
                ll[border[j]] = readBits(3);
                //document.write(ll[border[j]]+" ");
            }
            //fprintf(errfp, "\n");
            //document.write('<br>ll:'+ll);
            len = distanceTree.length;
            for (i=0; i<len; i++)
                distanceTree[i]=new HufNode();
            if(CreateTree(distanceTree, 19, ll, 0)) {
                flushBuffer();
                return 1;
            }
            if (debug){
            	document.write("<br>distanceTree");
            	for(var a=0;a<distanceTree.length;a++){
                	document.write("<br>"+distanceTree[a].b0+" "+distanceTree[a].b1+" "+distanceTree[a].jump+" "+distanceTree[a].jumppos);
                	/*if (distanceTree[a].jumppos!=-1)
                    	document.write(" "+distanceTree[a].jump.b0+" "+distanceTree[a].jump.b1);
                	*/
            	}
            }
            //document.write('<BR>tree created');
    
            //read in literal and distance code lengths
            n = literalCodes + distCodes;
            i = 0;
            var z=-1;
            if (debug)
            	document.write("<br>n="+n+" bits: "+bits+"<br>");
            while(i < n) {
                z++;
                j = DecodeValue(distanceTree);
                if (debug)
                	document.write("<br>"+z+" i:"+i+" decode: "+j+"    bits "+bits+"<br>");
                if(j<16) {    // length of code in bits (0..15)
                       ll[i++] = j;
                } else if(j==16) {    // repeat last length 3 to 6 times 
                       var l;
                    j = 3 + readBits(2);
                    if(i+j > n) {
                        flushBuffer();
                        return 1;
                    }
                    l = i ? ll[i-1] : 0;
                    while(j--) {
                        ll[i++] = l;
                    }
                } else {
                    if(j==17) {        // 3 to 10 zero length codes
                        j = 3 + readBits(3);
                    } else {        // j == 18: 11 to 138 zero length codes 
                        j = 11 + readBits(7);
                    }
                    if(i+j > n) {
                        flushBuffer();
                        return 1;
                    }
                    while(j--) {
                        ll[i++] = 0;
                    }
                }
            }
            /*for(j=0; j<literalCodes+distCodes; j++) {
                //fprintf(errfp, "%d ", ll[j]);
                if ((j&7)==7)
                    fprintf(errfp, "\n");
            }
            fprintf(errfp, "\n");*/
            // Can overwrite tree decode tree as it is not used anymore
            len = literalTree.length;
            for (i=0; i<len; i++)
                literalTree[i]=new HufNode();
            if(CreateTree(literalTree, literalCodes, ll, 0)) {
                flushBuffer();
                return 1;
            }
            len = literalTree.length;
            for (i=0; i<len; i++)
                distanceTree[i]=new HufNode();
            var ll2 = new Array();
            for (i=literalCodes; i <ll.length; i++){
                ll2[i-literalCodes]=ll[i];
            }    
            if(CreateTree(distanceTree, distCodes, ll2, 0)) {
                flushBuffer();
                return 1;
            }
            if (debug)
           		document.write("<br>literalTree");
            while(1) {
                j = DecodeValue(literalTree);
                if(j >= 256) {        // In C64: if carry set
                    var len, dist;
                    j -= 256;
                    if(j == 0) {
                        // EOF
                        break;
                    }
                    j--;
                    len = readBits(cplext[j]) + cplens[j];
    
                    j = DecodeValue(distanceTree);
                    if(cpdext[j] > 8) {
                        dist = readBits(8);
                        dist |= (readBits(cpdext[j]-8)<<8);
                    } else {
                        dist = readBits(cpdext[j]);
                    }
                    dist += cpdist[j];
                    while(len--) {
                        var c = buf32k[(bIdx - dist) & 0x7fff];
                        addBuffer(c);
                    }
                } else {
                    addBuffer(j);
                }
            }
        }
    } while(!last);
    flushBuffer();

    byteAlign();
    return 0;
};

JXG.Util.Unzip.prototype.unzipFile = function(name) {
    var i;
	this.unzip();
	//alert(unzipped[0][1]);
	for (i=0;i<unzipped.length;i++){
		if(unzipped[i][1]==name) {
			return unzipped[i][0];
		}
	}
	
  };
    
    
JXG.Util.Unzip.prototype.unzip = function() {
	//convertToByteArray(input);
	if (debug)
		alert(bA);
	/*for (i=0;i<bA.length*8;i++){
		document.write(readBit());
		if ((i+1)%8==0)
			document.write(" ");
	}*/
	/*for (i=0;i<bA.length;i++){
		document.write(readByte()+" ");
		if ((i+1)%8==0)
			document.write(" ");
	}
	for (i=0;i<bA.length;i++){
		document.write(bA[i]+" ");
		if ((i+1)%16==0)
			document.write("<br>");
	}	
	*/
	//alert(bA);
	nextFile();
	return unzipped;
  };
    
 function nextFile(){
 	if (debug)
 		alert("NEXTFILE");
 	outputArr = [];
 	var tmp = [];
 	modeZIP = false;
	tmp[0] = readByte();
	tmp[1] = readByte();
	if (debug)
		alert("type: "+tmp[0]+" "+tmp[1]);
	if (tmp[0] == parseInt("78",16) && tmp[1] == parseInt("da",16)){ //GZIP
		if (debug)
			alert("GEONExT-GZIP");
		DeflateLoop();
		if (debug)
			alert(outputArr.join(''));
		unzipped[files] = new Array(2);
    	unzipped[files][0] = outputArr.join('');
    	unzipped[files][1] = "geonext.gxt";
    	files++;
	}
	if (tmp[0] == parseInt("1f",16) && tmp[1] == parseInt("8b",16)){ //GZIP
		if (debug)
			alert("GZIP");
		//DeflateLoop();
		skipdir();
		if (debug)
			alert(outputArr.join(''));
		unzipped[files] = new Array(2);
    	unzipped[files][0] = outputArr.join('');
    	unzipped[files][1] = "file";
    	files++;
	}
	if (tmp[0] == parseInt("50",16) && tmp[1] == parseInt("4b",16)){ //ZIP
		modeZIP = true;
		tmp[2] = readByte();
		tmp[3] = readByte();
		if (tmp[2] == parseInt("3",16) && tmp[3] == parseInt("4",16)){
			//MODE_ZIP
			tmp[0] = readByte();
			tmp[1] = readByte();
			if (debug)
				alert("ZIP-Version: "+tmp[1]+" "+tmp[0]/10+"."+tmp[0]%10);
			
			gpflags = readByte();
			gpflags |= (readByte()<<8);
			if (debug)
				alert("gpflags: "+gpflags);
			
			var method = readByte();
			method |= (readByte()<<8);
			if (debug)
				alert("method: "+method);
			
			readByte();
			readByte();
			readByte();
			readByte();
			
			var crc = readByte();
			crc |= (readByte()<<8);
			crc |= (readByte()<<16);
			crc |= (readByte()<<24);
			
			var compSize = readByte();
			compSize |= (readByte()<<8);
			compSize |= (readByte()<<16);
			compSize |= (readByte()<<24);
			
			var size = readByte();
			size |= (readByte()<<8);
			size |= (readByte()<<16);
			size |= (readByte()<<24);
			
			if (debug)
				alert("local CRC: "+crc+"\nlocal Size: "+size+"\nlocal CompSize: "+compSize);
			
			var filelen = readByte();
			filelen |= (readByte()<<8);
			
			var extralen = readByte();
			extralen |= (readByte()<<8);
			
			if (debug)
				alert("filelen "+filelen);
			i = 0;
			nameBuf = [];
			while (filelen--){ 
				var c = readByte();
				if (c == "/" | c ==":"){
					i = 0;
				} else if (i < NAMEMAX-1)
					nameBuf[i++] = String.fromCharCode(c);
			}
			if (debug)
				alert("nameBuf: "+nameBuf);
			
			//nameBuf[i] = "\0";
			if (!fileout)
				fileout = nameBuf;
			
			var i = 0;
			while (i < extralen){
				c = readByte();
				i++;
			}
				
			CRC = 0xffffffff;
			SIZE = 0;
			
			if (size = 0 && fileOut.charAt(fileout.length-1)=="/"){
				//skipdir
				if (debug)
					alert("skipdir");
			}
			if (method == 8){
				DeflateLoop();
				if (debug)
					alert(outputArr.join(''));
				unzipped[files] = new Array(2);
				unzipped[files][0] = outputArr.join('');
    			unzipped[files][1] = nameBuf.join('');
    			files++;
				//return outputArr.join('');
			}
			skipdir();
		}
	}
 };
	
function skipdir(){
    var crc, 
        tmp = [],
        compSize, size, os, i, c;
    
	if ((gpflags & 8)) {
		tmp[0] = readByte();
		tmp[1] = readByte();
		tmp[2] = readByte();
		tmp[3] = readByte();
		
		if (tmp[0] == parseInt("50",16) && 
            tmp[1] == parseInt("4b",16) && 
            tmp[2] == parseInt("07",16) && 
            tmp[3] == parseInt("08",16))
        {
            crc = readByte();
            crc |= (readByte()<<8);
            crc |= (readByte()<<16);
            crc |= (readByte()<<24);
		} else {
			crc = tmp[0] | (tmp[1]<<8) | (tmp[2]<<16) | (tmp[3]<<24);
		}
		
		compSize = readByte();
		compSize |= (readByte()<<8);
		compSize |= (readByte()<<16);
		compSize |= (readByte()<<24);
		
		size = readByte();
		size |= (readByte()<<8);
		size |= (readByte()<<16);
		size |= (readByte()<<24);
		
		if (debug)
			alert("CRC:");
	}

	if (modeZIP)
		nextFile();
	
	tmp[0] = readByte();
	if (tmp[0] != 8) {
		if (debug)
			alert("Unknown compression method!");
        return 0;	
	}
	
	gpflags = readByte();
	if (debug){
		if ((gpflags & ~(parseInt("1f",16))))
			alert("Unknown flags set!");
	}
	
	readByte();
	readByte();
	readByte();
	readByte();
	
	readByte();
	os = readByte();
	
	if ((gpflags & 4)){
		tmp[0] = readByte();
		tmp[2] = readByte();
		len = tmp[0] + 256*tmp[1];
		if (debug)
			alert("Extra field size: "+len);
		for (i=0;i<len;i++)
			readByte();
	}
	
	if ((gpflags & 8)){
		i=0;
		nameBuf=[];
		while (c=readByte()){
			if(c == "7" || c == ":")
				i=0;
			if (i<NAMEMAX-1)
				nameBuf[i++] = c;
		}
		//nameBuf[i] = "\0";
		if (debug)
			alert("original file name: "+nameBuf);
	}
		
	if ((gpflags & 16)){
		while (c=readByte()){
			//FILE COMMENT
		}
	}
	
	if ((gpflags & 2)){
		readByte();
		readByte();
	}
	
	DeflateLoop();
	
	crc = readByte();
	crc |= (readByte()<<8);
	crc |= (readByte()<<16);
	crc |= (readByte()<<24);
	
	size = readByte();
	size |= (readByte()<<8);
	size |= (readByte()<<16);
	size |= (readByte()<<24);
	
	if (modeZIP)
		nextFile();
	
};

};

/**
*  Base64 encoding / decoding
*  @see <a href="http://www.webtoolkit.info/">http://www.webtoolkit.info/</A>
*/
JXG.Util.Base64 = {

    // private property
    _keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

    // public method for encoding
    encode : function (input) {
        var output = [],
            chr1, chr2, chr3, enc1, enc2, enc3, enc4,
            i = 0;

        input = JXG.Util.Base64._utf8_encode(input);

        while (i < input.length) {

            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);

            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;

            if (isNaN(chr2)) {
                enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
                enc4 = 64;
            }

            output.push([this._keyStr.charAt(enc1),
                         this._keyStr.charAt(enc2),
                         this._keyStr.charAt(enc3),
                         this._keyStr.charAt(enc4)].join(''));
        }

        return output.join('');
    },

    // public method for decoding
    decode : function (input, utf8) {
        var output = [],
            chr1, chr2, chr3,
            enc1, enc2, enc3, enc4,
            i = 0;

        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

        while (i < input.length) {

            enc1 = this._keyStr.indexOf(input.charAt(i++));
            enc2 = this._keyStr.indexOf(input.charAt(i++));
            enc3 = this._keyStr.indexOf(input.charAt(i++));
            enc4 = this._keyStr.indexOf(input.charAt(i++));

            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;

            output.push(String.fromCharCode(chr1));

            if (enc3 != 64) {
                output.push(String.fromCharCode(chr2));
            }
            if (enc4 != 64) {
                output.push(String.fromCharCode(chr3));
            }
        }
        
        output = output.join(''); 
        
        if (utf8) {
            output = JXG.Util.Base64._utf8_decode(output);
        }
        return output;

    },

    // private method for UTF-8 encoding
    _utf8_encode : function (string) {
        string = string.replace(/\r\n/g,"\n");
        var utftext = "";

        for (var n = 0; n < string.length; n++) {

            var c = string.charCodeAt(n);

            if (c < 128) {
                utftext += String.fromCharCode(c);
            }
            else if((c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            }
            else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }

        }

        return utftext;
    },

    // private method for UTF-8 decoding
    _utf8_decode : function (utftext) {
        var string = [],
            i = 0,
            c = 0, c2 = 0, c3 = 0;

        while ( i < utftext.length ) {
            c = utftext.charCodeAt(i);
            if (c < 128) {
                string.push(String.fromCharCode(c));
                i++;
            }
            else if((c > 191) && (c < 224)) {
                c2 = utftext.charCodeAt(i+1);
                string.push(String.fromCharCode(((c & 31) << 6) | (c2 & 63)));
                i += 2;
            }
            else {
                c2 = utftext.charCodeAt(i+1);
                c3 = utftext.charCodeAt(i+2);
                string.push(String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)));
                i += 3;
            }
        }
        return string.join('');
    },
    
    _destrip: function (stripped, wrap){
        var lines = [], lineno, i,
            destripped = [];
        
        if (wrap==null) 
            wrap = 76;
            
        stripped.replace(/ /g, "");
        lineno = stripped.length / wrap;
        for (i = 0; i < lineno; i++)
            lines[i]=stripped.substr(i * wrap, wrap);
        if (lineno != stripped.length / wrap)
            lines[lines.length]=stripped.substr(lineno * wrap, stripped.length-(lineno * wrap));
            
        for (i = 0; i < lines.length; i++)
            destripped.push(lines[i]);
        return destripped.join('\n');
    },
    
    decodeAsArray: function (input){
        var dec = this.decode(input),
            ar = [], i;
        for (i=0;i<dec.length;i++){
            ar[i]=dec.charCodeAt(i);
        }
        return ar;
    },
    
    decodeGEONExT : function (input) {
        return decodeAsArray(destrip(input),false);
    }
};

/**
 * @private
 */
JXG.Util.asciiCharCodeAt = function(str,i){
	var c = str.charCodeAt(i);
	if (c>255){
    	switch (c) {
			case 8364: c=128;
	    	break;
	    	case 8218: c=130;
	    	break;
	    	case 402: c=131;
	    	break;
	    	case 8222: c=132;
	    	break;
	    	case 8230: c=133;
	    	break;
	    	case 8224: c=134;
	    	break;
	    	case 8225: c=135;
	    	break;
	    	case 710: c=136;
	    	break;
	    	case 8240: c=137;
	    	break;
	    	case 352: c=138;
	    	break;
	    	case 8249: c=139;
	    	break;
	    	case 338: c=140;
	    	break;
	    	case 381: c=142;
	    	break;
	    	case 8216: c=145;
	    	break;
	    	case 8217: c=146;
	    	break;
	    	case 8220: c=147;
	    	break;
	    	case 8221: c=148;
	    	break;
	    	case 8226: c=149;
	    	break;
	    	case 8211: c=150;
	    	break;
	    	case 8212: c=151;
	    	break;
	    	case 732: c=152;
	    	break;
	    	case 8482: c=153;
	    	break;
	    	case 353: c=154;
	    	break;
	    	case 8250: c=155;
	    	break;
	    	case 339: c=156;
	    	break;
	    	case 382: c=158;
	    	break;
	    	case 376: c=159;
	    	break;
	    	default:
	    	break;
	    }
	}
	return c;
};

/**
 * Decoding string into utf-8
 * @param {String} string to decode
 * @return {String} utf8 decoded string
 */
JXG.Util.utf8Decode = function(utftext) {
  var string = [];
  var i = 0;
  var c = 0, c1 = 0, c2 = 0;

  while ( i < utftext.length ) {
    c = utftext.charCodeAt(i);

    if (c < 128) {
      string.push(String.fromCharCode(c));
      i++;
    } else if((c > 191) && (c < 224)) {
      c2 = utftext.charCodeAt(i+1);
      string.push(String.fromCharCode(((c & 31) << 6) | (c2 & 63)));
      i += 2;
    } else {
      c2 = utftext.charCodeAt(i+1);
      c3 = utftext.charCodeAt(i+2);
      string.push(String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)));
      i += 3;
    }
  };
  return string.join('');
};

// Added to exports for Cocos2d
module.exports = JXG;

}};
__resources__["/__builtin__/libs/Plist.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/**
 * XML Node types
 */
var ELEMENT_NODE                = 1,
    ATTRIBUTE_NODE              = 2,
    TEXT_NODE                   = 3,
    CDATA_SECTION_NODE          = 4,
    ENTITY_REFERENCE_NODE       = 5,
    ENTITY_NODE                 = 6,
    PROCESSING_INSTRUCTION_NODE = 7,
    COMMENT_NODE                = 8,
    DOCUMENT_NODE               = 9,
    DOCUMENT_TYPE_NODE          = 10,
    DOCUMENT_FRAGMENT_NODE      = 11,
    NOTATION_NODE               = 12;


var Plist = BObject.extend (/** @lends Plist# */{
    /**
     * The unserialized data inside the Plist file
     * @type Object
     */
    data: null,

    /**
     * An object representation of an XML Property List file
     *
     * @constructs
     * @extends BObject
     * @param {Options} opts Options
     * @config {String} [file] The path to a .plist file
     * @config {String} [data] The contents of a .plist file
     */
    init: function(opts) {
        var file = opts['file'],
            data = opts['data'];

        if (file && !data) {
            data = resource(file);
        }


        var parser = new DOMParser(),
            doc = parser.parseFromString(data, 'text/xml'),
            plist = doc.documentElement;

        if (plist.tagName != 'plist') {
            throw "Not a plist file";
        }


        // Get first real node
        var node = null;
        for (var i = 0, len = plist.childNodes.length; i < len; i++) {
            node = plist.childNodes[i];
            if (node.nodeType == ELEMENT_NODE) {
                break;
            }
        }

        this.set('data', this.parseNode_(node));
    },


    /**
     * @private
     * Parses an XML node inside the Plist file
     * @returns {Object/Array/String/Integer/Float} A JS representation of the node value
     */
    parseNode_: function(node) {
        var data = null;
        switch(node.tagName) {
        case 'dict':
            data = this.parseDict_(node); 
            break;
        case 'array':
            data = this.parseArray_(node); 
            break;
        case 'string':
            // FIXME - This needs to handle Firefox's 4KB nodeValue limit
            data = node.firstChild.nodeValue;
            break
        case 'false':
            data = false;
            break
        case 'true':
            data = true;
            break
        case 'real':
            data = parseFloat(node.firstChild.nodeValue);
            break
        case 'integer':
            data = parseInt(node.firstChild.nodeValue, 10);
            break
        }

        return data;
    },

    /**
     * @private
     * Parses a <dict> node in a plist file
     *
     * @param {XMLElement}
     * @returns {Object} A simple key/value JS Object representing the <dict>
     */
    parseDict_: function(node) {
        var data = {};

        var key = null;
        for (var i = 0, len = node.childNodes.length; i < len; i++) {
            var child = node.childNodes[i];
            if (child.nodeType != ELEMENT_NODE) {
                continue;
            }

            // Grab the key, next noe should be the value
            if (child.tagName == 'key') {
                key = child.firstChild.nodeValue;
            } else {
                // Parse the value node
                data[key] = this.parseNode_(child);
            }
        }


        return data;
    },

    /**
     * @private
     * Parses an <array> node in a plist file
     *
     * @param {XMLElement}
     * @returns {Array} A simple JS Array representing the <array>
     */
    parseArray_: function(node) {
        var data = [];

        for (var i = 0, len = node.childNodes.length; i < len; i++) {
            var child = node.childNodes[i];
            if (child.nodeType != ELEMENT_NODE) {
                continue;
            }

            data.push(this.parseNode_(child));
        }

        return data;
    }
});


exports.Plist = Plist;

}};
__resources__["/__builtin__/libs/qunit.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
 * QUnit - A JavaScript Unit Testing Framework
 * 
 * http://docs.jquery.com/QUnit
 *
 * Copyright (c) 2011 John Resig, Jörn Zaefferer
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * or GPL (GPL-LICENSE.txt) licenses.
 */

(function(window) {

var defined = {
	setTimeout: typeof window.setTimeout !== "undefined",
	sessionStorage: (function() {
		try {
			return !!sessionStorage.getItem;
		} catch(e){
			return false;
		}
  })()
}

var testId = 0;

var Test = function(name, testName, expected, testEnvironmentArg, async, callback) {
	this.name = name;
	this.testName = testName;
	this.expected = expected;
	this.testEnvironmentArg = testEnvironmentArg;
	this.async = async;
	this.callback = callback;
	this.assertions = [];
};
Test.prototype = {
	init: function() {
		var tests = id("qunit-tests");
		if (tests) {
			var b = document.createElement("strong");
				b.innerHTML = "Running " + this.name;
			var li = document.createElement("li");
				li.appendChild( b );
				li.id = this.id = "test-output" + testId++;
			tests.appendChild( li );
		}
	},
	setup: function() {
		if (this.module != config.previousModule) {
			if ( config.previousModule ) {
				QUnit.moduleDone( {
					name: config.previousModule,
					failed: config.moduleStats.bad,
					passed: config.moduleStats.all - config.moduleStats.bad,
					total: config.moduleStats.all
				} );
			}
			config.previousModule = this.module;
			config.moduleStats = { all: 0, bad: 0 };
			QUnit.moduleStart( {
				name: this.module
			} );
		}

		config.current = this;
		this.testEnvironment = extend({
			setup: function() {},
			teardown: function() {}
		}, this.moduleTestEnvironment);
		if (this.testEnvironmentArg) {
			extend(this.testEnvironment, this.testEnvironmentArg);
		}

		QUnit.testStart( {
			name: this.testName
		} );

		// allow utility functions to access the current test environment
		// TODO why??
		QUnit.current_testEnvironment = this.testEnvironment;
		
		try {
			if ( !config.pollution ) {
				saveGlobal();
			}

			this.testEnvironment.setup.call(this.testEnvironment);
		} catch(e) {
			QUnit.ok( false, "Setup failed on " + this.testName + ": " + e.message );
		}
	},
	run: function() {
		if ( this.async ) {
			QUnit.stop();
		}

		if ( config.notrycatch ) {
			this.callback.call(this.testEnvironment);
			return;
		}
		try {
			this.callback.call(this.testEnvironment);
		} catch(e) {
			fail("Test " + this.testName + " died, exception and test follows", e, this.callback);
			QUnit.ok( false, "Died on test #" + (this.assertions.length + 1) + ": " + e.message + " - " + QUnit.jsDump.parse(e) );
			// else next test will carry the responsibility
			saveGlobal();

			// Restart the tests if they're blocking
			if ( config.blocking ) {
				start();
			}
		}
	},
	teardown: function() {
		try {
			checkPollution();
			this.testEnvironment.teardown.call(this.testEnvironment);
		} catch(e) {
			QUnit.ok( false, "Teardown failed on " + this.testName + ": " + e.message );
		}
	},
	finish: function() {
		if ( this.expected && this.expected != this.assertions.length ) {
			QUnit.ok( false, "Expected " + this.expected + " assertions, but " + this.assertions.length + " were run" );
		}
		
		var good = 0, bad = 0,
			tests = id("qunit-tests");

		config.stats.all += this.assertions.length;
		config.moduleStats.all += this.assertions.length;

		if ( tests ) {
			var ol  = document.createElement("ol");

			for ( var i = 0; i < this.assertions.length; i++ ) {
				var assertion = this.assertions[i];

				var li = document.createElement("li");
				li.className = assertion.result ? "pass" : "fail";
				li.innerHTML = assertion.message || (assertion.result ? "okay" : "failed");
				ol.appendChild( li );

				if ( assertion.result ) {
					good++;
				} else {
					bad++;
					config.stats.bad++;
					config.moduleStats.bad++;
				}
			}

			// store result when possible
			defined.sessionStorage && sessionStorage.setItem("qunit-" + this.testName, bad);

			if (bad == 0) {
				ol.style.display = "none";
			}

			var b = document.createElement("strong");
			b.innerHTML = this.name + " <b class='counts'>(<b class='failed'>" + bad + "</b>, <b class='passed'>" + good + "</b>, " + this.assertions.length + ")</b>";
			
			addEvent(b, "click", function() {
				var next = b.nextSibling, display = next.style.display;
				next.style.display = display === "none" ? "block" : "none";
			});
			
			addEvent(b, "dblclick", function(e) {
				var target = e && e.target ? e.target : window.event.srcElement;
				if ( target.nodeName.toLowerCase() == "span" || target.nodeName.toLowerCase() == "b" ) {
					target = target.parentNode;
				}
				if ( window.location && target.nodeName.toLowerCase() === "strong" ) {
					window.location.search = "?" + encodeURIComponent(getText([target]).replace(/\(.+\)$/, "").replace(/(^\s*|\s*$)/g, ""));
				}
			});

			var li = id(this.id);
			li.className = bad ? "fail" : "pass";
			li.style.display = resultDisplayStyle(!bad);
			li.removeChild( li.firstChild );
			li.appendChild( b );
			li.appendChild( ol );

		} else {
			for ( var i = 0; i < this.assertions.length; i++ ) {
				if ( !this.assertions[i].result ) {
					bad++;
					config.stats.bad++;
					config.moduleStats.bad++;
				}
			}
		}

		try {
			QUnit.reset();
		} catch(e) {
			fail("reset() failed, following Test " + this.testName + ", exception and reset fn follows", e, QUnit.reset);
		}

		QUnit.testDone( {
			name: this.testName,
			failed: bad,
			passed: this.assertions.length - bad,
			total: this.assertions.length
		} );
	},
	
	queue: function() {
		var test = this;
		synchronize(function() {
			test.init();
		});
		function run() {
			// each of these can by async
			synchronize(function() {
				test.setup();
			});
			synchronize(function() {
				test.run();
			});
			synchronize(function() {
				test.teardown();
			});
			synchronize(function() {
				test.finish();
			});
		}
		// defer when previous test run passed, if storage is available
		var bad = defined.sessionStorage && +sessionStorage.getItem("qunit-" + this.testName);
		if (bad) {
			run();
		} else {
			synchronize(run);
		};
	}
	
}

var QUnit = {

	// call on start of module test to prepend name to all tests
	module: function(name, testEnvironment) {
		config.currentModule = name;
		config.currentModuleTestEnviroment = testEnvironment;
	},

	asyncTest: function(testName, expected, callback) {
		if ( arguments.length === 2 ) {
			callback = expected;
			expected = 0;
		}

		QUnit.test(testName, expected, callback, true);
	},
	
	test: function(testName, expected, callback, async) {
		var name = '<span class="test-name">' + testName + '</span>', testEnvironmentArg;

		if ( arguments.length === 2 ) {
			callback = expected;
			expected = null;
		}
		// is 2nd argument a testEnvironment?
		if ( expected && typeof expected === 'object') {
			testEnvironmentArg =  expected;
			expected = null;
		}

		if ( config.currentModule ) {
			name = '<span class="module-name">' + config.currentModule + "</span>: " + name;
		}

		if ( !validTest(config.currentModule + ": " + testName) ) {
			return;
		}
		
		var test = new Test(name, testName, expected, testEnvironmentArg, async, callback);
		test.module = config.currentModule;
		test.moduleTestEnvironment = config.currentModuleTestEnviroment;
		test.queue();
	},
	
	/**
	 * Specify the number of expected assertions to gurantee that failed test (no assertions are run at all) don't slip through.
	 */
	expect: function(asserts) {
		config.current.expected = asserts;
	},

	/**
	 * Asserts true.
	 * @example ok( "asdfasdf".length > 5, "There must be at least 5 chars" );
	 */
	ok: function(a, msg) {
		a = !!a;
		var details = {
			result: a,
			message: msg
		};
		msg = escapeHtml(msg);
		QUnit.log(details);
		config.current.assertions.push({
			result: a,
			message: msg
		});
	},

	/**
	 * Checks that the first two arguments are equal, with an optional message.
	 * Prints out both actual and expected values.
	 *
	 * Prefered to ok( actual == expected, message )
	 *
	 * @example equal( format("Received {0} bytes.", 2), "Received 2 bytes." );
	 *
	 * @param Object actual
	 * @param Object expected
	 * @param String message (optional)
	 */
	equal: function(actual, expected, message) {
		QUnit.push(expected == actual, actual, expected, message);
	},

	notEqual: function(actual, expected, message) {
		QUnit.push(expected != actual, actual, expected, message);
	},
	
	deepEqual: function(actual, expected, message) {
		QUnit.push(QUnit.equiv(actual, expected), actual, expected, message);
	},

	notDeepEqual: function(actual, expected, message) {
		QUnit.push(!QUnit.equiv(actual, expected), actual, expected, message);
	},

	strictEqual: function(actual, expected, message) {
		QUnit.push(expected === actual, actual, expected, message);
	},

	notStrictEqual: function(actual, expected, message) {
		QUnit.push(expected !== actual, actual, expected, message);
	},

	raises: function(block, expected, message) {
		var actual, ok = false;
	
		if (typeof expected === 'string') {
			message = expected;
			expected = null;
		}
	
		try {
			block();
		} catch (e) {
			actual = e;
		}
	
		if (actual) {
			// we don't want to validate thrown error
			if (!expected) {
				ok = true;
			// expected is a regexp	
			} else if (QUnit.objectType(expected) === "regexp") {
				ok = expected.test(actual);
			// expected is a constructor	
			} else if (actual instanceof expected) {
				ok = true;
			// expected is a validation function which returns true is validation passed	
			} else if (expected.call({}, actual) === true) {
				ok = true;
			}
		}
			
		QUnit.ok(ok, message);
	},

	start: function() {
		config.semaphore--;
		if (config.semaphore > 0) {
			// don't start until equal number of stop-calls
			return;
		}
		if (config.semaphore < 0) {
			// ignore if start is called more often then stop
			config.semaphore = 0;
		}
		// A slight delay, to avoid any current callbacks
		if ( defined.setTimeout ) {
			window.setTimeout(function() {
				if ( config.timeout ) {
					clearTimeout(config.timeout);
				}

				config.blocking = false;
				process();
			}, 13);
		} else {
			config.blocking = false;
			process();
		}
	},
	
	stop: function(timeout) {
		config.semaphore++;
		config.blocking = true;

		if ( timeout && defined.setTimeout ) {
			clearTimeout(config.timeout);
			config.timeout = window.setTimeout(function() {
				QUnit.ok( false, "Test timed out" );
				QUnit.start();
			}, timeout);
		}
	}

};

// Backwards compatibility, deprecated
QUnit.equals = QUnit.equal;
QUnit.same = QUnit.deepEqual;

// Maintain internal state
var config = {
	// The queue of tests to run
	queue: [],

	// block until document ready
	blocking: true
};

// Load paramaters
(function() {
	var location = window.location || { search: "", protocol: "file:" },
		GETParams = location.search.slice(1).split('&');

	for ( var i = 0; i < GETParams.length; i++ ) {
		GETParams[i] = decodeURIComponent( GETParams[i] );
		if ( GETParams[i] === "noglobals" ) {
			GETParams.splice( i, 1 );
			i--;
			config.noglobals = true;
		} else if ( GETParams[i] === "notrycatch" ) {
			GETParams.splice( i, 1 );
			i--;
			config.notrycatch = true;
		} else if ( GETParams[i].search('=') > -1 ) {
			GETParams.splice( i, 1 );
			i--;
		}
	}
	
	// restrict modules/tests by get parameters
	config.filters = GETParams;
	
	// Figure out if we're running the tests from a server or not
	QUnit.isLocal = !!(location.protocol === 'file:');
})();

// Expose the API as global variables, unless an 'exports'
// object exists, in that case we assume we're in CommonJS
if ( typeof exports === "undefined" || typeof require === "undefined" ) {
	extend(window, QUnit);
	window.QUnit = QUnit;
} else {
	extend(exports, QUnit);
	exports.QUnit = QUnit;
}

// define these after exposing globals to keep them in these QUnit namespace only
extend(QUnit, {
	config: config,

	// Initialize the configuration options
	init: function() {
		extend(config, {
			stats: { all: 0, bad: 0 },
			moduleStats: { all: 0, bad: 0 },
			started: +new Date,
			updateRate: 1000,
			blocking: false,
			autostart: true,
			autorun: false,
			filters: [],
			queue: [],
			semaphore: 0
		});

		var tests = id("qunit-tests"),
			banner = id("qunit-banner"),
			result = id("qunit-testresult");

		if ( tests ) {
			tests.innerHTML = "";
		}

		if ( banner ) {
			banner.className = "";
		}

		if ( result ) {
			result.parentNode.removeChild( result );
		}
	},
	
	/**
	 * Resets the test setup. Useful for tests that modify the DOM.
	 * 
	 * If jQuery is available, uses jQuery's html(), otherwise just innerHTML.
	 */
	reset: function() {
		if ( window.jQuery ) {
			jQuery( "#main, #qunit-fixture" ).html( config.fixture );
		} else {
			var main = id( 'main' ) || id( 'qunit-fixture' );
			if ( main ) {
				main.innerHTML = config.fixture;
			}
		}
	},
	
	/**
	 * Trigger an event on an element.
	 *
	 * @example triggerEvent( document.body, "click" );
	 *
	 * @param DOMElement elem
	 * @param String type
	 */
	triggerEvent: function( elem, type, event ) {
		if ( document.createEvent ) {
			event = document.createEvent("MouseEvents");
			event.initMouseEvent(type, true, true, elem.ownerDocument.defaultView,
				0, 0, 0, 0, 0, false, false, false, false, 0, null);
			elem.dispatchEvent( event );

		} else if ( elem.fireEvent ) {
			elem.fireEvent("on"+type);
		}
	},
	
	// Safe object type checking
	is: function( type, obj ) {
		return QUnit.objectType( obj ) == type;
	},
	
	objectType: function( obj ) {
		if (typeof obj === "undefined") {
				return "undefined";

		// consider: typeof null === object
		}
		if (obj === null) {
				return "null";
		}

		var type = Object.prototype.toString.call( obj )
			.match(/^\[object\s(.*)\]$/)[1] || '';

		switch (type) {
				case 'Number':
						if (isNaN(obj)) {
								return "nan";
						} else {
								return "number";
						}
				case 'String':
				case 'Boolean':
				case 'Array':
				case 'Date':
				case 'RegExp':
				case 'Function':
						return type.toLowerCase();
		}
		if (typeof obj === "object") {
				return "object";
		}
		return undefined;
	},
	
	push: function(result, actual, expected, message) {
		var details = {
			result: result,
			message: message,
			actual: actual,
			expected: expected
		};
		
		message = escapeHtml(message) || (result ? "okay" : "failed");
		message = '<span class="test-message">' + message + "</span>";
		expected = escapeHtml(QUnit.jsDump.parse(expected));
		actual = escapeHtml(QUnit.jsDump.parse(actual));
		var output = message + '<table><tr class="test-expected"><th>Expected: </th><td><pre>' + expected + '</pre></td></tr>';
		if (actual != expected) {
			output += '<tr class="test-actual"><th>Result: </th><td><pre>' + actual + '</pre></td></tr>';
			output += '<tr class="test-diff"><th>Diff: </th><td><pre>' + QUnit.diff(expected, actual) +'</pre></td></tr>';
		}
		if (!result) {
			var source = sourceFromStacktrace();
			if (source) {
				details.source = source;
				output += '<tr class="test-source"><th>Source: </th><td><pre>' + source +'</pre></td></tr>';
			}
		}
		output += "</table>";
		
		QUnit.log(details);
		
		config.current.assertions.push({
			result: !!result,
			message: output
		});
	},
	
	// Logging callbacks; all receive a single argument with the listed properties
	// run test/logs.html for any related changes
	begin: function() {},
	// done: { failed, passed, total, runtime }
	done: function() {},
	// log: { result, actual, expected, message }
	log: function() {},
	// testStart: { name }
	testStart: function() {},
	// testDone: { name, failed, passed, total }
	testDone: function() {},
	// moduleStart: { name }
	moduleStart: function() {},
	// moduleDone: { name, failed, passed, total }
	moduleDone: function() {}
});

if ( typeof document === "undefined" || document.readyState === "complete" ) {
	config.autorun = true;
}

addEvent(window, "load", function() {
	QUnit.begin({});
	
	// Initialize the config, saving the execution queue
	var oldconfig = extend({}, config);
	QUnit.init();
	extend(config, oldconfig);

	config.blocking = false;

	var userAgent = id("qunit-userAgent");
	if ( userAgent ) {
		userAgent.innerHTML = navigator.userAgent;
	}
	var banner = id("qunit-header");
	if ( banner ) {
		var paramsIndex = location.href.lastIndexOf(location.search);
		if ( paramsIndex > -1 ) {
			var mainPageLocation = location.href.slice(0, paramsIndex);
			if ( mainPageLocation == location.href ) {
				banner.innerHTML = '<a href=""> ' + banner.innerHTML + '</a> ';
			} else {
				var testName = decodeURIComponent(location.search.slice(1));
				banner.innerHTML = '<a href="' + mainPageLocation + '">' + banner.innerHTML + '</a> &#8250; <a href="">' + testName + '</a>';
			}
		}
	}
	
	var toolbar = id("qunit-testrunner-toolbar");
	if ( toolbar ) {
		var filter = document.createElement("input");
		filter.type = "checkbox";
		filter.id = "qunit-filter-pass";
		addEvent( filter, "click", function() {
			var li = document.getElementsByTagName("li");
			for ( var i = 0; i < li.length; i++ ) {
				if ( li[i].className.indexOf("pass") > -1 ) {
					li[i].style.display = filter.checked ? "none" : "";
				}
			}
			if ( defined.sessionStorage ) {
				sessionStorage.setItem("qunit-filter-passed-tests", filter.checked ? "true" : "");
			}
		});
		if ( defined.sessionStorage && sessionStorage.getItem("qunit-filter-passed-tests") ) {
			filter.checked = true;
		}
		toolbar.appendChild( filter );

		var label = document.createElement("label");
		label.setAttribute("for", "qunit-filter-pass");
		label.innerHTML = "Hide passed tests";
		toolbar.appendChild( label );
	}

	var main = id('main') || id('qunit-fixture');
	if ( main ) {
		config.fixture = main.innerHTML;
	}

	if (config.autostart) {
		QUnit.start();
	}
});

function done() {
	config.autorun = true;

	// Log the last module results
	if ( config.currentModule ) {
		QUnit.moduleDone( {
			name: config.currentModule,
			failed: config.moduleStats.bad,
			passed: config.moduleStats.all - config.moduleStats.bad,
			total: config.moduleStats.all
		} );
	}

	var banner = id("qunit-banner"),
		tests = id("qunit-tests"),
		runtime = +new Date - config.started,
		passed = config.stats.all - config.stats.bad,
		html = [
			'Tests completed in ',
			runtime,
			' milliseconds.<br/>',
			'<span class="passed">',
			passed,
			'</span> tests of <span class="total">',
			config.stats.all,
			'</span> passed, <span class="failed">',
			config.stats.bad,
			'</span> failed.'
		].join('');

	if ( banner ) {
		banner.className = (config.stats.bad ? "qunit-fail" : "qunit-pass");
	}

	if ( tests ) {	
		var result = id("qunit-testresult");

		if ( !result ) {
			result = document.createElement("p");
			result.id = "qunit-testresult";
			result.className = "result";
			tests.parentNode.insertBefore( result, tests.nextSibling );
		}

		result.innerHTML = html;
	}

	QUnit.done( {
		failed: config.stats.bad,
		passed: passed, 
		total: config.stats.all,
		runtime: runtime
	} );
}

function validTest( name ) {
	var i = config.filters.length,
		run = false;

	if ( !i ) {
		return true;
	}
	
	while ( i-- ) {
		var filter = config.filters[i],
			not = filter.charAt(0) == '!';

		if ( not ) {
			filter = filter.slice(1);
		}

		if ( name.indexOf(filter) !== -1 ) {
			return !not;
		}

		if ( not ) {
			run = true;
		}
	}

	return run;
}

// so far supports only Firefox, Chrome and Opera (buggy)
// could be extended in the future to use something like https://github.com/csnover/TraceKit
function sourceFromStacktrace() {
	try {
		throw new Error();
	} catch ( e ) {
		if (e.stacktrace) {
			// Opera
			return e.stacktrace.split("\n")[6];
		} else if (e.stack) {
			// Firefox, Chrome
			return e.stack.split("\n")[4];
		}
	}
}

function resultDisplayStyle(passed) {
	return passed && id("qunit-filter-pass") && id("qunit-filter-pass").checked ? 'none' : '';
}

function escapeHtml(s) {
	if (!s) {
		return "";
	}
	s = s + "";
	return s.replace(/[\&"<>\\]/g, function(s) {
		switch(s) {
			case "&": return "&amp;";
			case "\\": return "\\\\";
			case '"': return '\"';
			case "<": return "&lt;";
			case ">": return "&gt;";
			default: return s;
		}
	});
}

function synchronize( callback ) {
	config.queue.push( callback );

	if ( config.autorun && !config.blocking ) {
		process();
	}
}

function process() {
	var start = (new Date()).getTime();

	while ( config.queue.length && !config.blocking ) {
		if ( config.updateRate <= 0 || (((new Date()).getTime() - start) < config.updateRate) ) {
			config.queue.shift()();
		} else {
			window.setTimeout( process, 13 );
			break;
		}
	}
  if (!config.blocking && !config.queue.length) {
    done();
  }
}

function saveGlobal() {
	config.pollution = [];
	
	if ( config.noglobals ) {
		for ( var key in window ) {
			config.pollution.push( key );
		}
	}
}

function checkPollution( name ) {
	var old = config.pollution;
	saveGlobal();
	
	var newGlobals = diff( old, config.pollution );
	if ( newGlobals.length > 0 ) {
		ok( false, "Introduced global variable(s): " + newGlobals.join(", ") );
		config.current.expected++;
	}

	var deletedGlobals = diff( config.pollution, old );
	if ( deletedGlobals.length > 0 ) {
		ok( false, "Deleted global variable(s): " + deletedGlobals.join(", ") );
		config.current.expected++;
	}
}

// returns a new Array with the elements that are in a but not in b
function diff( a, b ) {
	var result = a.slice();
	for ( var i = 0; i < result.length; i++ ) {
		for ( var j = 0; j < b.length; j++ ) {
			if ( result[i] === b[j] ) {
				result.splice(i, 1);
				i--;
				break;
			}
		}
	}
	return result;
}

function fail(message, exception, callback) {
	if ( typeof console !== "undefined" && console.error && console.warn ) {
		console.error(message);
		console.error(exception);
		console.warn(callback.toString());

	} else if ( window.opera && opera.postError ) {
		opera.postError(message, exception, callback.toString);
	}
}

function extend(a, b) {
	for ( var prop in b ) {
		a[prop] = b[prop];
	}

	return a;
}

function addEvent(elem, type, fn) {
	if ( elem.addEventListener ) {
		elem.addEventListener( type, fn, false );
	} else if ( elem.attachEvent ) {
		elem.attachEvent( "on" + type, fn );
	} else {
		fn();
	}
}

function id(name) {
	return !!(typeof document !== "undefined" && document && document.getElementById) &&
		document.getElementById( name );
}

// Test for equality any JavaScript type.
// Discussions and reference: http://philrathe.com/articles/equiv
// Test suites: http://philrathe.com/tests/equiv
// Author: Philippe Rathé <prathe@gmail.com>
QUnit.equiv = function () {

    var innerEquiv; // the real equiv function
    var callers = []; // stack to decide between skip/abort functions
    var parents = []; // stack to avoiding loops from circular referencing

    // Call the o related callback with the given arguments.
    function bindCallbacks(o, callbacks, args) {
        var prop = QUnit.objectType(o);
        if (prop) {
            if (QUnit.objectType(callbacks[prop]) === "function") {
                return callbacks[prop].apply(callbacks, args);
            } else {
                return callbacks[prop]; // or undefined
            }
        }
    }
    
    var callbacks = function () {

        // for string, boolean, number and null
        function useStrictEquality(b, a) {
            if (b instanceof a.constructor || a instanceof b.constructor) {
                // to catch short annotaion VS 'new' annotation of a declaration
                // e.g. var i = 1;
                //      var j = new Number(1);
                return a == b;
            } else {
                return a === b;
            }
        }

        return {
            "string": useStrictEquality,
            "boolean": useStrictEquality,
            "number": useStrictEquality,
            "null": useStrictEquality,
            "undefined": useStrictEquality,

            "nan": function (b) {
                return isNaN(b);
            },

            "date": function (b, a) {
                return QUnit.objectType(b) === "date" && a.valueOf() === b.valueOf();
            },

            "regexp": function (b, a) {
                return QUnit.objectType(b) === "regexp" &&
                    a.source === b.source && // the regex itself
                    a.global === b.global && // and its modifers (gmi) ...
                    a.ignoreCase === b.ignoreCase &&
                    a.multiline === b.multiline;
            },

            // - skip when the property is a method of an instance (OOP)
            // - abort otherwise,
            //   initial === would have catch identical references anyway
            "function": function () {
                var caller = callers[callers.length - 1];
                return caller !== Object &&
                        typeof caller !== "undefined";
            },

            "array": function (b, a) {
                var i, j, loop;
                var len;

                // b could be an object literal here
                if ( ! (QUnit.objectType(b) === "array")) {
                    return false;
                }   
                
                len = a.length;
                if (len !== b.length) { // safe and faster
                    return false;
                }
                
                //track reference to avoid circular references
                parents.push(a);
                for (i = 0; i < len; i++) {
                    loop = false;
                    for(j=0;j<parents.length;j++){
                        if(parents[j] === a[i]){
                            loop = true;//dont rewalk array
                        }
                    }
                    if (!loop && ! innerEquiv(a[i], b[i])) {
                        parents.pop();
                        return false;
                    }
                }
                parents.pop();
                return true;
            },

            "object": function (b, a) {
                var i, j, loop;
                var eq = true; // unless we can proove it
                var aProperties = [], bProperties = []; // collection of strings

                // comparing constructors is more strict than using instanceof
                if ( a.constructor !== b.constructor) {
                    return false;
                }

                // stack constructor before traversing properties
                callers.push(a.constructor);
                //track reference to avoid circular references
                parents.push(a);
                
                for (i in a) { // be strict: don't ensures hasOwnProperty and go deep
                    loop = false;
                    for(j=0;j<parents.length;j++){
                        if(parents[j] === a[i])
                            loop = true; //don't go down the same path twice
                    }
                    aProperties.push(i); // collect a's properties

                    if (!loop && ! innerEquiv(a[i], b[i])) {
                        eq = false;
                        break;
                    }
                }

                callers.pop(); // unstack, we are done
                parents.pop();

                for (i in b) {
                    bProperties.push(i); // collect b's properties
                }

                // Ensures identical properties name
                return eq && innerEquiv(aProperties.sort(), bProperties.sort());
            }
        };
    }();

    innerEquiv = function () { // can take multiple arguments
        var args = Array.prototype.slice.apply(arguments);
        if (args.length < 2) {
            return true; // end transition
        }

        return (function (a, b) {
            if (a === b) {
                return true; // catch the most you can
            } else if (a === null || b === null || typeof a === "undefined" || typeof b === "undefined" || QUnit.objectType(a) !== QUnit.objectType(b)) {
                return false; // don't lose time with error prone cases
            } else {
                return bindCallbacks(a, callbacks, [b, a]);
            }

        // apply transition with (1..n) arguments
        })(args[0], args[1]) && arguments.callee.apply(this, args.splice(1, args.length -1));
    };

    return innerEquiv;

}();

/**
 * jsDump
 * Copyright (c) 2008 Ariel Flesler - aflesler(at)gmail(dot)com | http://flesler.blogspot.com
 * Licensed under BSD (http://www.opensource.org/licenses/bsd-license.php)
 * Date: 5/15/2008
 * @projectDescription Advanced and extensible data dumping for Javascript.
 * @version 1.0.0
 * @author Ariel Flesler
 * @link {http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html}
 */
QUnit.jsDump = (function() {
	function quote( str ) {
		return '"' + str.toString().replace(/"/g, '\\"') + '"';
	};
	function literal( o ) {
		return o + '';	
	};
	function join( pre, arr, post ) {
		var s = jsDump.separator(),
			base = jsDump.indent(),
			inner = jsDump.indent(1);
		if ( arr.join )
			arr = arr.join( ',' + s + inner );
		if ( !arr )
			return pre + post;
		return [ pre, inner + arr, base + post ].join(s);
	};
	function array( arr ) {
		var i = arr.length,	ret = Array(i);					
		this.up();
		while ( i-- )
			ret[i] = this.parse( arr[i] );				
		this.down();
		return join( '[', ret, ']' );
	};
	
	var reName = /^function (\w+)/;
	
	var jsDump = {
		parse:function( obj, type ) { //type is used mostly internally, you can fix a (custom)type in advance
			var	parser = this.parsers[ type || this.typeOf(obj) ];
			type = typeof parser;			
			
			return type == 'function' ? parser.call( this, obj ) :
				   type == 'string' ? parser :
				   this.parsers.error;
		},
		typeOf:function( obj ) {
			var type;
			if ( obj === null ) {
				type = "null";
			} else if (typeof obj === "undefined") {
				type = "undefined";
			} else if (QUnit.is("RegExp", obj)) {
				type = "regexp";
			} else if (QUnit.is("Date", obj)) {
				type = "date";
			} else if (QUnit.is("Function", obj)) {
				type = "function";
			} else if (typeof obj.setInterval !== undefined && typeof obj.document !== "undefined" && typeof obj.nodeType === "undefined") {
				type = "window";
			} else if (obj.nodeType === 9) {
				type = "document";
			} else if (obj.nodeType) {
				type = "node";
			} else if (typeof obj === "object" && typeof obj.length === "number" && obj.length >= 0) {
				type = "array";
			} else {
				type = typeof obj;
			}
			return type;
		},
		separator:function() {
			return this.multiline ?	this.HTML ? '<br />' : '\n' : this.HTML ? '&nbsp;' : ' ';
		},
		indent:function( extra ) {// extra can be a number, shortcut for increasing-calling-decreasing
			if ( !this.multiline )
				return '';
			var chr = this.indentChar;
			if ( this.HTML )
				chr = chr.replace(/\t/g,'   ').replace(/ /g,'&nbsp;');
			return Array( this._depth_ + (extra||0) ).join(chr);
		},
		up:function( a ) {
			this._depth_ += a || 1;
		},
		down:function( a ) {
			this._depth_ -= a || 1;
		},
		setParser:function( name, parser ) {
			this.parsers[name] = parser;
		},
		// The next 3 are exposed so you can use them
		quote:quote, 
		literal:literal,
		join:join,
		//
		_depth_: 1,
		// This is the list of parsers, to modify them, use jsDump.setParser
		parsers:{
			window: '[Window]',
			document: '[Document]',
			error:'[ERROR]', //when no parser is found, shouldn't happen
			unknown: '[Unknown]',
			'null':'null',
			undefined:'undefined',
			'function':function( fn ) {
				var ret = 'function',
					name = 'name' in fn ? fn.name : (reName.exec(fn)||[])[1];//functions never have name in IE
				if ( name )
					ret += ' ' + name;
				ret += '(';
				
				ret = [ ret, QUnit.jsDump.parse( fn, 'functionArgs' ), '){'].join('');
				return join( ret, QUnit.jsDump.parse(fn,'functionCode'), '}' );
			},
			array: array,
			nodelist: array,
			arguments: array,
			object:function( map ) {
				var ret = [ ];
				QUnit.jsDump.up();
				for ( var key in map )
					ret.push( QUnit.jsDump.parse(key,'key') + ': ' + QUnit.jsDump.parse(map[key]) );
				QUnit.jsDump.down();
				return join( '{', ret, '}' );
			},
			node:function( node ) {
				var open = QUnit.jsDump.HTML ? '&lt;' : '<',
					close = QUnit.jsDump.HTML ? '&gt;' : '>';
					
				var tag = node.nodeName.toLowerCase(),
					ret = open + tag;
					
				for ( var a in QUnit.jsDump.DOMAttrs ) {
					var val = node[QUnit.jsDump.DOMAttrs[a]];
					if ( val )
						ret += ' ' + a + '=' + QUnit.jsDump.parse( val, 'attribute' );
				}
				return ret + close + open + '/' + tag + close;
			},
			functionArgs:function( fn ) {//function calls it internally, it's the arguments part of the function
				var l = fn.length;
				if ( !l ) return '';				
				
				var args = Array(l);
				while ( l-- )
					args[l] = String.fromCharCode(97+l);//97 is 'a'
				return ' ' + args.join(', ') + ' ';
			},
			key:quote, //object calls it internally, the key part of an item in a map
			functionCode:'[code]', //function calls it internally, it's the content of the function
			attribute:quote, //node calls it internally, it's an html attribute value
			string:quote,
			date:quote,
			regexp:literal, //regex
			number:literal,
			'boolean':literal
		},
		DOMAttrs:{//attributes to dump from nodes, name=>realName
			id:'id',
			name:'name',
			'class':'className'
		},
		HTML:false,//if true, entities are escaped ( <, >, \t, space and \n )
		indentChar:'  ',//indentation unit
		multiline:true //if true, items in a collection, are separated by a \n, else just a space.
	};

	return jsDump;
})();

// from Sizzle.js
function getText( elems ) {
	var ret = "", elem;

	for ( var i = 0; elems[i]; i++ ) {
		elem = elems[i];

		// Get the text from text nodes and CDATA nodes
		if ( elem.nodeType === 3 || elem.nodeType === 4 ) {
			ret += elem.nodeValue;

		// Traverse everything else, except comment nodes
		} else if ( elem.nodeType !== 8 ) {
			ret += getText( elem.childNodes );
		}
	}

	return ret;
};

/*
 * Javascript Diff Algorithm
 *  By John Resig (http://ejohn.org/)
 *  Modified by Chu Alan "sprite"
 *
 * Released under the MIT license.
 *
 * More Info:
 *  http://ejohn.org/projects/javascript-diff-algorithm/
 *  
 * Usage: QUnit.diff(expected, actual)
 * 
 * QUnit.diff("the quick brown fox jumped over", "the quick fox jumps over") == "the  quick <del>brown </del> fox <del>jumped </del><ins>jumps </ins> over"
 */
QUnit.diff = (function() {
	function diff(o, n){
		var ns = new Object();
		var os = new Object();
		
		for (var i = 0; i < n.length; i++) {
			if (ns[n[i]] == null) 
				ns[n[i]] = {
					rows: new Array(),
					o: null
				};
			ns[n[i]].rows.push(i);
		}
		
		for (var i = 0; i < o.length; i++) {
			if (os[o[i]] == null) 
				os[o[i]] = {
					rows: new Array(),
					n: null
				};
			os[o[i]].rows.push(i);
		}
		
		for (var i in ns) {
			if (ns[i].rows.length == 1 && typeof(os[i]) != "undefined" && os[i].rows.length == 1) {
				n[ns[i].rows[0]] = {
					text: n[ns[i].rows[0]],
					row: os[i].rows[0]
				};
				o[os[i].rows[0]] = {
					text: o[os[i].rows[0]],
					row: ns[i].rows[0]
				};
			}
		}
		
		for (var i = 0; i < n.length - 1; i++) {
			if (n[i].text != null && n[i + 1].text == null && n[i].row + 1 < o.length && o[n[i].row + 1].text == null &&
			n[i + 1] == o[n[i].row + 1]) {
				n[i + 1] = {
					text: n[i + 1],
					row: n[i].row + 1
				};
				o[n[i].row + 1] = {
					text: o[n[i].row + 1],
					row: i + 1
				};
			}
		}
		
		for (var i = n.length - 1; i > 0; i--) {
			if (n[i].text != null && n[i - 1].text == null && n[i].row > 0 && o[n[i].row - 1].text == null &&
			n[i - 1] == o[n[i].row - 1]) {
				n[i - 1] = {
					text: n[i - 1],
					row: n[i].row - 1
				};
				o[n[i].row - 1] = {
					text: o[n[i].row - 1],
					row: i - 1
				};
			}
		}
		
		return {
			o: o,
			n: n
		};
	}
	
	return function(o, n){
		o = o.replace(/\s+$/, '');
		n = n.replace(/\s+$/, '');
		var out = diff(o == "" ? [] : o.split(/\s+/), n == "" ? [] : n.split(/\s+/));

		var str = "";
		
		var oSpace = o.match(/\s+/g);
		if (oSpace == null) {
			oSpace = [" "];
		}
		else {
			oSpace.push(" ");
		}
		var nSpace = n.match(/\s+/g);
		if (nSpace == null) {
			nSpace = [" "];
		}
		else {
			nSpace.push(" ");
		}
		
		if (out.n.length == 0) {
			for (var i = 0; i < out.o.length; i++) {
				str += '<del>' + out.o[i] + oSpace[i] + "</del>";
			}
		}
		else {
			if (out.n[0].text == null) {
				for (n = 0; n < out.o.length && out.o[n].text == null; n++) {
					str += '<del>' + out.o[n] + oSpace[n] + "</del>";
				}
			}
			
			for (var i = 0; i < out.n.length; i++) {
				if (out.n[i].text == null) {
					str += '<ins>' + out.n[i] + nSpace[i] + "</ins>";
				}
				else {
					var pre = "";
					
					for (n = out.n[i].row + 1; n < out.o.length && out.o[n].text == null; n++) {
						pre += '<del>' + out.o[n] + oSpace[n] + "</del>";
					}
					str += " " + out.n[i].text + nSpace[i] + pre;
				}
			}
		}
		
		return str;
	};
})();

})(this);

}};
__resources__["/__builtin__/libs/util.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
var path = require('path');

/**
 * @namespace
 * Useful utility functions
 */
var util = {
    /**
     * Merge two or more objects and return the result.
     *
     * @param {Object} firstObject First object to merge with
     * @param {Object} secondObject Second object to merge with
     * @param {Object} [...] More objects to merge
     * @returns {Object} A new object containing the properties of all the objects passed in
     */
    merge: function(firstObject, secondObject) {
        var result = {};

        for (var i = 0; i < arguments.length; i++) {
            var obj = arguments[i];

            for (var x in obj) {
                if (!obj.hasOwnProperty(x)) {
                    continue;
                }

                result[x] = obj[x];
            }
        };

        return result;
    },

    /**
     * Creates a deep copy of an object
     *
     * @param {Object} obj The Object to copy
     * @returns {Object} A copy of the original Object
     */
    copy: function(obj) {
        if (obj === null) {
            return null;
        }

        var copy;

        if (obj instanceof Array) {
            copy = [];
            for (var i = 0, len = obj.length; i < len; i++) {
                copy[i] = arguments.callee(obj[i]);
            }
        } else if (typeof(obj) == 'object') {
            if (typeof(obj.copy) == 'function') {
                copy = obj.copy();
            } else {
                copy = {};

                var o, x;
                for (x in obj) {
                    copy[x] = arguments.callee(obj[x]);
                }
            }
        } else {
            // Primative type. Doesn't need copying
            copy = obj;
        }

        return copy;
    },

    /**
     * Iterates over an array and calls a function for each item.
     *
     * @param {Array} arr An Array to iterate over
     * @param {Function} func A function to call for each item in the array
     * @returns {Array} The original array
     */
    each: function(arr, func) {
        var i = 0,
            len = arr.length;
        for (i = 0; i < len; i++) {
            func(arr[i], i);
        }

        return arr;
    },

    /**
     * Iterates over an array, calls a function for each item and returns the results.
     *
     * @param {Array} arr An Array to iterate over
     * @param {Function} func A function to call for each item in the array
     * @returns {Array} The return values from each function call
     */
    map: function(arr, func) {
        var i = 0,
            len = arr.length,
            result = [];

        for (i = 0; i < len; i++) {
            result.push(func(arr[i], i));
        }

        return result;
    },

    extend: function(target, ext) {
        if (arguments.length < 2) {
            throw "You must provide at least a target and 1 object to extend from"
        }

        var i, j, obj, key, val;

        for (i = 1; i < arguments.length; i++) {
            obj = arguments[i];
            for (key in obj) {
                // Don't copy built-ins
                if (!obj.hasOwnProperty(key)) {
                    continue;
                }

                val = obj[key];
                // Don't copy undefineds or references to target (would cause infinite loop)
                if (val === undefined || val === target) {
                    continue;
                }

                // Replace existing function and store reference to it in .base
                if (val instanceof Function && target[key] && val !== target[key]) {
                    val.base = target[key];
                    val._isProperty = val.base._isProperty;
                }
                target[key] = val;

                if (val instanceof Function) {
                    // If this function observes make a reference to it so we can set
                    // them up when this get instantiated
                    if (val._observing) {
                        // Force a COPY of the array or we will probably end up with various
                        // classes sharing the same one.
                        if (!target._observingFunctions) {
                            target._observingFunctions = [];
                        } else {
                            target._observingFunctions = target._observingFunctions.slice(0);
                        }


                        for (j = 0; j<val._observing.length; j++) {
                            target._observingFunctions.push({property:val._observing[j], method: key});
                        }
                    } // if (val._observing)

                    // If this is a computer property then add it to the list so get/set know where to look
                    if (val._isProperty) {
                        if (!target._computedProperties) {
                            target._computedProperties = [];
                        } else {
                            target._computedProperties = target._computedProperties.slice(0);
                        }

                        target._computedProperties.push(key)
                    }
                }
        
            }
        }


        return target;
    },

    beget: function(o) {
        var F = function(){};
        F.prototype = o;
        var ret  = new F();
        F.prototype = null;
        return ret;
    },

    callback: function(target, method) {
        if (typeof(method) == 'string') {
            var methodName = method;
            method = target[method];
            if (!method) {
                throw "Callback to undefined method: " + methodName;
            }
        }
        if (!method) {
            throw "Callback with no method to call";
        }

        return function() {
            method.apply(target, arguments);
        }
    },

    domReady: function() {
        if (this._isReady) {
            return;
        }

        if (!document.body) {
            setTimeout(function() { util.domReady(); }, 13);
        }

        window.__isReady = true;

        if (window.__readyList) {
            var fn, i = 0;
            while ( (fn = window.__readyList[ i++ ]) ) {
                fn.call(document);
            }

            window.__readyList = null;
            delete window.__readyList;
        }
    },


    /**
     * Adapted from jQuery
     * @ignore
     */
    bindReady: function() {

        if (window.__readyBound) {
            return;
        }

        window.__readyBound = true;

        // Catch cases where $(document).ready() is called after the
        // browser event has already occurred.
        if ( document.readyState === "complete" ) {
            return util.domReady();
        }

        // Mozilla, Opera and webkit nightlies currently support this event
        if ( document.addEventListener ) {
            // Use the handy event callback
            //document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );
            
            // A fallback to window.onload, that will always work
            window.addEventListener( "load", util.domReady, false );

        // If IE event model is used
        } else if ( document.attachEvent ) {
            // ensure firing before onload,
            // maybe late but safe also for iframes
            //document.attachEvent("onreadystatechange", DOMContentLoaded);
            
            // A fallback to window.onload, that will always work
            window.attachEvent( "onload", util.domReady );

            // If IE and not a frame
            /*
            // continually check to see if the document is ready
            var toplevel = false;

            try {
                toplevel = window.frameElement == null;
            } catch(e) {}

            if ( document.documentElement.doScroll && toplevel ) {
                doScrollCheck();
            }
            */
        }
    },



    ready: function(func) {
        if (window.__isReady) {
            func()
        } else {
            if (!window.__readyList) {
                window.__readyList = [];
            }
            window.__readyList.push(func);
        }

        util.bindReady();
    },


    /**
     * Tests if a given object is an Array
     *
     * @param {Array} ar The object to test
     *
     * @returns {Boolean} True if it is an Array, otherwise false
     */
    isArray: function(ar) {
      return ar instanceof Array
          || (ar && ar !== Object.prototype && util.isArray(ar.__proto__));
    },


    /**
     * Tests if a given object is a RegExp
     *
     * @param {RegExp} ar The object to test
     *
     * @returns {Boolean} True if it is an RegExp, otherwise false
     */
    isRegExp: function(re) {
      var s = ""+re;
      return re instanceof RegExp // easy case
          || typeof(re) === "function" // duck-type for context-switching evalcx case
          && re.constructor.name === "RegExp"
          && re.compile
          && re.test
          && re.exec
          && s.charAt(0) === "/"
          && s.substr(-1) === "/";
    },


    /**
     * Tests if a given object is a Date
     *
     * @param {Date} ar The object to test
     *
     * @returns {Boolean} True if it is an Date, otherwise false
     */
    isDate: function(d) {
        if (d instanceof Date) return true;
        if (typeof d !== "object") return false;
        var properties = Date.prototype && Object.getOwnPropertyNames(Date.prototype);
        var proto = d.__proto__ && Object.getOwnPropertyNames(d.__proto__);
        return JSON.stringify(proto) === JSON.stringify(properties);
    },

    /**
     * Utility to populate a namespace's index with its modules
     *
     * @param {Object} parent The module the namespace lives in. parent.exports will be populated automatically
     * @param {String} modules A space separated string of all the module names
     *
     * @returns {Object} The index namespace
     */
    populateIndex: function(parent, modules) {
        var namespace = {};
        modules = modules.split(' ');

        util.each(modules, function(mod, i) {
            // Use the global 'require' which allows overriding the parent module
            util.extend(namespace, window.require('./' + mod, parent));
        });

        util.extend(parent.exports, namespace);

        return namespace;
    }


}

util.extend(String.prototype, /** @scope String.prototype */ {
    /**
     * Create an array of words from a string
     *
     * @returns {String[]} Array of the words in the string
     */
    w: function() {
        return this.split(' ');
    }
});




module.exports = util;

}};
__resources__["/__builtin__/path.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/** @namespace */
var path = {
    /**
     * Returns full directory path for the filename given. The path must be formed using forward slashes '/'.
     *
     * @param {String} path Path to return the directory name of
     * @returns {String} Directory name
     */
    dirname: function(path) {
        var tokens = path.split('/');
        tokens.pop();
        return tokens.join('/');
    },

    /**
     * Returns just the filename portion of a path.
     *
     * @param {String} path Path to return the filename portion of
     * @returns {String} Filename
     */
    basename: function(path) {
        var tokens = path.split('/');
        return tokens[tokens.length-1];
    },

    /**
     * Joins multiple paths together to form a single path
     * @param {String} ... Any number of string arguments to join together
     * @returns {String} The joined path
     */
    join: function () {
        return module.exports.normalize(Array.prototype.join.call(arguments, "/"));
    },

    /**
     * Tests if a path exists
     *
     * @param {String} path Path to test
     * @returns {Boolean} True if the path exists, false if not
     */
    exists: function(path) {
        return (__resources__[path] !== undefined);
    },

    /**
     * @private
     */
    normalizeArray: function (parts, keepBlanks) {
      var directories = [], prev;
      for (var i = 0, l = parts.length - 1; i <= l; i++) {
        var directory = parts[i];

        // if it's blank, but it's not the first thing, and not the last thing, skip it.
        if (directory === "" && i !== 0 && i !== l && !keepBlanks) continue;

        // if it's a dot, and there was some previous dir already, then skip it.
        if (directory === "." && prev !== undefined) continue;

        // if it starts with "", and is a . or .., then skip it.
        if (directories.length === 1 && directories[0] === "" && (
            directory === "." || directory === "..")) continue;

        if (
          directory === ".."
          && directories.length
          && prev !== ".."
          && prev !== "."
          && prev !== undefined
          && (prev !== "" || keepBlanks)
        ) {
          directories.pop();
          prev = directories.slice(-1)[0]
        } else {
          if (prev === ".") directories.pop();
          directories.push(directory);
          prev = directory;
        }
      }
      return directories;
    },

    /**
     * Returns the real path by expanding any '.' and '..' portions
     *
     * @param {String} path Path to normalize
     * @param {Boolean} [keepBlanks=false] Whether to keep blanks. i.e. double slashes in a path
     * @returns {String} Normalized path
     */
    normalize: function (path, keepBlanks) {
      return module.exports.normalizeArray(path.split("/"), keepBlanks).join("/");
    }
};

module.exports = path;

}};
__resources__["/__builtin__/system.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/** @namespace */
var system = {
    /** @namespace */
    stdio: {
        /**
         * Print text and objects to the debug console if the browser has one
         * 
         * @param {*} Any value to output
         */
        print: function() {
            if (console) {
                console.log.apply(console, arguments);
            } else {
                // TODO
            }
        }
    }
};

if (window.console) {
    system.console = window.console
} else {
    system.console = {
        log: function(){}
    }
}

}};
__resources__["/AudioMixer.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
Copyright 2011, Carnegie Learning

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Cocos requires
var cocos = require('cocos2d');
var events = require('events');

// Static requires
var MOT = require('ModifyOverTime').ModifyOverTime;

// Project requires
var AudioTrack = require('AudioTrack').AudioTrack;

// Only need a single Audio Mixer, so the class is static
// Responsible for managing all the audio in the app
var AudioMixer = BObject.extend({
    sounds : null, // Dictionary of AudioTracks
    availible : false, // true if browser supports <audio>
    ogg : false, // true if browser supports ogg/oga format
    mp3 : false, // true is browser supports mp3 format
    muted : false, // Whether or not all audio should be muted
    volume : 1, // Master volume
    
    init: function () {
        AudioMixer.superclass.init.call(this);
        
        this.sounds = {};
        
        // If AudioMixer is disabled, do not do anything else
        if(!AudioMixer.enabled) {
            console.log("AudioMixer is currently disabled");
            return;
        }
        
        this.crossFadeComplete = this.crossFadeComplete.bind(this);

        var a = document.createElement('audio');
        // Detect <audio> capability
        if(a.canPlayType) {
            this.set('availible', true);
            
            // Detect ogg/oga capability
            var check = a.canPlayType('audio/ogg; codecs="vorbis"');
            if(check != '' && check != 'no') {
                this.set('ogg', true);
            }
            
            // Detect mp3 capability
            check = a.canPlayType('audio/mpeg;')
            if(check != '' && check != 'no') {
                this.set('mp3', true);
            }
        }
    },

    // Load a sound, do NOT supply a file extension with the filename
    loadSound: function(ref, filename) {
        if(!this.get('availible')) {
            return;
        }
        
        // Set file extension based on filetype(s) supported
        if(this.get('ogg')) {
            filename += '.ogg';
        }
        else if(this.get('mp3')) {
            filename += '.mp3';
        }
        else {
            console.log('Can play audio, but no supported audio type availible');
            return
        }
        
        if(!this.checkRef(ref)) {
            var sndList = this.get('sounds');
            
            try {
                sndList[ref] = AudioTrack.create(filename);
            }
            catch(exception) {
                console.log(exception);
            }
            
            this.set('sounds', sndList);
        }
        else {
            console.log('AudioTrack already exists at reference: ' + ref);
        }
    },

    // Plays a sound
    playSound: function(ref, force) {
        if(!this.availible) {
            return;
        }
        
        if(this.checkRef(ref)) {
            if(force) {
                this.sounds[ref].forcePlay();
            }
            else {
                this.sounds[ref].play();
            }
        }
    },

    // Sets a sound to loop continuously, also starts playing the sound if it is not already playing
    loopSound: function(ref) {
        if(!this.availible) {
            return;
        }
        
        if(this.checkRef(ref)) {
            this.sounds[ref].loop = true;
            
            this.playSound(ref);
        }
    },

    // Stops a sound, also disables looping
    stopSound: function(ref) {
        if(!this.availible) {
            return;
        }
        
        if(this.checkRef(ref)) {
            this.sounds[ref].loop = false;
            this.sounds[ref].stop();
        }
    },

    // Sets whether or not all sound is to be muted
    setMute: function(b) {
        if(!this.availible) {
            return;
        }
        
        this.muted = b;
        
        for(snd in this.sounds) {
            this.sounds[snd].setMute(b);
        }
    },

    // Sets the master volume
    setMasterVolume: function(v) {
        if(!this.availible) {
            return;
        }
        
        // Keep the volume level within acceptable range
        v = Math.min(Math.max(0, v), 1);
        
        this.volume = v;
        
        for(snd in this.sounds) {
            this.sounds[snd].updateMasterVolume(v);
        }
    },
    
    // Gets the specificied AudioTrack if it exists
    getSound: function(ref) {
        if(this.checkRef(ref)) {
            return this.get('sounds')[ref];
        }
        return null;
    },
    
    // Cross fades from the specified track to the other specified track over the specified duration
    crossFade: function(from, to, dur) {
        var f = this.getSound(from);
        var t = this.getSound(to);
        
        if(f && t) {
            MOT.create(1, -1, dur).bindFunc(f, f.setVolume);
            MOT.create(0, 1, dur).bindFunc(t, t.setVolume);
        }
        
        setTimeout(this.crossFadeComplete, dur * 1000);
    },
    
    crossFadeComplete: function() {
        events.trigger(this, 'crossFadeComplete');
    },

    // Checks to see if the reference has a valid entry in the dictionary
    checkRef: function(ref) {
        if(ref in this.sounds) {
            return true;
        }
        return false;
    }
});

// Static constants
AudioMixer.enabled = true; // Setting to false disables constructor, preventing audio from playing

exports.AudioMixer = AudioMixer
}};
__resources__["/AudioTrack.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
Copyright 2011, Carnegie Learning

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Cocos requires
var cocos = require('cocos2d')

// Wrapper class for the <audio> element
var AudioTrack = BObject.extend({
    audio : null, // Holds the actual audio element
    loop : false, // Whether or not the track should loop on ending
    isPlaying : false, // True if the track is current playing
    volume : 1, // [0-1] the volume for this specific AudioTrack
    masterVolume: 1, // [0-1] the volume of the AudioMixer
    init: function(file) {
        this.audio = document.createElement('audio');
        this.audio.setAttribute('src', file);
        this.audio.addEventListener('ended', this.endCallback.bind(this), false);
        this.set('isPlaying', false);
    },
    
    // Starts playing the audio if it is not already playing
    // Returns true if the audio started to play
    play: function() {
        if(this.audio.networkState != HTMLMediaElement.NETWORK_NO_SOURCE) {
            if(!this.get('isPlaying')) {
                this.audio.play();
                this.set('isPlaying', true);
                return true;
            }
        }
        return false;
    },
    
    // Forces the audio to start playing regardless of its current state
    forcePlay: function() {
        this.stop();
        this.play();
    },
    
    // Stops the audio if it is currently playing
    // Returns true if the audio was stopped
    stop: function() {
        if(this.audio.networkState != HTMLMediaElement.NETWORK_NO_SOURCE) {
            if(this.get('isPlaying')) {
                this.audio.pause();
                this.audio.currentTime = 0;
                this.set('isPlaying', false);
                return true;
            }
        }
        return false;
    },
    
    // Called when a track finishes playing, loops if needed
    endCallback: function() {
        this.set('isPlaying', false);
        
        if(this.get('loop')) {
            this.play();
        }
    },
    
    // Sets the muted attribute for the audio
    setMute: function(b) {
        if(this.audio.networkState != HTMLMediaElement.NETWORK_NO_SOURCE) {
            this.audio.muted = b;
        }
    },
    
    // Called by AudioMixer when the master volume level is changed
    updateMasterVolume: function(v) {
        if(this.audio.networkState != HTMLMediaElement.NETWORK_NO_SOURCE) {
            this.set('masterVolume', v);
            this.audio.volume = v * this.get('volume');
        }
    },
    
    // Called to change the volume of this specific AudioTrack
    setVolume: function(v) {
        if(this.audio.networkState != HTMLMediaElement.NETWORK_NO_SOURCE) {
            // Keep the volume level within acceptable range
            v = Math.min(Math.max(0, v), 1);
            
            this.set('volume', v);
            this.audio.volume = this.get('masterVolume') * v;
        }
    }
});

exports.AudioTrack = AudioTrack
}};
__resources__["/Background.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
Copyright 2011, Carnegie Learning

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

var cocos = require('cocos2d');

var PNode = require('PerspectiveNode').PerspectiveNode;
var RC = require('RaceControl').RaceControl;

var Background = cocos.nodes.Node.extend({
    init: function(lanes) {
        Background.superclass.init.call(this);
    },
    
    draw: function(context) {
        // Ground
        context.fillStyle = "#44AA22";
        context.fillRect(-10, -10, 820, 620);
        
        // Sky
        context.fillStyle = "#1122BB";
        context.fillRect(-10, -10, 820, PNode.horizonStart + 10);
        
        // Road
        context.fillStyle = "#808080";
        context.beginPath();
        context.moveTo(385,                PNode.horizonStart);
        context.lineTo(PNode.roadOffset,   610);
        context.lineTo(PNode.roadWidthPix, 610);
        context.lineTo(415,                PNode.horizonStart);
        context.closePath();
        context.fill();
        
        // Lanes
        context.fillStyle = "#FFFF00";
        context.lineWidth = 4
        
        if(RC.curNumLanes == 2) {
            context.beginPath();
            context.moveTo(400, PNode.horizonStart);
            context.lineTo(396, 610);
            context.lineTo(404, 610);
            context.lineTo(400, PNode.horizonStart);
            context.closePath();
            context.fill();
        }
        else if(RC.curNumLanes == 3) {
            var x = 400 - PNode.roadWidthPix / 9 * 1.5;
            
            context.beginPath();
            context.moveTo(395,   PNode.horizonStart);
            context.lineTo(x - 4, 610);
            context.lineTo(x + 4, 610);
            context.lineTo(395,   PNode.horizonStart);
            context.closePath();
            context.fill();
            
            x = 400 + PNode.roadWidthPix / 9 * 1.5;
            context.beginPath();
            context.moveTo(405,   PNode.horizonStart);
            context.lineTo(x - 4, 610);
            context.lineTo(x + 4, 610);
            context.lineTo(405,   PNode.horizonStart);
            context.fill();
        }
    },
});

exports.Background = Background
}};
__resources__["/Content.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
Copyright 2011, Carnegie Learning

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

// Project Imports
var FractionRenderer = require('FractionRenderer').FractionRenderer;
//var LabelBG = require('LabelBG').LabelBG; //HACK
var PieChart = require('PieChart').PieChart;

// Static Imports
var XML = require('XML').XML;

// Represents a single question to be answered by the player
var Content = BObject.extend({
    init: function(opts) {
        Content.superclass.init.call(this, opts);
    }
});

// Holds registered subclasses' creation functions
Content.registeredContent = {};

// Every defined subclass used should be registered, the cls should be the class
Content.registerContent = function(str, cls) {
    Content.registeredContent[str] = cls;
}

Content.initialize = function () {
    //Content.registerContent(LabelBG.identifier, LabelBG); //HACK
    Content.registerContent('Fraction', FractionRenderer);
    Content.registerContent('PieChart', PieChart);
}

Content._validateNode = function (xmlNode) {
    if(xmlNode.attributes.hasOwnProperty('TYPE')) {
        if(Content.registeredContent.hasOwnProperty(xmlNode.attributes.TYPE)) {
            return true;
        }
    }
    return false;
}

// Build Content subclass from parsed XML
Content.buildFrom = function(xmlNode) {
    if(Content._validateNode(xmlNode)) {
        var cs = XML.getChildByName(xmlNode, 'ContentSettings');
        if(cs) {
            return Content.registeredContent[xmlNode.attributes.TYPE].create.call(
                Content.registeredContent[xmlNode.attributes.TYPE], cs.attributes);
        }
    }
    
    return null;
}

exports.Content = Content;
}};
__resources__["/Dashboard.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
Copyright 2011, Carnegie Learning

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

var cocos = require('cocos2d');
var geom = require('geometry');

var PNode = require('PerspectiveNode').PerspectiveNode;
var RC = require('RaceControl').RaceControl;
var MOT = require('ModifyOverTime').ModifyOverTime;

// Displays the dashboard on the right hand side
// TODO: Add speedometer, race progress, medal tracker, penalty time
var Dashboard = cocos.nodes.Node.extend({
    elapsedTime  : 0,       // Time in race elapsed so far
    displayTime  : null,    // Timer displayed to player
    gaugeRadius  : 40,      // Radius of the gauges
    penaltyTime  : null,    // Displayed penalty time
    pTime        : 0.0,     // Stores numerical penalty time
    speed        : 0,       // Speed for speedometer
    currentSpeed : null,    // Numerically displayed speed
    lastS        : 0,       // Previous frame's speed
    maxSpeed     : 200,     // Maximum possible speed to display/calculate
    timerAcc     : 3,       // Number of digits to the right of the decimal place for timer accuracy
    pause        : false,   // Stores if the elapsed timer should be paused.
    speedMode    : 2,       // 0: m/s 1: kph 2: mph
    displayMedal : null,    // Holds the text representation for the current medal the player in on track to get
    playerZ      : 0,       // The player's current location
    goldZ        : 0,		// Z position of the gold medal car
    silverZ      : 0,		// Z position of the silver medal car 
    bronzeZ      : 0,		// Z position of the bronze medal car
	checkpoints	 : [],		// Z positions of the checkpoints
    
    init: function() {
        Dashboard.superclass.init.call(this);
        
        this.set('zOrder', 100);
        
        var opts = Object();
        
        // Create the visible timer
        opts['string'] = 'Elapsed Time';
        var disp = cocos.nodes.Label.create(opts);
        disp.set('position', new geom.Point(5, 35));
        disp.set('anchorPoint', new geom.Point(0, 0.5));
        this.addChild({child: disp});
        
        opts['string'] = '0.000';
        disp = cocos.nodes.Label.create(opts);
        disp.set('position', new geom.Point(5, 50));
        disp.set('anchorPoint', new geom.Point(0, 0.5));
        this.set('displayTime', disp)
        this.addChild({child: disp});
        
        
        // Create visible penalty timer
        opts['string'] = 'Penalty Time';
        disp = cocos.nodes.Label.create(opts);
        disp.set('position', new geom.Point(5, 85));
        disp.set('anchorPoint', new geom.Point(0, 0.5));
        this.addChild({child: disp});
        
        opts['string'] = '0.000';
        disp = cocos.nodes.Label.create(opts);
        disp.set('position', new geom.Point(5, 100));
        disp.set('anchorPoint', new geom.Point(0, 0.5));
        this.addChild({child: disp});
        this.set('penaltyTime', disp);
        
        // Create numerical speedometer
        opts['string'] = 'Speed';
        disp = cocos.nodes.Label.create(opts);
        disp.set('position', new geom.Point(5, 215));
        disp.set('anchorPoint', new geom.Point(0, 0.5));
        this.addChild({child: disp});
        
        opts['string'] = '0';
        disp = cocos.nodes.Label.create(opts);
        disp.set('position', new geom.Point(5, 230));
        disp.set('anchorPoint', new geom.Point(0, 0.5));
        this.addChild({child: disp});
        this.set('displaySpeed', disp);
        
        // Create textual medal meter
        opts['string'] = 'Medal';
        disp = cocos.nodes.Label.create(opts);
        disp.set('position', new geom.Point(5, 315));
        disp.set('anchorPoint', new geom.Point(0, 0.5));
        this.addChild({child: disp});
        
        opts['string'] = ' - ';
        disp = cocos.nodes.Label.create(opts);
        disp.set('position', new geom.Point(5, 330));
        disp.set('anchorPoint', new geom.Point(0, 0.5));
        this.addChild({child: disp});
        this.set('displayMedal', disp);
    },
    
    // Starts tracking time and updating the dashboard timer.
    start: function () {
        this.set('elapsedTime', 0)
        this.scheduleUpdate();
    },
    
    // Helper function for grabbing the elapsed + penalty time
    getTotalTime: function () {
        var tt = this.get('pTime') + this.elapsedTime;
        if(tt.toFixed) {
            tt = tt.toFixed(this.timerAcc);
        }
        return tt;
    },
    
    // Changes the current amount of penalty time accured
    modifyPenaltyTime: function(dt) {
        MOT.create(this.get('pTime'), dt, 1.0).bindTo('value', this, 'pTime');
    },
    
    // Sets the pause state
    pauseTimer: function () {
        this.pause = true;
    },
    
    // Unsets the pause state
    unpauseTimer: function () {
        this.pause = false;
    },
    
    // Updates the time
    update: function(dt) {
        if(!this.pause) {
            // Update elapsed timer
            var t = this.get('elapsedTime') + dt;
            this.set('elapsedTime', t);
            
            if(t > 0) {
                this.displayTime.set('string', t.toFixed(this.timerAcc));
            }
        }
        
        // Update penalty timer
        this.penaltyTime.set('string', parseFloat(this.get('pTime')).toFixed(this.timerAcc));
        
        // Update numerical speedometer
        this.displaySpeed.set('string', this.getConvertedSpeed());
    },
    
    // Updates the text under the medal meter to the indicated medal
    updateMedalText: function(p) {
        var txt;
        
        if(p > 0.75) {
            txt = 'Gold';
        }
        else if(p > 0.5) {
            txt = 'Silver';
        }
        else if(p > 0.25) {
            txt = 'Bronze';
        }
        else {
            txt = ' - ';
        }
        
        this.displayMedal.set('string', txt);
    },
    
    // Get speed converted to specified units
    getConvertedSpeed: function() {
        var s = this.getSpeed();
        
        if(this.speedMode == Dashboard.SPEED_M_PS) {
            if(s.toFixed) {
                s = s.toFixed(0);
            }
            s += ' m/s';
        }
        else if(this.speedMode == Dashboard.SPEED_KM_PH) {
            s = s * 36 / 10;
            if(s.toFixed) {
                s = s.toFixed(0);
            }
            s += ' kph';
        }
        else if(this.speedMode == Dashboard.SPEED_MI_PH) {
            s = s * 36 / 16;
            if(s.toFixed) {
                s = s.toFixed(0);
            }
            s += ' mph';
        }
        else {
            console.log('Invalid speedMode = ' + mode);
            return null;
        }
        
        return s;
    },
    
    // Getter for speed, accounts for the fact that 'speed' is 0 when paused
    getSpeed: function() {
        if(!this.pause) {
            return this.get('speed');
        }
        return this.lastS;
    },
    
    // Helper function for creating an arc of a circle filled with color
    fillArc: function (c, x, y, r, s, e, b) {
        c.beginPath();
        s += Math.PI;
        c.arc(x, y, r, s, s + e, b);
        c.lineTo(x, y);
        c.closePath();
        c.fill();
    },
    
    // Draws the dash
    draw: function(context) {
        context.fillStyle = "#8B7765";
        context.beginPath();
        context.moveTo(0,-10);
        context.lineTo(0,610);
        context.lineTo(110,610);
        context.lineTo(110,-10);
        context.closePath();
        context.fill();
        
        // Speedometer
        var r = this.gaugeRadius;
        
        // Interior fills
        context.fillStyle = '#202020';
        this.fillArc(context, 50, 200, r, 0               , Math.PI * 5 / 6, false);
        context.fillStyle = '#FF8C00';
        this.fillArc(context, 50, 200, r, Math.PI / 12 * 9, Math.PI / 12   , false);
        context.fillStyle = '#DD1111';
        this.fillArc(context, 50, 200, r, Math.PI / 6 * 5 , Math.PI / 6    , false);
        
        // Hash marks
        context.strokeStyle = '#FFFFFF';
        context.lineWidth = "2";
        var maxStep = 6
        for(var step = 1; step < maxStep; step += 1) {
            context.beginPath();
            context.moveTo(Math.sin(step*Math.PI/maxStep - Math.PI/2)*r + 50, Math.cos(step*Math.PI/maxStep - Math.PI/2)*-r + 200);
            context.lineTo(Math.sin(step*Math.PI/maxStep - Math.PI/2)*(r-10) + 50, Math.cos(step*Math.PI/maxStep - Math.PI/2)*-(r-10) + 200)
            context.closePath();
            context.stroke();
        }
        
        // Gauge frame
        context.strokeStyle = "#000000";
        context.lineWidth = "4";
        context.beginPath();
        context.arc(50, 200, r, 0, Math.PI, true);
        context.lineTo(10, 200);
        context.closePath();
        context.stroke();
        
        var s = this.getSpeed();
        var maxs = this.maxSpeed;
        
        // Needle outline
        context.beginPath();
        context.moveTo(50, 200);
        context.lineTo(Math.sin(s*Math.PI/maxs - Math.PI/2)*r + 50, Math.cos(s*Math.PI/maxs - Math.PI/2)*-r + 200);
        context.closePath();
        context.stroke();
        
        // Needle
        context.strokeStyle = "#11CC22";
        context.lineWidth = "2";
        context.beginPath();
        context.moveTo(50, 200);
        context.lineTo(Math.sin(s*Math.PI/maxs - Math.PI/2)*r + 50, Math.cos(s*Math.PI/maxs - Math.PI/2)*-r + 200);
        context.closePath();
        context.stroke();
        
        this.set('lastS', s);
        
        // Medalmeter
        
        // Interior fills
        context.fillStyle = RC.noMedal;
        this.fillArc(context, 50, 300, r, 0,               Math.PI / 4, false);
        context.fillStyle = RC.bronze;
        this.fillArc(context, 50, 300, r, Math.PI / 4,     Math.PI / 4, false);
        context.fillStyle = RC.silver;
        this.fillArc(context, 50, 300, r, Math.PI / 2,     Math.PI / 4, false);
        context.fillStyle = RC.gold;
        this.fillArc(context, 50, 300, r, Math.PI / 4 * 3, Math.PI / 4, false);
        
        // Gauge frame
        context.strokeStyle = "#000000";
        context.lineWidth = "4";
        context.beginPath();
        context.arc(50, 300, r, 0, Math.PI, true);
        context.lineTo(10, 300);
        context.closePath();
        context.stroke();
        
        
        // Negative time is bad for calculating the medal meter
        if(this.get('elapsedTime') > 0) {
            var p = this.pHelper(s);
            
            this.updateMedalText(p);
            
            // Needle outline
            context.strokeStyle = "000000";
            context.lineWidth = "4";
            context.beginPath();
            context.moveTo(50, 300);
            context.lineTo(Math.sin(Math.PI*p - Math.PI/2)*r + 50, Math.cos(Math.PI*p - Math.PI/2)*-r + 300)
            context.closePath();
            context.stroke();
            
            // Needle
            context.strokeStyle = "#11CC22";
            context.lineWidth = "2";
            context.beginPath();
            context.moveTo(50, 300);
            context.lineTo(Math.sin(Math.PI*p - Math.PI/2)*r + 50, Math.cos(Math.PI*p - Math.PI/2)*-r + 300)
            context.closePath();
            context.stroke();
            
            var m = this.pHelper(maxs);
            
            // Impossible grayed out area
            context.fillStyle = 'rgba(0,0,0,0.4)';
            this.fillArc(context, 50, 300, r, Math.PI, -1 * Math.PI * (1 - m), true);
        }
        
		// Draw minimap
        context.strokeStyle = "#FFFFFF";
        context.lineWidth = "2";
        context.beginPath();
        context.moveTo(50, 400);
        context.lineTo(50, 500)
        context.closePath();
        context.stroke();
        
        context.beginPath();
        context.moveTo(45, 400);
        context.lineTo(55, 400)
        context.closePath();
        context.stroke();
        
        context.beginPath();
        context.moveTo(45, 500);
        context.lineTo(55, 500)
        context.closePath();
        context.stroke();
		
		// Checkpoint hashmarks
		var cp = this.get('checkpoints')
		for(var i=0; i<cp.length; i++) {
			context.beginPath();
			context.moveTo(45, 500 - 100 * cp[i] / RC.finishLine);
			context.lineTo(55, 500 - 100 * cp[i] / RC.finishLine)
			context.closePath();
			context.stroke();
		}
        
        var colors = [RC.bronze, RC.silver, RC.gold]
        var pos = [this.get('bronzeZ'), this.get('silverZ'), this.get('goldZ')]
        
        for(var i = 0; i < 3; i++) {
            var p = pos[i] / RC.finishLine;
            if(p > 1) {
                p = 1;
            }
        
            context.fillStyle = "#000000";
            context.beginPath();
            context.arc(52, 500 - 100 * p, 5, 0, Math.PI * 2);
            context.closePath();
            context.fill();
            
            context.fillStyle = colors[i];
            context.beginPath();
            context.arc(52, 500 - 100 * p, 4, 0, Math.PI * 2);
            context.closePath();
            context.fill();
        }
        
        context.fillStyle = "#000000";
        context.beginPath();
        context.arc(48, 500 - 100 * (this.get('playerZ') / RC.finishLine), 5, 0, Math.PI * 2);
        context.closePath();
        context.fill();
        
        context.fillStyle = "#22DD22";
        context.beginPath();
        context.arc(48, 500 - 100 * (this.get('playerZ') / RC.finishLine), 4, 0, Math.PI * 2);
        context.closePath();
        context.fill();
    },
    
    // Helper function for calculating needle position
    // TODO: Possibly rewrite to account for proportial areas instead of statically sized areas
    pHelper: function (s) {
        // TODO: Add chaseDist back into this, otherwise calculation will be off by part of a meter
        var dc = PNode.cameraZ + 6;
        var tc = this.elapsedTime + this.get('pTime');
        
        var dr = Math.max(RC.finishLine - dc, 0);
        var tr = dr / s;
        var te = tr + tc;
        
        var p;
        
        for(var i=1; i<5; i+=1) {
        
            if(te < RC.times[i] || i==4) {
                p = 1 - (te - RC.times[i-1]) / (RC.times[i] - RC.times[i-1]);
                p = Math.min(Math.max(p, 0), 1);
                
                return p / 4 + (1 - 0.25 * i);
            }
        }
    },
});

// Speed setting constants
Dashboard.SPEED_M_PS = 0;
Dashboard.SPEED_KM_PH = 1;
Dashboard.SPEED_MI_PH = 2;

exports.Dashboard = Dashboard
}};
__resources__["/EndOfGameDisplay.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
Copyright 2011, Carnegie Learning

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

// Cocos imports
var cocos = require('cocos2d');
var geom = require('geometry');
var events = require('events');

// Static imports
var RC = require('RaceControl').RaceControl;
var MOT = require('ModifyOverTime').ModifyOverTime;

// Responsible for displaying the player's stats at the end of the game
EndOfGameDisplay = cocos.nodes.Node.extend({
    elapsedLabel    : null,     // Text label for the elapsed line
    elapsedTime     : null,     // Displays the elapsed time
    elapsedLink     : 0,        // Holds the raw value of elapsedTime
    incorrectLabel  : null,     // Text label for the incorrect line
    incorrects      : null,     // Displays the numer of incorrect answers
    incorrectsLink  : 0,        // Holds the raw value of incorrects
    xLabel          : null,     // Displays the multiplication symbol
    penalty         : null,     // Displays the time penalty for each incorrect answer
    eLabel          : null,     // Displays the equals sign
    totalPenalty    : null,     // Displays the total time lost to penalties
    totalPenLink    : 0,        // Holds the raw value of totalPenalty
    totalLabel      : null,     // Text label for the total line
    total           : null,     // Displays the total time including penalties
    totalLink       : 0,        // Holds the raw value of total
    
    step            : 0,        // Current animation step
    playRate        : 1,        // Play duration of the animations (1 = 100% time, 0.1 = 10% time or 10x speed)
    
    timeAmt         : 0.0,      // Elapsed time to display
    numPenalty      : 0,        // Number of penalties incurred
    abort           : false,    // Abort state of the game
    
    sliderX         : 10,       // X location of the slider on the medal line
    
    init: function (ta, np, a) {
        EndOfGameDisplay.superclass.init.call(this);
    
        this.set('timeAmt', ta);
        this.set('numPenalty', np);
        this.set('abort', a);
    
        var lbl;
        var opts = {};
        
        // Text label for time elapsed
        opts['string'] = 'Elapsed Time';
        lbl = cocos.nodes.Label.create(opts);
        lbl.set('position', new geom.Point(-500, 40));
        lbl.set('anchorPoint', new geom.Point(0, 0.5));
        this.set('elapsedLabel', lbl);
        
        // Displays time elapsed
        opts['string'] = '0.000';
        lbl = cocos.nodes.Label.create(opts);
        lbl.set('position', new geom.Point(350, 40));
        lbl.set('anchorPoint', new geom.Point(1, 0.5));
        this.set('elapsedTime', lbl);
        
////////////////////////////////////////////////////////////////////////////////////////////////////
        
        // Text label for the missed questions line
        opts['string'] = 'Incorrects';
        lbl = cocos.nodes.Label.create(opts);
        lbl.set('position', new geom.Point(-500, 80));
        lbl.set('anchorPoint', new geom.Point(0, 0.5));
        this.set('incorrectLabel', lbl);
        
        // Displays number of questions missed
        opts['string'] = '0';
        lbl = cocos.nodes.Label.create(opts);
        lbl.set('position', new geom.Point(100, 80));
        lbl.set('anchorPoint', new geom.Point(0, 0.5));
        this.set('incorrects', lbl);
        
        // Displays multiplication symbol
        opts['string'] = 'X';
        lbl = cocos.nodes.Label.create(opts);
        lbl.set('position', new geom.Point(120, 80));
        lbl.set('anchorPoint', new geom.Point(0, 0.5));
        this.set('xLabel', lbl);
        
        // Displays the penalty for each missed question
        opts['string'] = parseFloat(RC.penaltyTime).toFixed(3);
        lbl = cocos.nodes.Label.create(opts);
        lbl.set('position', new geom.Point(145, 80));
        lbl.set('anchorPoint', new geom.Point(0, 0.5));
        this.set('penalty', lbl);
        
        // Displays an equal sign
        opts['string'] = '=';
        lbl = cocos.nodes.Label.create(opts);
        lbl.set('position', new geom.Point(200, 80));
        lbl.set('anchorPoint', new geom.Point(0, 0.5));
        this.set('eLabel', lbl);
        
        // Subtotal for penalty time
        opts['string'] = '0.000';
        lbl = cocos.nodes.Label.create(opts);
        lbl.set('position', new geom.Point(350, 80));
        lbl.set('anchorPoint', new geom.Point(1, 0.5));
        this.set('totalPenalty', lbl);
        
////////////////////////////////////////////////////////////////////////////////////////////////////
        
        // Text label for the total line
        opts['string'] = 'Total Time';
        lbl = cocos.nodes.Label.create(opts);
        lbl.set('position', new geom.Point(-500, 120));
        lbl.set('anchorPoint', new geom.Point(0, 0.5));
        this.set('totalLabel', lbl);
        
        // Displays the overall time, including penalties
        opts['string'] = '0.000';
        lbl = cocos.nodes.Label.create(opts);
        lbl.set('position', new geom.Point(350, 120));
        lbl.set('anchorPoint', new geom.Point(1, 0.5));
        this.set('total', lbl);
        
        this.scheduleUpdate();
    },
    
    // Called every frame
    update: function(dt) {
        this.fix(this.get('elapsedTime'), this.get('elapsedLink'), 3);
        this.fix(this.get('incorrects'), this.get('incorrectsLink'), 0);
        this.fix(this.get('totalPenalty'), this.get('totalPenLink'), 3);
        this.fix(this.get('total'), this.get('totalLink'), 3);
    },
    
    // Keeps the label's string value fixed to three positions
    fix: function(l, v, p) {
        f = parseFloat(v);
        l.set('string', f.toFixed(p));
    },
    
    // Start the animation sequence
    start: function() {
        events.addListener(this, 'actionComplete', this.next.bind(this));
        this.next();
    },
    
    // Begins the next step in the animation process
    next: function() {
        var step = this.get('step');
        
        if(step == 0)
            this.slideLabelIn(this.get('elapsedLabel'), 0.75);
        else if(step == 1)
            this.totalLabelUp(this.get('elapsedTime'), 'elapsedLink', this.get('timeAmt'), 0.5);
        else if(step == 2)
            this.slideLabelIn(this.get('incorrectLabel'), 0.75);
        else if(step == 3)
            this.totalLabelUp(this.get('incorrects'), 'incorrectsLink', this.get('numPenalty'), 0.5);
        else if(step == 4)
            this.showLabel(this.get('xLabel'), 0.1);
        else if(step == 5)
            this.showLabel(this.get('penalty'), 0.1);
        else if(step == 6)
            this.showLabel(this.get('eLabel'), 0.1);
        else if(step == 7)
            this.totalLabelUp(this.get('totalPenalty'), 'totalPenLink', this.get('numPenalty') * RC.penaltyTime, 0.5);
        else if(step == 8)
            this.slideLabelIn(this.get('totalLabel'), 0.75);
        else if(step == 9) {
            var tt = this.get('timeAmt') + this.get('numPenalty') * RC.penaltyTime;
            this.totalLabelUp(this.get('total'), 'totalLink', tt, 1.0);
            
            var x;
            if(this.get('abort'))
                x = 380;
            else if(tt > RC.times[3])
                x = 290 + 90 * Math.min(1, tt / RC.times[4]);
            else
                x = 290 * (tt - RC.times[0]) / (RC.times[3] - RC.times[0]);
            
            MOT.create(this.get('sliderX'), x, 1.0).bind(this, 'sliderX');
        }
        else if(step == 10) {
            // "Stamp" the medal on the score sheet here
            var that = this;
            events.trigger(this, 'almostComplete');
            setTimeout(function() {events.trigger(that, 'actionComplete');}, 1000);
        }
        else if(step == 11) {
            // Motivational message / tip / advice popup
            events.trigger(this, 'complete');
        }
            
        this.set('step', step + 1);
    },
    
    skipAnimation: function () {
        this.playRate = 0.1;
    },
    
    // Slides a label in from the right
    slideLabelIn: function (l, d) {
        this.addChild({child: l});
        var a = cocos.actions.MoveTo.create({position: new geom.Point(10, l.get('position').y), duration: d * this.playRate});
        a.startWithTarget(l);
        l.runAction(a);
        
        var that = this;
        setTimeout(function() {events.trigger(that, 'actionComplete');}, d * 1000 * this.playRate);
    },
    
    // Totals a label up over time
    totalLabelUp: function(label, link, value, duration) {
        this.addChild({child: label});
        MOT.create(0, value, duration * this.playRate).bind(this, link);
        
        var that = this;
        setTimeout(function() {events.trigger(that, 'actionComplete');}, duration * 1000 * this.playRate);
    },
    
    // Causes a label to appear
    showLabel: function (l, d) {
        this.addChild({child: l});
        
        var that = this;
        setTimeout(function() {events.trigger(that, 'actionComplete');}, d * 1000 * this.playRate);
    },
    
    // Helper function that gives area percentage for medal time ranges
    proportions: function (i) {
        return (RC.times[i] - RC.times[i - 1]) / (RC.times[3] - RC.times[0]);
    },
    
    // Handles all the low level drawing calls
    // TODO: Unmagic number these
    draw: function (ctx) {
        // Draws the background of the window
        ctx.fillStyle = "#8B7765";
        ctx.fillRect(0, 0, 400, 450);
        
        // Draw the medal meter line
        var offset = 10;
        
        var run = this.proportions(1) * 290;
        ctx.fillStyle = RC.gold;
        ctx.fillRect(offset, 160, run, 20);
        offset += run;
        
        run = this.proportions(2) * 290;
        ctx.fillStyle = RC.silver;
        ctx.fillRect(offset, 160, run, 20);
        offset += run;
        
        run = this.proportions(3) * 290;
        ctx.fillStyle = RC.bronze;
        ctx.fillRect(offset, 160, run, 20);
        offset += run;
        
        ctx.fillStyle = RC.noMedal;
        ctx.fillRect(offset, 160, 390 - offset, 20);
        
        // Draw the indicator for the medal meter line
        var x = this.get('sliderX');
        ctx.fillStyle = "#CC2222";
        ctx.beginPath();
        ctx.moveTo(x    , 177);
        ctx.lineTo(x + 8, 150);
        ctx.lineTo(x - 8, 150);
        ctx.closePath();
        ctx.fill();
        
        if(this.get('step') >= 10) {
            // Draw the medal
            var t = this.get('timeAmt') + this.get('numPenalty') * RC.penaltyTime;
            if(this.get('abort'))
                ctx.fillStyle = RC.noMedal;
            else if(t < RC.times[1])
                ctx.fillStyle = RC.gold;
            else if(t < RC.times[2])
                ctx.fillStyle = RC.silver;
            else if(t < RC.times[3])
                ctx.fillStyle = RC.bronze;
            else
                ctx.fillStyle = RC.noMedal;
                
            ctx.beginPath();
            ctx.arc(300, 300, 80, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
        }
    }
});

exports.EndOfGameDisplay = EndOfGameDisplay
}};
__resources__["/FractionRenderer.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
Copyright 2011, Carnegie Learning

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

var cocos = require('cocos2d');
var geom = require('geometry');
var util = require('util');

// TODO: Subclass this off a Value/Expression class or have it pulled in when needed by such a class
var FractionRenderer = cocos.nodes.Node.extend({
    numerator   : 1,            // The numerator of the fraction
    denominator : 2,            // The denominator of the fraction
    whole       : null,         // The mixed number component of the fraction
    bgColor     : '#fff',       // Color of the background rectangle
    fontColor   : '#000',       // Color of the numerator and denominator (TODO: Seperate for numerator/denominator?)
    fontSize    : '16',         // Size of the numerator and denominator text
    fontName    : 'Helvetica',  // Font of the numerator and denominator
    lineColor   : '#a22',       // Color of the fraction bar between the numerator and denominator
    init: function(opts) {
        FractionRenderer.superclass.init.call(this);
        
        // Set properties from the option object
        util.each('numerator denominator whole bgColor fontColor seperatorColor fontName fontColor fontSize'.w(), util.callback(this, function (name) {
            if (opts[name]) {
                this.set(name, opts[name]);
            }
        }));
        
        // Create the numerical labels for the numerator and denominator
        var opts = Object();
        opts["string"] = this.get("numerator");
        opts["fontName"] = this.get("fontName");
        opts["fontColor"] = this.get("fontColor");
        opts["fontSize"] = this.get("fontSize");
        
        var n = cocos.nodes.Label.create(opts);
        n.bindTo('opacity', this, 'opacity');
        this.addChild({child: n});
        
        opts["string"] = this.get("denominator");
        var d = cocos.nodes.Label.create(opts);
        d.bindTo('opacity', this, 'opacity');
        this.addChild({child: d});
        
        // Figuring out combined content size
        var v = n.get('contentSize').height / 2 + d.get('contentSize').height / 2 + 36;
        var h = Math.max(n.get('contentSize').width, d.get('contentSize').width) + 10;
        
        // Regular fraction defaults
        if(this.get('whole') == null) {
            n.set('position', new geom.Point(0, -15));
            d.set('position', new geom.Point(0, 15));
            
            this.set('contentSize', new geom.Size(h, v));
        }
        // Account for the inclusion of a mixed number
        else {
            opts["string"] = this.get("whole");
            opts["fontSize"] *= 2;
            var w = cocos.nodes.Label.create(opts);
            w.bindTo('opacity', this, 'opacity');
            this.addChild({child: w});
            
            n.set('anchorPoint', new geom.Point(1, 0.5));
            n.set('position', new geom.Point(h / 2 + 2, -15));
            d.set('anchorPoint', new geom.Point(1, 0.5));
            d.set('position', new geom.Point(h / 2 + 2, 15));
            
            w.set('anchorPoint', new geom.Point(0, 0.5));
            w.set('position', new geom.Point(h / -2 - 2, 0));
            
            h += w.get('contentSize').width;
            
            this.set('contentSize', new geom.Size(h, v));
        }
    },
    
    // Draw the background and the horizontal fraction bar
    draw: function(context) {
        var size = this.get('contentSize');
    
        context.fillStyle = this.get('bgColor');
        context.beginPath();
        context.moveTo(size.width /  2, size.height /  2);
        context.lineTo(size.width /  2, size.height / -2);
        context.lineTo(size.width / -2, size.height / -2);
        context.lineTo(size.width / -2, size.height /  2);
        context.closePath();
        context.fill();
        
        context.strokeStyle = this.get('lineColor');
        context.beginPath();
        if(this.get('whole') == null) {
            context.moveTo(size.width / -4, 0);
            context.lineTo(size.width /  4, 0);
        }
        // Account for offset due to mixed number presence
        else {
            context.moveTo(2                 , 0);
            context.lineTo(size.width / 2 - 2, 0);
        }
        context.closePath();
        context.stroke();
    },
});

exports.FractionRenderer = FractionRenderer
}};
__resources__["/Intermission.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
Copyright 2011, Carnegie Learning

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

var cocos = require('cocos2d');
var events = require('events');
var geom = require('geometry');

var PNode = require('PerspectiveNode').PerspectiveNode;

// Represents a single question to be answered by the player
// TODO: Build with an options object to allow easier initialization when customizing away from default values
var Intermission = PNode.extend({
    fired       : false,        // True if the intermission has already fired
    selector    : null,         // Selector to change to during the intermission
    init: function(selector, z) {
        Intermission.superclass.init.call(this, {xCoordinate:0, zCoordinate: z});
        
        // Initialize all variables
        this.selector = selector;
        
        // Schedule the per frame update
        this.scheduleUpdate();
    },
    
    // Manages question timing and movement
    update: function(dt) {
        if(PNode.cameraZ + 6 >= this.get('zCoordinate') && !this.fired) {
            this.fired = true;
            events.trigger(this, 'changeSelector', this.selector, this.get('zCoordinate'));
        }
        
        Intermission.superclass.update.call(this, dt);
    },
});

// TODO: Write static helper for building an options object to initialize a question

exports.Intermission = Intermission
}};
__resources__["/KeyboardLayer.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
Copyright 2011, Carnegie Learning

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

// Import the cocos2d module
var cocos = require('cocos2d');
    
// Handles reading keyboard input, allows us to ignore "Key Repeat" settings as the key is either down, or up
var KeyboardLayer = cocos.nodes.Layer.extend({
    anyKey      : false,// true if any key has been pressed since the last time it was checked
    keys        : null, // Holds the array of key statuses
    bindings    : {},   // Holds the application specific bindings
    init: function() {
        // You must always call the super class version of init
        KeyboardLayer.superclass.init.call(this);
        
        // Enables detecting keypresses
        this.set('isKeyboardEnabled', true);
        
        // Build the array to hold keyboard state
        this.keys = Array(256);
        for(key in this.keys) {
            key = 0;
        }
    },
    
    // Sets key to true when pressed
    keyDown: function(evt) {
        this.anyKey = true;
        this.keys[evt.keyCode] = KeyboardLayer.PRESS;
    },
    
    // Sets key to false when no longer pressed
    keyUp: function(evt) {
        this.keys[evt.keyCode] = KeyboardLayer.UP;
    },
    
    // Check to see if a valid key is pressed
    // Returns false is the key was invalid or not pressed
    // Returns 1 if this is the first time we are detecting the press, 2 if we have detected this press previously
    checkKey: function(keyCode) {
        if(keyCode > -1 && keyCode < 256) {
            var ret = this.keys[keyCode];
            
            // Lets us know if we have polled this key before and the user has not let it back up
            if(ret == KeyboardLayer.PRESS) {
                this.keys[keyCode] = KeyboardLayer.HOLD;
            }
            
            return ret;
        }
        
        return false;
    },
    
    // Checks to see if any key has been pressed since it was last checked
    checkAnyKey: function() {
        if(this.anyKey) {
            this.anyKey = false;
            return true;
        }
        return false;
    },
    
    // Adds a key to a binding, or create the binding if none exists
    addToBinding: function(bind, to) {
        var b = this.get('bindings');
        
        if(!bind in b) {
            b[bind] = [to];
        }
        else {
            b[bind].push(to);
        }
        
        this.set('bindings', b);
        return true;
    },
    
    // Removes a key from a binding, returns false if bind or rm was not found
    removeFromBinding: function(bind, rm) {
        var b = this.get('bindings');
        
        if(bind in b) {
            var i=0
            while(i<b[bind].length && b[bind][i] != rm) {
                i+=1;
            }
            
            if(i<b[bind].length && b[bind][i] == rm) {
                b[bind].splice(i, 1);
                this.set('bindings', b);
                return true;
            }
        }
        return false;
    },
    
    // Explicitly set a binding to a list of keys
    setBinding: function(bind, list) {
        var b = this.get('bindings');
        b[bind] = list;
        this.set('bindings', b);
        return true;
    },
    
    // Clears all keys from a binding, returns false in bind was not in bindings
    clearBinding: function(bind, to) {
        var b = this.get('bindings');
        
        if(bind in b) {
            delete b[bind];
            this.set('bindings', b);
            return true;
        }
        return false;
    },
    
    // Checks to see if any key in the binding is pressed and returns the highest state of any such button pressed
    checkBinding: function(bind) {
        var ret = KeyboardLayer.UP;
        
        if(bind in this.bindings) {
            for(var i = 0; i < this.bindings[bind].length; i += 1) {
                var temp = this.checkKey(this.bindings[bind][i]);
                if(temp > ret) {
                    ret = temp;
                }
            }
            
            return ret;
        }
    },
});

// Static constants
KeyboardLayer.UP        = 0;    // Key is up and was not recently released
KeyboardLayer.PRESS     = 1;    // Key has just been pressed (KeyDown)
KeyboardLayer.HOLD      = 2;    // Key is down and not been released

exports.KeyboardLayer = KeyboardLayer
}};
__resources__["/LabelBG.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
Copyright 2011, Carnegie Learning

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

// Import the cocos2d module
var cocos = require('cocos2d');

// Global imports
var Content = require('Content').Content;

var LabelBG = cocos.nodes.Node.extend({
    label  : null,      //The label that the class wraps
    bgColor: '#FFFFFF', //The color of the background that will be behind the label
    
    init: function(opts) {
        // You must always call the super class version of init
        LabelBG.superclass.init.call(this, opts);
        
        opts['string']    = this.defaulter(opts, 'string',    '');
        opts['fontName']  = this.defaulter(opts, 'fontName',  'Helvetica');
        opts['fontColor'] = this.defaulter(opts, 'fontColor', '#000');
        opts['fontSize']  = this.defaulter(opts, 'fontSize',  '16');
        
        var label = cocos.nodes.Label.create(opts)
        label.bindTo('opacity', this, 'opacity');
        this.set('label', label);
        this.addChild({child: label});
        
        this.set('bgColor', this.defaulter(opts, 'bgColor', '#FFFFFF'));

        this.set('contentSize', this.get('label').get('contentSize'));
    },
    
    // Draws the background for the label
    draw: function(context) {
        var size = this.get('contentSize');
        
        context.fillStyle = this.get('bgColor');
        context.fillRect(size.width * -0.6, size.height * -0.75, size.width * 1.2, size.height * 1.5);
    },
    
    //TODO: Put into a utility script/class
    defaulter: function(obj, prop, def) {
        return obj.hasOwnProperty(prop) ? obj[prop] : def;
    }
});

// Static helper function to build the creation options object
LabelBG.helper = function(String, FontColor, BgColor, FontSize, FontName) {
    return {
        string      : String,
        fontColor   : FontColor,
        bgColor     : BgColor,
        fontSize    : FontSize,
        fontName    : FontName
    };
}

LabelBG.identifier = 'String';

exports.LabelBG = LabelBG
}};
__resources__["/main.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
Copyright 2011, Carnegie Learning

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

// Import the cocos2d module
var cocos = require('cocos2d');
var geo = require('geometry');
var events = require('events');

// Project Imports
var AudioMixer = require('AudioMixer').AudioMixer;
var Background = require('Background').Background;
var Dashboard = require('Dashboard').Dashboard
var Intermission = require('Intermission').Intermission;
var KeyboardLayer = require('KeyboardLayer').KeyboardLayer
var Player = require('Player').Player;
var PNode = require('PerspectiveNode').PerspectiveNode;
var Question = require('Question').Question;
var EOGD = require('EndOfGameDisplay').EndOfGameDisplay;
var Preloader = require('Preloader').Preloader;

var LabelBG = require('LabelBG').LabelBG;   //HACK

// Static Imports
var RC = require('RaceControl').RaceControl;
var MOT = require('ModifyOverTime').ModifyOverTime;
var XML = require('XML').XML;
var Content = require('Content').Content;

// TODO: De-magic number these
/* Zorder
-10 Background
-5  Finish Line
-4  Trees
-1  Dashboard
0   Anything not mentioned
100 Question Delimiters
*/

// Create a new layer
// TODO: Clean up main, it is getting bloated
var FluencyApp = KeyboardLayer.extend({
    player      : null,     // Holds the player
    background  : null,     // Holds the the background object
    dash        : null,     // Holds the right hand side dashboard
    questionList: [],       // List of all questions in the input
    audioMixer  : null,     // AudioMixer for sound effects
    musicMixer  : null,     // AudioMixer for music
    medalCars   : [],       // Contains the pace cars
    gameID      : '',       // Unique ID for the game
	inters		: [],       // Holds the list of checkpoints
    
    bgFade      : false,    // True when crossfading between bg tracks
    bgFast      : false,    // True when playing bg_fast, false when playing bg_slow
    
    lanePosX    : {2: [-2, 2], 3:[-3, 0, 3]},
    lane        : 1,
    
    endOfGameCallback : null,   //Holds the name of the window function to call back to at the end of the game
    
    version     : 'v 0.3.0',    // Current version number
    
    // Remote resources loaded successfully, proceed as normal
    runRemotely: function() {
        if(resource("resources/testset.xml") !== undefined) {
            this.parseXML(resource("resources/testset.xml"));
        }
        else {
            console.log("ERROR: No remote XML found to parse.");
        }
    },
    
    // Not the 'real init', sets up and starts preloading
    init: function() {
        // You must always call the super class version of init
        FluencyApp.superclass.init.call(this);
        
        Content.initialize();
        Content.registerContent(LabelBG.identifier, LabelBG);   //HACK
        
        // Explicitly enable audio
        AudioMixer.enabled = true;
        var dir = 'sound/';
        // Set up basic audio
        var AM = AudioMixer.create();
        AM.loadSound('screech',      dir + 'CarScreech2');
        AM.loadSound('decel',        dir + 'SlowDown');
        AM.loadSound('accel',        dir + 'SpeedUp');
        AM.loadSound('turbo',        dir + 'Turboboost');
        AM.loadSound('start',        dir + 'EngineStart');
        AM.loadSound('hum',          dir + 'Engine Hum');
        AM.loadSound('correct',      dir + 'Correct v1');
        AM.loadSound('wrong',        dir + 'Incorrect v1');
        AM.loadSound('finish',       dir + 'FinishLine v1');
        AM.loadSound('intermission', dir + 'Numberchange v1');
        AM.loadSound('countdown',    dir + 'countdown');
        this.set('audioMixer', AM);
        
        var MM = AudioMixer.create();
        MM.loadSound('bg_slow', dir + 'Racecar v3-2');
        MM.loadSound('bg_fast', dir + 'Racecar FAST v3-2');
        MM.loadSound('bg_open', dir + 'Racecar Opening Chord');
        this.set('musicMixer', MM);
        
        events.addListener(MM, 'crossFadeComplete', this.onCrossFadeComplete.bind(this));
        
        var preloader = Preloader.create();
        this.addChild({child: preloader});
        this.set('preloader', preloader);
        
        events.addListener(preloader, 'loaded', this.delayedInit.bind(this));
    },
    
    delayedInit: function() {
        // Remove the 'preloader'
        var preloader = this.get('preloader')
        this.removeChild({child: preloader});
        cocos.Scheduler.get('sharedScheduler').unscheduleUpdateForTarget(preloader);
        this.set('preloader', null);
    
        // Static binds
        this.addMeHandler = this.addMeHandler.bind(this)
        this.answerQuestion = this.answerQuestion.bind(this)
        this.removeMeHandler = this.removeMeHandler.bind(this)
        
        // Create player
        var player = Player.create();
        player.set('position', new geo.Point(400, 450));
        this.set('player', player);
        
        // Create dashboard
        var dash = Dashboard.create();
        dash.set('position', new geo.Point(800, 0));
        this.set('dash', dash);
        
        // Get "command line" arguments from the div tag
        var app_div = $('#cocos_test_app')
        var xml_path = app_div.attr('data');
        this.set('gameID', app_div.attr('gameid'));
        this.set('endOfGameCallback', app_div.attr('callback'));
        
        // Set up remote resources, default value allows for running 'locally'
        // TODO: Remove default in production, replace with error
        __remote_resources__["resources/testset.xml"] = {meta: {mimetype: "application/xml"}, data: xml_path ? xml_path : "set002.xml"};
        
        // Preload remote resources
        var p = cocos.Preloader.create();
        events.addListener(p, 'complete', this.runRemotely.bind(this));
        p.load();
        
        events.trigger(this, 'loaded');
    },
    
    // Parses the level xml file
    parseXML: function(xmlDoc) {
        var xml = XML.parser(xmlDoc.firstChild);
    
        var medals = this.parseMedals(xml); // Parse medal information
        this.parseAudio(xml);               // Parse the audio information
        this.parseSpeed(xml);               // Parse and set player speed values
        this.parsePenalty(xml);             // Get the penalty time for incorrect answers
    
        // Parse and process questions
        RC.finishLine = this.parseProblemSet(xml) + RC.finishSpacing;
        
        // Process medal information
        medals[0] = RC.finishLine / this.get('player').get('maxSpeed');
        medals[medals.length] = medals[medals.length - 1] * 1.5;
        RC.times = medals;

        // Sanity check
        if(medals[0] > medals[1]) {
            console.log("WARNING: Calculated minimum time (" + medal[0] +") is longer than the maximum allowed time for a gold medal (" + medal[1] +").");
        }
        
        this.preprocessingComplete();
    },
    
    // Parse the medal values
    parseMedals: function (xml) {
        var ret = [];
        var node = XML.getDeepChildByName(xml, 'MEDALS');
        if(node != null) {
            var id, val;
            for(var i in node.children) {
                id = node.children[i].attributes['Id'];
                val = node.children[i].attributes['MEDAL_THRESHOLD'];
                
                if(id != null && val != null) {
                    if(val > 1000) {
                        val /= 1000;
                    }
                    
                    ret[id] = val;
                }
                else {
                    console.log('ERROR: Missing or corrupted medal data');
                }
            }
        }
        else {
            console.log('ERROR: No medal data found for stage');
        }
        
        return ret;
    },
    
    // Parse the audio information
    parseAudio: function (xml) {
        var node = XML.getDeepChildByName(xml, 'AudioSettings');
        if(node) {
            RC.crossFadeSpeed = node['crossFadeSpeed'] == null ? RC.crossFadeSpeed : node['crossFadeSpeed'];
        }
    },
    
    // Parse the penalty settings
    parsePenalty: function (xml) {
        var node = XML.getDeepChildByName(xml, 'PenaltySettings');
        if(node != null) {
            if(node.attributes['TimeLost'] != null) {
                RC.penaltyTime = node.attributes['TimeLost'];
            }
            if(node.attributes['SpeedLost'] != null) {
                RC.penaltySpeed = node.attributes['SpeedLost'] * -1;
            }
        }
    },
    
    // Parse and set player speed values
    parseSpeed: function (xml) {
        var node = XML.getDeepChildByName(xml, 'SpeedSettings');
        
        var max = node.attributes['Max'];
        var min = node.attributes['Min'];
        var speed = node.attributes['Default'];
        var accel = node.attributes['Acceleration'];
        var decel = node.attributes['Deceleration'];
        var turbo = node.attributes['Turbo'];
      
        // Heper function for setting values without overwritting defaults
        var helper = function(obj, key, val){
            if(val != null) {
                obj.set(key, val);
            }
        }
        
        // Set the values on the player
        var p = this.get('player')
        helper(p, 'maxSpeed', max);
        helper(p, 'minSpeed', min);
        helper(p, 'zVelocity', speed==null ? min : speed);
        helper(p, 'acceleration', accel);
        helper(p, 'deceleration', decel);
        helper(p, 'turboSpeed', turbo==null ? max : turbo);
    },
    
    // Parses the PROBLEM_SET
    parseProblemSet: function (xml) {
        var problemRoot = XML.getDeepChildByName(xml, 'PROBLEM_SET');
        var subsets = problemRoot.children;
        var z = 0;
        var once = true;
        
        for(var i in subsets) {
            z = this.parseProblemSubset(subsets[i], z, once);
            once = false;
        }
        
        return z;
    },
    
    // Parses a subset within the PROBLEM_SET
    parseProblemSubset: function (subset, z, once) {
        
        var interContent = Content.buildFrom(subset.children[0]);
        
        // Not the first subset
        if(!once) {
            z += RC.intermissionSpacing;
            // Gets the intermission value
            
            var inter = Intermission.create(interContent, z);
            events.addListener(inter, 'changeSelector', this.get('player').startIntermission.bind(this.get('player')));
            events.addListener(inter, 'changeSelector', this.pause.bind(this));
            inter.idle();
			
            // Append the intermission to the list of intermissions
			var temp = this.get('inters');
			temp.push(z);
			this.set('inters', temp);
			
			// Add checkpoint marker to the race track
			var opts = {
				maxScale    : 1.00,
				alignH      : 0.5,
				alignV      : 0,
				visibility  : 1,
				xCoordinate : 0,
				zCoordinate : z,
				dropoffDist : -10,
			}
			opts['content'] = cocos.nodes.Sprite.create({file: '/resources/checkpoint_p.png',});
			
			var fl = PNode.create(opts);
			events.addListener(fl, 'addMe', this.addMeHandler);
			fl.idle();
			fl.set('zOrder', -5);
        }
        else {
            this.set('startSelector', interContent);
        }
        
        // Interate over questions in subset
        var list = this.get('questionList');
        for(var i=1; i<subset.children.length; i+=1) {
            z += RC.questionSpacing;

            // Create a question
            list[list.length] = Question.create(subset.children[i], z);
            events.addListener(list[list.length - 1], 'questionTimeExpired', this.answerQuestion);
            events.addListener(list[list.length - 1], 'addMe', this.addMeHandler);
            list[list.length - 1].idle();
        }
        
        this.set('questionList', list);
        
        return z;
    },
    
    // The 'real init()' called after all the preloading/parsing is completed
    preprocessingComplete: function () {
        // Create key bindings
        this.setBinding('MOVE_LEFT',    [65, 37]);  // [A, ARROW_LEFT]
        this.setBinding('MOVE_RIGHT',   [68, 39]);  // [D, ARROW_RIGHT]
        this.setBinding('SPEED_UP',     [87, 38]);  // [W, ARROW_UP]
        this.setBinding('SPEED_DOWN',   [83, 40]);  // [S, ARROW_DOWN]
        this.setBinding('TURBO',        [32]);      // [SPACE]
        this.setBinding('ABORT',        [27]);      // [ESC]
        this.setBinding('SHOW_FPS',     [80]);      // [P]
        
        // Draw background
        var bg = Background.create();
        bg.set('zOrder', -10);
        this.set('background', bg);
        this.addChild({child: bg});
        
        var player = this.get('player');
        player.set('xCoordinate', this.lanePosX[RC.curNumLanes][1]);
        
        // Add the right hand side dash
        var dash = this.get('dash');
        dash.set('maxSpeed', player.get('maxSpeed'));
        this.addChild({child: dash});
        dash.set('zOrder', -1);
		dash.set('checkpoints', this.get('inters'));
        
        events.addListener(player, 'IntermissionComplete', this.unpause.bind(this));
        
        // Add player
        this.addChild({child: player});
        
        // Create finish line
        var opts = {
            maxScale    : 1.00,
            alignH      : 0.5,
            alignV      : 0,
            visibility  : 1,
            xCoordinate : 0,
            zCoordinate : RC.finishLine,
            dropoffDist : -10,
        }
        opts['content'] = cocos.nodes.Sprite.create({file: '/resources/finishline.png',});
        opts['content'].set('scaleX', 2);
        opts['content'].set('scaleY', 0.5);
        
        var fl = PNode.create(opts);
        events.addListener(fl, 'addMe', this.addMeHandler);
        fl.idle();
        fl.set('zOrder', -5);
        
        // Add version number
        var vtag = cocos.nodes.Label.create({string: this.get('version')})
        vtag.set('anchor-point', new geo.Point(0.5, 0.5));
        vtag.set('position', new geo.Point(850, 590));
        this.addChild({child: vtag});
        
        // Create FPS meter
        var fps = cocos.nodes.Label.create({string: '0 FPS'})
        fps.set('position', new geo.Point(20, 20));
        this.fps = fps;
        this.fpsTracker = [30, 30, 30, 30, 30];
        this.fpsToggle = false;
        
        // Calculate new min safe time
        var m = Math.min(RC.questionSpacing, RC.intermissionSpacing);
        m = Math.min(m, RC.finishSpacing);
        
        RC.maxTimeWindow = m / player.get('maxSpeed') * 0.9;
        
        // Generate things to the side of the road
        var sprite = cocos.nodes.Sprite.create({file: '/resources/tree_1.png',});
        
        for(var t=10; t<RC.finishLine + 100; t += Math.ceil(Math.random()*6+4)) {
            if(Math.random() < 0.25) {
                var p = PNode.create({xCoordinate: 4 * Math.random() + 5.5, zCoordinate: t, content: sprite, alignH: 0.5, alignV: 0.5})
                p.set('zOrder', -4);
                events.addListener(p, 'addMe', this.addMeHandler);
                p.idle();
            }
            if(Math.random() < 0.25) {
                var p = PNode.create({xCoordinate: -4 * Math.random() - 5.5, zCoordinate: t, content: sprite, alignH: 0.5, alignV: 0.5})
                p.set('zOrder', -4);
                events.addListener(p, 'addMe', this.addMeHandler);
                p.idle();
            }
        }
    },
    
    // Three second countdown before the game begins (after pressing the start button on the menu layer)
    // TODO: Make countdown more noticible
    countdown: function () {
        var medalCars = []
        
        var opts = {
            maxScale    : 1.00,
            alignH      : 0.5,
            alignV      : 0,
            visibility  : 1,
            xCoordinate : 4.5,
            zCoordinate : 0,
            dropoffDist : -10,
            delOnDrop   : false,
        }
        
        // Ghost cars representing medal cutoffs
        // TODO: Make seperate class, support lines in addition to cars
        for(var i=0; i<3; i+= 1) {
            var car = cocos.nodes.Sprite.create({file: '/resources/car'+i+'.png'});
            car.set('opacity', 192);
        
            opts['content'] = car
            medalCars[i] = PNode.create(opts)
            medalCars[i].zVelocity = RC.finishLine / RC.times[i+1];
            
            events.addListener(medalCars[i], 'addMe', this.addMeHandler);
            events.addListener(medalCars[i], 'removeMe', this.removeMeHandler);
            medalCars[i].delOnDrop = false;
        }
        
        this.set('medalCars', medalCars);
        
        // Set audio levels
        this.musicMixer.setMasterVolume(0.35);

        var s = this.audioMixer.getSound('accel')
        if(s) {
            s.setVolume(0.8);
        }
        
        s = this.audioMixer.getSound('screech')
        if(s) {
            s.setVolume(0.5);
        }
        
        this.audioMixer.playSound('countdown');
    
        this.get('dash').bindTo('speed', this.get('player'), 'zVelocity');
        this.get('dash').bindTo('playerZ', this.get('player'), 'zCoordinate');
        this.get('dash').bindTo('goldZ', this.medalCars[0], 'zCoordinate');
        this.get('dash').bindTo('silverZ', this.medalCars[1], 'zCoordinate');
        this.get('dash').bindTo('bronzeZ', this.medalCars[2], 'zCoordinate');
        setTimeout(this.startGame.bind(this), RC.initialCountdown);
        this.get('audioMixer').playSound('bg');
        
        var cd = cocos.nodes.Label.create({string: '3', textColor: '#000000'});
        cd.set('scaleX', 10);
        cd.set('scaleY', 10);
        cd.set('position', new geo.Point(400, 300));
        
        this.set('cdt', cd);
        this.addChild({child: cd});
        
        // Set the starting value on the player's car
        this.get('player').changeSelectorByForce(this.get('startSelector'));
        
        var that = this;
        setTimeout(function () { that.get('cdt').set('string', '2'); }, 750)
        setTimeout(function () { that.get('cdt').set('string', '1'); }, 1500)
        setTimeout(function () { that.get('cdt').set('string', 'GO!'); that.get('cdt').set('position', new geo.Point(300, 300)); }, 2250)
        setTimeout(function () { that.removeChild(that.get('cdt')); }, 2750)
        
        this.audioMixer.playSound('start');
        this.audioMixer.loopSound('hum');
        
        // Catch window unloads at this point as aborts
        $(window).unload(this.endOfGame.bind(this, null));
    },
    
    // Starts the game
    startGame: function () {
        this.scheduleUpdate();          // Start keyboard input and fps tracking
        var p = this.get('player');
        p.scheduleUpdate();             // Start the player
        this.get('dash').start();       // Start timer and dash updates
        
        // Accelerate the player to their default speed after starting
        var ds = p.get('zVelocity');
        p.set('zVelocity', 0);
        MOT.create(0, ds, 0.2).bind(p, 'zVelocity');
        
        this.medalCars[0].scheduleUpdate();
        this.addChild({child: this.medalCars[0]});
        this.medalCars[1].scheduleUpdate();
        this.addChild({child: this.medalCars[1]});
        this.medalCars[2].scheduleUpdate();
        this.addChild({child: this.medalCars[2]});
        
        // Start background music
        this.musicMixer.loopSound('bg_slow');
        this.musicMixer.playSound('bg_open');
        var s = this.musicMixer.getSound('bg_fast')
        if(s) {
            s.setVolume(0);
        }
        this.musicMixer.loopSound('bg_fast');
    },
    
	// Pauses the dashboard and medal cars
    pause: function () {
        this.get('dash').pauseTimer();
        
        this.audioMixer.playSound('intermission');
        
        var mc = this.get('medalCars');
        
        for(var i=0; i<3; i+=1) {
            mc[i].prepause = mc[i].zVelocity;
            mc[i].zVelocity = 0;
        }
        
        this.set('medalCars', mc);
    },
    
	// Unpauses the dashboard and medal cars
    unpause: function () {
        this.get('dash').unpauseTimer();
        
        var mc = this.get('medalCars');
        
        for(var i=0; i<3; i+=1) {
            mc[i].zVelocity = mc[i].prepause;
            mc[i].prepause = 0;
        }
        
        this.set('medalCars', mc);
    },
    
    // Handles add requests from PerspectiveNodes
    // TODO: Make a PerspectiveView class to handle these functions?
    // STATIC BIND
    addMeHandler: function (toAdd) {
        this.addChild({child: toAdd});
        events.addListener(toAdd, 'removeMe', this.removeMeHandler);
    },
    
    // Handles removal requests from PerspectiveNodes
    // STATIC BIND
    removeMeHandler: function (toRemove) {
        this.removeChild(toRemove);
    },
    
    onCrossFadeComplete: function () {
        this.bgFade = false;
    },
    
    // Called when game ends, should collect results, display them to the screen and output the result XML
    // finished = null on window.unload, false on abort, true on completion
    endOfGame: function(finished) {
        if(finished != null) {
            $(window).unbind('unload')
            $(window).unload(this.cleanup.bind(this, null));
        }
        else {
            this.cleanup();
        }
        
        // Fade out background music tracks at the end of the game
        var s;
        
        s = this.musicMixer.getSound('bg_fast');
        if(s) {
            MOT.create(s.volume, -1, 2).bindFunc(s, s.setVolume);
        }
        
        s = this.musicMixer.getSound('bg_slow');
        if(s) {
            MOT.create(s.volume, -1, 2).bindFunc(s, s.setVolume);
        }
        
        this.audioMixer.stopSound('hum');
        this.audioMixer.playSound('finish');
    
        // Stop the player from moving further and the dash from increasing the elapsed time
        cocos.Scheduler.get('sharedScheduler').unscheduleUpdateForTarget(this.get('player'));
        
        this.dash.pauseTimer();
        
        // Stops the medal pace cars
        var mc = this.get('medalCars');
        mc[0].set('zVelocity', 0);
        mc[1].set('zVelocity', 0);
        mc[2].set('zVelocity', 0);
    
        var ql = this.get('questionList')
        var i = 0, correct = 0, incorrect = 0, unanswered = 0;
        
        // Tally question results
        while(i < ql.length) {
            if(ql[i].get('answeredCorrectly')) {
                correct += 1;
            }
            else if(ql[i].get('answeredCorrectly') == false) {
                incorrect += 1;
            }
            else {
                unanswered += 1;
            }
            
            i += 1;
        }
        
        var tt = this.get('dash').getTotalTime()
        var m = 1;
        
        if(finished) {
            while(m < 4 && RC.times[m] < tt) {
                m += 1;
            }
        }
        else {
            m = 4;
        }
        
        // Checks to see if abort was related to window.unload
        if(finished != null) {
            //alert("Correct: " + correct + '\nTotal Time: ' + tt + '\nMedal Earned: ' + RC.medalNames[m] );
            var e = EOGD.create(this.get('dash').get('elapsedTime'), incorrect + unanswered, !finished);
            e.set('position', new geo.Point(200, 50));
            this.addChild({child: e});
            var that = this;
            events.addListener(e, 'almostComplete', function () {that.get('menuLayer').addRetryButton();});
            events.addListener(e, 'complete', this.cleanup.bind(this));
            this.eogd = e;
            e.start();
        }
    
        // If the 'command line' specified a call back, feed the callback the xml
        if(this.get('endOfGameCallback')) {
            if(finished) {
                window[this.get('endOfGameCallback')](this.writeXML(correct, 'FINISH'));
            }
            else {
                window[this.get('endOfGameCallback')](this.writeXML(correct, 'ABORT'));
            }
        }
    },

    // Writes the output xml file as a string and returns it
    // TODO: Decide on a new format if needed and update
    writeXML: function(correct, state) {
        // Get needed values
        var ref = this.get('gameID');
        var d = this.get('dash');
        var e = d.get('elapsedTime');
        var p = d.get('pTime');
        var m = ' - ';
        
        // Determine medal string
        if(state == 'FINISH') {
            if(e + p < RC.times[1])
                m = "Gold";
            else if(e + p < RC.times[2])
                m = "Silver";
            else if(e + p < RC.times[3])
                m = "Bronze";
        }
        
        // Convert times to milliseconds for reporting
        e = Math.round(e * 1000)
        p = Math.round(p * 1000)
        
        // Build the XML string
        var x =
        '<OUTPUT>\n' + 
        '    <GAME_REFERENCE_NUMBER ID="' + ref + '"/>\n' + 
        '    <SCORE_SUMMARY>\n' + 
        '        <Score CorrectAnswers="' + correct +'" ElapsedTime="' + e + '" PenaltyTime="' + p + '" TotalScore="' + (e + p) +'" Medal="' + m + '"/>\n' + 
        '    </SCORE_SUMMARY>\n' +
        '    <SCORE_DETAILS>\n';
                var i = 0;
                var ql = this.get('questionList');
                while(i < ql.length) {
                x += '        <SCORE QuestionIndex="' + (i+1) +'" AnswerValue="' +  ql[i].get('correctAnswer') + '" TimeTaken="' + Math.round(ql[i].get('timeElapsed') * 1000) + '" LaneChosen="' + ql[i].get('answer') + '"/>\n';
                i += 1;
                }
            x += '    </SCORE_DETAILS>\n' + 
        '    <END_STATE STATE="' + state + '"/>\n' +
        '</OUTPUT>';
        
        return x;
    },
    
    // Code to be run when the game is finished
    cleanup: function() {
        // Clear the bind
        $(window).unbind('unload');
        
        cocos.Scheduler.get('sharedScheduler').unscheduleUpdateForTarget(this);
        
        var d = cocos.Director.get('sharedDirector');
        
        // Stop the main loop and clear the scenes
        d.stopAnimation();
        delete d.sceneStack.pop();
        delete d.sceneStack.pop();
        
        // Clear the setup functions
        d.attachInView = null;
        d.runWithScene = null;
        
        // Clear the animating functions
        d.startAnimation = null;
        d.animate = null;
        d.drawScene = null;
        
        // Clear the instance
        d._instance = null;
    },
    
    // Handles answering the current question when time expires
    // STATIC BIND
    answerQuestion: function(question) {
        var result = question.answerQuestion(this.lane);

        var player = this.get('player');
        
        // Handle correct / incorrect feedback
        if(result) {
            this.audioMixer.playSound('correct', true);
        }
        else {
            var dash = this.get('dash');
            var t = dash.elapsedTime + dash.pTime + parseFloat(RC.penaltyTime);
        
            player.wipeout(1);
            dash.modifyPenaltyTime(RC.penaltyTime);
            
            this.audioMixer.playSound('wrong', true);
            
            // Update medal car velocities to account for penalty time
            var c = this.get('medalCars')
            for(var i=0; i<3; i+=1) {
                var rd = RC.finishLine - c[i].get('zCoordinate');
                var rt = RC.times[i+1] - t;
                
                if(rt > 0.1 && rd > 0) {
                    c[i].set('zVelocity', rd / rt);
                }
                else if (rd > 0) {
                    c[i].set('zVelocity', rd / 0.1);
                }
            }
            
            this.set('medalCars', c);
        }
        
        player.endTurboBoost();
    },
    
    // Toggles the AudioMixer's mute
    muteHandler: function() {
        var AM = this.get('audioMixer');
        AM.setMute(!AM.get('muted'));
    },
    
    muteMusicHandler: function() {
        var AM = this.get('musicMixer');
        AM.setMute(!AM.get('muted'));
    },
    
    // Called every frame, manages keyboard input
    update: function(dt) {
        var player = this.get('player');
        var playerX = player.get('xCoordinate');
        
        if(player.get('zCoordinate') > RC.finishLine && this.eogd == null) {
            this.endOfGame(true);
        }
        
        if(this.checkAnyKey() && this.eogd != null) {
            this.eogd.skipAnimation();
        }
        
    // Move the player according to keyboard
        // 'A' / 'LEFT' Move left, discreet
        if(this.checkBinding('MOVE_LEFT') == KeyboardLayer.PRESS) {
            if(this.lane > 0) {
                this.lane -= 1;
                player.set('xCoordinate', this.lanePosX[RC.curNumLanes][this.lane]);
                this.audioMixer.playSound('screech', true);
            }
        }
        // 'D' / 'RIGHT' Move right, discreet
        else if(this.checkBinding('MOVE_RIGHT') == KeyboardLayer.PRESS) {
            if(this.lane < RC.curNumLanes-1) {
                this.lane += 1;
                player.set('xCoordinate', this.lanePosX[RC.curNumLanes][this.lane]);
                this.audioMixer.playSound('screech', true);
            }
        }
        
        var decel_lock = false;
        
        // 'S' / 'DOWN' Slow down, press
        if(this.checkBinding('SPEED_DOWN') > KeyboardLayer.UP) {
            player.decelerate(dt);
            this.audioMixer.loopSound('decel')
        
            // Cross fade tracks if needed and able
            if(this.bgFast && !this.bgFade && player.zVelocity < RC.crossFadeSpeed) {
                this.musicMixer.crossFade('bg_fast', 'bg_slow', 2);
                this.bgFast = false;
                this.bgFade = true;
            }
            
            // Prevents triggering both acceleration and deceleration
            decel_lock = true;
        }
        // 'W' / 'UP' Speed up, press
        else
            this.audioMixer.stopSound('decel');
            
        if(!decel_lock && this.checkBinding('SPEED_UP') > KeyboardLayer.UP) {
            player.accelerate(dt);
            this.audioMixer.loopSound('accel')
            
            // Cross fade tracks if needed and able
            if(!this.bgFast && !this.bgFade && player.zVelocity > RC.crossFadeSpeed) {
                this.musicMixer.crossFade('bg_slow', 'bg_fast', 2);
                this.bgFast = true;
                this.bgFade = true;
            }
        }
        else
            this.audioMixer.stopSound('accel');
        
        // 'SPACE' turbo boost, discreet
        if(this.checkBinding('TURBO') == KeyboardLayer.PRESS) {
            if(player.startTurboBoost())
                this.audioMixer.playSound('turbo', true);
        }
        
        // 'ESC' Abort game, discreet
        if(this.checkBinding('ABORT') == KeyboardLayer.PRESS) {
            this.endOfGame(false);
        }
        
        var sub = parseFloat(0);    // Zero the subtotal
        var cur = 1 / dt;           // Store the current frame's fps
        
        this.fpsTracker.shift();    // Get rid of oldest frame
        this.fpsTracker.push(cur);  // Add this frame
        
        // Log spikes to console if FPS tracker is enabled
        if(this.fpsToggle) {
            if(1 / dt < 20) {
                console.log('FPS Spike down frame ( ' + cur.toFixed(1) + ' FPS / ' + (dt*1000).toFixed(0) + ' ms dt )');
            }
        }
        
        // Smooth over multiple frames
        this.fps.set('fontColor', '#FFFFFF');
        for(t in this.fpsTracker){
            sub += this.fpsTracker[t];
            
            // Flash red on low framerate spikes
            if(this.fpsTracker[t] < 20) {
                this.fps.set('fontColor', '#DD2222');
            }
        }
        
        // Update the FPS tracker label
        this.fps.set('string', (sub / this.fpsTracker.length).toFixed(1) + ' FPS');
        
        // 'P' Toggle showing FPS tracker, discreet
        if(this.checkBinding('SHOW_FPS') == KeyboardLayer.PRESS) {
            if(!this.get('fpsToggle')) {
                this.addChild({child: this.fps});
                this.fpsToggle = true;
            }
            else {
                this.removeChild({child: this.fps});
                this.fpsToggle = false;
            }
        }
    },
});

// For button-like interactions (e.g. starting the game)
// TODO: Extend Menu with functions making it easier to tie the Menu into an app
var MenuLayer = cocos.nodes.Menu.extend({
    startButton : null,     // Holds the button to start the game
    startGame   : null,     // Holds the function in the app that starts the game
    muted       : false,    // State of the volume mute button
    mutedMusic  : false,    // State of the volume mute button
    init: function() {
        MenuLayer.superclass.init.call(this, {});
    },
    
    createMenu: function() {
        // Create the button
        var opts = Object();
        opts['normalImage'] = '/resources/start-button.png';
        opts['selectedImage'] = '/resources/start-button.png';
        opts['disabledImage'] = '/resources/start-button.png';
        // We use this callback so we can do cleanup before handing everything over to the main game
        opts['callback'] = this.startButtonCallback.bind(this);
        
        var sb = cocos.nodes.MenuItemImage.create(opts);
        sb.set('position', new geo.Point(0, 0));
        sb.set('scaleX', 0.5);
        sb.set('scaleY', 0.5);
        this.set('startButton', sb);
        this.addChild({child: sb});
        
        // Create the volume control
        // TODO: Make a better basic (toggle)button (extend MenuItemImage?)
        opts['normalImage'] = '/resources/volume-control.png';
        opts['selectedImage'] = '/resources/volume-control.png';
        opts['disabledImage'] = '/resources/volume-control.png';
        opts['callback'] = this.volumeCallback.bind(this);
        
        var vc = cocos.nodes.MenuItemImage.create(opts);
        vc.set('position', new geo.Point(425, 250));
        this.set('volumeButtonOn', vc);
        this.addChild({child: vc});
        
        opts['callback'] = this.musicCallback.bind(this);
        vc = cocos.nodes.MenuItemImage.create(opts);
        vc.set('position', new geo.Point(375, 250));
        this.set('musicButtonOn', vc);
        this.addChild({child: vc});
        
        opts['normalImage'] = '/resources/volume-control-off.png';
        opts['selectedImage'] = '/resources/volume-control-off.png';
        opts['disabledImage'] = '/resources/volume-control-off.png';
        opts['callback'] = this.volumeCallback.bind(this);
        
        vc = cocos.nodes.MenuItemImage.create(opts);
        vc.set('position', new geo.Point(425, 250));
        this.set('volumeButtonOff', vc);
        
        opts['callback'] = this.musicCallback.bind(this);
        vc = cocos.nodes.MenuItemImage.create(opts);
        vc.set('position', new geo.Point(375, 250));
        this.set('musicButtonOff', vc);
    },
    
    // Called when the button is pressed, clears the button, then hands control over to the main game
    startButtonCallback: function() {
        this.removeChild(this.get('startButton'));
        events.trigger(this, "startGameEvent");
    },
    
    // Called when the volume button is pressed
    // TODO: Seperate this into two functions (mute/unmute)?
    // TODO: Implement a slider/levels to set master volume
    volumeCallback: function() {
        events.trigger(this, "muteEvent");
        
        var m = this.get('muted')
        if(!m) {
            this.removeChild(this.get('volumeButtonOn'));
            this.addChild({child: this.get('volumeButtonOff')});
        }
        else {
            this.removeChild(this.get('volumeButtonOff'));
            this.addChild({child: this.get('volumeButtonOn')});
        }
        this.set('muted', !m);
    },
    
    musicCallback: function() {
        events.trigger(this, "muteMusicEvent");
        
        var m = this.get('mutedMusic')
        if(!m) {
            this.removeChild(this.get('musicButtonOn'));
            this.addChild({child: this.get('musicButtonOff')});
        }
        else {
            this.removeChild(this.get('musicButtonOff'));
            this.addChild({child: this.get('musicButtonOn')});
        }
        this.set('mutedMusic', !m);
    },
    
    // Adds the retry button to the MenuLayer
    addRetryButton: function() {
        var opts = Object();
        opts['normalImage'] = '/resources/Retry_Up.png';
        opts['selectedImage'] = '/resources/Retry_Down.png';
        opts['disabledImage'] = '/resources/Retry_Up.png';
        opts['callback'] = this.retryButtonCallback.bind(this);
        
        var b = cocos.nodes.MenuItemImage.create(opts);
        b.set('position', new geo.Point(10-450+300, 230-300+125));
        b.set('scaleX', 0.8);
        b.set('scaleY', 0.8);
        this.addChild({child: b});
    },
    
    retryButtonCallback: function() {
        window.runStage(window.currentSequence, window.currentStage);
    }
});

// Initialise application
exports.main = function() {
    // From: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind
    // This defines function.bind for web browsers that have not implemented it:
    // Firefox < 4 ; Chrome < 7 ; IE < 9 ; Safari (all) ; Opera (all)
    if (!Function.prototype.bind) {  
        Function.prototype.bind = function (oThis) {  
        
            if (typeof this !== "function") { // closest thing possible to the ECMAScript 5 internal IsCallable function  
                throw new TypeError("Function.prototype.bind - what is trying to be fBound is not callable");  
            }

            var aArgs = Array.prototype.slice.call(arguments, 1),
                fToBind = this,
                fNOP = function () {},
                fBound = function () {
                    return fToBind.apply(this instanceof fNOP ? this : oThis || window, aArgs.concat(Array.prototype.slice.call(arguments)));
                };  

            fNOP.prototype = this.prototype;
            fBound.prototype = new fNOP();

            return fBound;
        };
    }
    
    // Setup the director
    var director = cocos.Director.get('sharedDirector');
    director.attachInView(document.getElementById('cocos_test_app'));
    
    var scene = cocos.nodes.Scene.create();     // Create a scene
    var app = FluencyApp.create();              // Create the layers
    var menu = MenuLayer.create();
    
    // Set up inter-layer events
    events.addListener(app, 'loaded', menu.createMenu.bind(menu));
    
    events.addListener(menu, 'startGameEvent', app.countdown.bind(app));
    events.addListener(menu, 'muteEvent', app.muteHandler.bind(app));
    events.addListener(menu, 'muteMusicEvent', app.muteMusicHandler.bind(app));
    
    // Add our layers to the scene
    scene.addChild({child: app});
    scene.addChild({child: menu});
    
    // Allow the App layer to directly access the UI layer
    app.set('menuLayer', menu);
    
    // Run the scene
    director.runWithScene(scene);
};
}};
__resources__["/ModifyOverTime.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
Copyright 2011, Carnegie Learning

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

var cocos = require('cocos2d');
var events = require('events');

// Automatically handles changing a value over time (just bindTo "value" to the value you want to change)
var ModifyOverTime = BObject.extend({
    duration: 0,    // Remaining duration of the change
    rate    : 0,    // Rate at which the value changes per second
    value   : null, // The value that is being changed
    
    init: function (x, amount, time) {
        ModifyOverTime.superclass.init.call();
        
        // Initialize
        this.set('value', x);
        this.set('rate', amount / time);
        this.set('duration', time);
        
        // Force calling updates since this will not be added to the scene
        cocos.Scheduler.get('sharedScheduler').scheduleUpdate({target: this, priority: 0, paused: false});
        
        // Keep track of this instance so we can remove it automatically later
        ModifyOverTime.list.push(this);
    },
    
    // Shortcut for bindTo
    bind: function (obj, str) {
        this.bindTo('value', obj, str);
    },
    
    bindFunc: function (obj, func) {
        this.obj = obj;
        this.func = func;
    },

    // Changes value over time
    update: function (dt) {
        var dur = this.get('duration');
        
        // Keep changing as long as there is duration remaining
        if(dur > 0) {
            // Check the case that the tick is longer than our remaining time
            var edt = Math.min(dt, dur);
            this.set('duration', dur - edt);
            
            var rate = this.get('rate');
            this.set('value', this.get('value') + rate * edt);
            
            if(this.func) {
                this.func.apply(this.obj, [this.get('value') + rate * edt]);
            }
        }
        
        // Otherwise change is complete
        else {
            // Let anyone who wants to know that this change has finished
            events.trigger(this, 'Completed', this);
            
            // Then kill it
            this.kill();
        }
    },
    
    // Calling this directly will stop the MOT from modifying and remove it just like if its duration expired, but will not notify anything that it has ended
    kill: function () {
        // Clean up
        cocos.Scheduler.get('sharedScheduler').unscheduleUpdateForTarget(this);
        events.clearInstanceListeners(this);
        this.unbind(this.get('value'));
        
        // and remove
        var index = ModifyOverTime.list.indexOf(this);
        ModifyOverTime.list.splice(index, 1);
    },
    
    pause: function () {
        cocos.Scheduler.get('sharedScheduler').pauseTarget(this);
    },
    
    resume: function () {
        cocos.Scheduler.get('sharedScheduler').resumeTarget(this);
    },
});

// Static variables
ModifyOverTime.list = [];

exports.ModifyOverTime = ModifyOverTime;
}};
__resources__["/PerspectiveNode.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
Copyright 2011, Carnegie Learning

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

var cocos = require('cocos2d');
var geom = require('geometry');
var events = require('events');
var util = require('util');

var RC = require('RaceControl').RaceControl;

// Base class for rending objects in perspective view
var PerspectiveNode = cocos.nodes.Node.extend({
    visibility  : 1,        // Content scale multiplier, used BEFORE clamping
    minScale    : null,     // Minimum scale for this node due to perspective distance (null disables minimum)
    maxScale    : null,     // Maximum scale for this node due to perspective distance (null disables maximum)
    xCoordinate : 0,        // The node's X position in the world
    zCoordinate : 0,        // The node's Z position in the world
    silent      : false,    // If set to true, will not fire events
    added       : false,    // True once added to the scene
    lockX       : false,    // Set to true to lock X value
    lockY       : false,    // Set to true to lock Y value
    alignV      : 0,        // Vertical alignment of the node (0 top - 0.5 center - 1 bottom)
    alignH      : 0,        // Horizontal alignment of the node (0 right - 0.5 center - 1 left)
    dropoffDist : -10,      // Distance behind the camera that node requests removal from scene
    zVelocity   : 0,        // Meters per second speed along the Z axis
    xVelocity   : 0,        // Meters per second speed along the X axis
    content     : null,     // Content to be displayed in the node
    delOnDrop   : true,     // If true, runs cleanup when the node is removed from the scene
    init: function(opts) {
        PerspectiveNode.superclass.init.call(this, opts);
        
        this.set('position', new geom.Point(0, 0));
        this.set('anchorPoint', new geom.Point(0, 0));
        
        //Set properties from the option object
        util.each('visibility minScale maxScale xCoordinate zCoordinate silent lockX lockY alignV alignH dropoffDist zVelocity xVelocity content delOnDrop'.w(), util.callback(this, function (name) {
            if (opts[name]) {
                this.set(name, opts[name]);
            }
        }));
        
        if(this.get('content') != null) {
            this.get('content').set('anchorPoint', new geom.Point(0, 0));
            this.addChild({child: this.get('content')});
            this.set('contentSize', this.get('content').get('contentSize'));
        }
        
        this.idle = this.idle.bind(this);
    },
    
    // Explicitly unschedules and unsubscribes this node
    cleanup: function () {
        cocos.Scheduler.get('sharedScheduler').unscheduleUpdateForTarget(this);
        events.clearInstanceListeners(this);
    },
    
    // Callen when place into the scene
    onEnter: function() {
        this.set('added', true);
        PerspectiveNode.superclass.onEnter.call(this);
    },
    
    // Called when removed from the scene, if delOnDrop, runs cleanup, otherwise explictly reschedules the node
    onExit: function () {
        this.set('added', false);
        PerspectiveNode.superclass.onExit.call(this);
        
        if(this.get('delOnDrop')) {
            this.cleanup();
        }
        else {
            cocos.Scheduler.get('sharedScheduler').scheduleUpdate({target: this, priority: 0, paused: false});
        }
    },
    
    // Applies visibility modifier and clamps to scale, then returns the augmented value
    scale: function (s) {
        s *= this.visibility;
    
        // Apply clamps to scale as needed
        if(this.minScale != null) {
            s = Math.max(this.minScale, s);
        }
        if(this.maxScale != null) {
            s = Math.min(this.maxScale, s);
        }
        
        // Set scale
        this.scaleX = s;
        this.scaleY = s;
        
        return s;
    },
    
    // Helper function for determining node width
    getContentWidth: function() {
        if(this.content) {
            return this.contentSize.width * this.content.scaleX;
        }
        return this.contentSize.width;
    },
    
    // Helper function for determining node height
    getContentHeight: function() {
        if(this.content) {
            return this.contentSize.height * this.content.scaleY;
        }
        return this.contentSize.height;
    },
    
    // Called once per second until node is 'just over the horizon' at which point, it starts running update() every frame instead
    // NOTE: This only works with stationary nodes
    idle: function () {
        var distance = this.zCoordinate - PerspectiveNode.cameraZ;
        
        if(distance <= PerspectiveNode.horizonDistance + RC.maxDistWindow) {
            cocos.Scheduler.get('sharedScheduler').scheduleUpdate({target: this, priority: 0, paused: false});
        }
        else {
            setTimeout(this.idle, 1000);
        }
    },
    
    // Called every frame for distance checking and rendering
    update: function (dt) {
        // Update current position based on velocity
        this.zCoordinate = this.zCoordinate + this.zVelocity * dt;
        this.xCoordinate = this.xCoordinate + this.xVelocity * dt;
        
        var distance = this.zCoordinate - PerspectiveNode.cameraZ;
    
        // Only worry about drawing once node is on our side of the horizon
        if(distance > PerspectiveNode.horizonDistance) {
            if(this.added && !this.silent) {
                events.trigger(this, 'removeMe', this);
            }
        }
        else if(distance <= PerspectiveNode.horizonDistance && distance > this.dropoffDist) {
            // Make sure that the node gets added to the scene graph once it should be visible
            if(!this.added && !this.silent) {
                events.trigger(this, 'addMe', this);
            }
        
            // Perspective transform
            var scale = PerspectiveNode.horizonDistance * PerspectiveNode.horizonScale / distance;
            var screenX, screenY;
            
            // Apply scaling
            var displayScale = this.scale(scale);
            
            // Check to see if X axis is locked
            if(!this.lockX) {
                screenX = PerspectiveNode.roadOffset + PerspectiveNode.roadWidthPix / 2 * (1 + scale * 2.0 * (this.xCoordinate / PerspectiveNode.roadWidth));
                screenX -= this.alignH * this.getContentWidth() * displayScale;
            }
            else {
                screenX = this.alignH * this.getContentWidth() * displayScale;
            }
            
            // Check to see if Y axis is locked
            if(!this.lockY) {
                var yScale = (1.0 / (1.0 - PerspectiveNode.horizonScale)) * (scale - PerspectiveNode.horizonScale);
                screenY = PerspectiveNode.horizonStart + PerspectiveNode.horizonHeight * (yScale);
                screenY -= this.alignV * this.getContentHeight() * displayScale;
            }
            else {
                screenY = -1 * this.alignV * this.getContentHeight() * displayScale;
            }

            // Set position
            this.set('position', new geom.Point(screenX, screenY));
        }
        // Once the node drops too far back, notify for removal
        else if (!this.silent) {
            events.trigger(this, 'removeMe', this);
        }
    }
});

// Static constants
PerspectiveNode.horizonStart    = 150;      // From top of screen to start of horizon in pixels
PerspectiveNode.horizonHeight   = 450;      // From horizonStart to the bottom of the screen in pixels
PerspectiveNode.horizonDistance = 100;      // In meters from the camera
PerspectiveNode.horizonScale    = 0.05;     // Scale of objects on the horizon
PerspectiveNode.roadWidth       = 9.0;      // Width of road at bottom of the screen in meters
PerspectiveNode.roadWidthPix    = 800;      // Width of road at bottom of the screen in pixels
PerspectiveNode.roadOffset      = 000;      // Number of pixels from the left hand side that the road starts at

// Static variables
PerspectiveNode.cameraZ = 0;                // Current Z coordinate of the camera

exports.PerspectiveNode = PerspectiveNode
}};
__resources__["/PieChart.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
Copyright 2011, Carnegie Learning

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

var cocos = require('cocos2d');
var geom = require('geometry');
var util = require('util');

// Draws a pie chart
var PieChart = cocos.nodes.Node.extend({
    numSections :2,         // Total number of pie slices
    numFilled   :1,         // Number of filled pie slices
    bgColor     :'#FFFFFF', // Color of the background
    lineColor   :'#000000', // Color of the lines used to outlijne and mark each section
    fillColor   :'#00A0A0', // Color of the filled in sections
    radius      :10,        // Size of the chart
    init: function(opts) {
        PieChart.superclass.init.call(this);
        
        //Set properties from the option object
        util.each('numSections numFilled bgColor lineColor fillColor radius'.w(), util.callback(this, function (name) {
            if (opts[name]) {
                this.set(name, opts[name]);
            }
        }));
        
        // Explictly set contentSize so it plays nice with formating based on it
        this.set('contentSize', new geom.Size(this.get('radius') * 2.4, this.get('radius') * 2.4));
    },
    
    // Draws the PieChart to the canvas
    draw: function(context) {
        var r = this.get('radius');
        
        // Draw background
        context.fillStyle = this.get('bgColor');
        context.fillRect(r * -1.2, r * -1.2, r * 2.4, r * 2.4);
    
        var step = Math.PI*2 / this.get('numSections');
        var offset = Math.PI * 3 / 2    //This is so we draw with 'up' as our 0
    
        // Draw the filled portion
        context.fillStyle = this.get('fillColor');
        context.beginPath();
        context.arc(0, 0, r, offset, offset + step * this.get('numFilled'));
        context.lineTo(0, 0);
        context.lineTo(0, -1 * r);
        context.closePath();
        context.fill();
    
        // Draw the outline
        context.strokeStyle = this.get('lineColor');
        context.beginPath();
        context.arc(0, 0, r, 0, Math.PI*2);
        context.closePath();
        context.stroke();
        
        // Draw the individual dividers
        for(var i=0; i<this.get('numSections'); i+= 1) {
            context.beginPath();
            context.moveTo(0, 0);
            context.lineTo(Math.sin(i*step)*r, Math.cos(i*step)*r*-1)
            context.closePath();
            context.stroke();
        }
    },
});

// Static helper function to build the creation options object
PieChart.helper = function(Sections, Filled, BgColor, LineColor, FillColor, Radius) {
    return {
        numSections : Sections,
        numFilled   : Filled,
        bgColor     : BgColor,
        lineColor   : LineColor,
        fillColor   : FillColor,
        radius      : Radius
    };
}

exports.PieChart = PieChart
}};
__resources__["/Player.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
Copyright 2011, Carnegie Learning

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

// Cocos requirements
var cocos = require('cocos2d');
var geom = require('geometry');
var events = require('events');

// Project requirements
var LabelBG = require('LabelBG').LabelBG;
var PNode = require('PerspectiveNode').PerspectiveNode;

// Static requirements
var RC = require('RaceControl').RaceControl;
var MOT = require('ModifyOverTime').ModifyOverTime;

// Represents the player in the game
var Player = PNode.extend({
    selector        : null,     // Label that represents the value the player has control over
    
    wipeoutDuration : 0,        // Duration remaining on a wipeout
    wipeoutRotSpeed : 0,        // Rotational velocity in degrees per second for the current wipeout
    
    selectorX       : null,     // The X coordinate that the label should be at, ignoring rotational transforms
    selectorY       : null,     // The Y coordinate that the label should be at, ignoring rotational transforms
    
    chaseDist       : 6,        // The distance in meters the player is ahead of the camera by
    chaseMin        : 6,        // The closest the camera can get behind the car in meters
    chaseDelta      : 1,        // How many meters the player will pull away from the camera by moving at maximum speed
    
    minSpeed        : 0,        // Minimum player speed in m/s (Zero is okay, negatives are BAD)
    maxSpeed        : 200,      // Maximum player speed in m/s
    acceleration    : 13,       // Player acceleration in m/s^2
    deceleration    : 26,       // Player deceleration in m/s^2
    
    turbo           : false,    // True if turbo boost is currently active
    preTurbo        : 0,        // Holds what the zVelocity was before turbo boosting
    turboSpeed      : 200,      // Turbo boost speed in m/s
    turboMOT        : null,     // Hold the MOT currently affecting zVelocity

    init: function() {
        Player.superclass.init.call(this, {xCoordinate:0, zCoordinate: this.get('chaseDist')});
        
        // Static binds
        this.changeSelector = this.changeSelector.bind(this)
        this.turboCompleted = this.turboCompleted.bind(this)
        this.endIntermission = this.endIntermission.bind(this)
        this.startIntermission = this.startIntermission.bind(this)
        this.startAnimationCallback = this.startAnimationCallback.bind(this)
        
        // Load the car sprite for the player
        var sprite = cocos.nodes.Sprite.create({file: '/resources/car_white.png',});
        sprite.set('scaleX', 0.5);
        sprite.set('scaleY', 0.5);
        this.addChild({child: sprite});
    },
    
    // Changes the currently displayed selector on the car
    // STATIC BIND
    changeSelector: function(newVal, location) {
        // Remove previous selector if there was one
        var prev = this.get('selector');
        if(prev != null) {
            this.removeChild(prev);
        }

        newVal = this.get('newSelector');
    
        // Create the new selector if one is provided
        if(newVal != null) {
            var selector = newVal
            this.get('parent').removeChild(selector);
            this.changeSelectorByForce(selector);
        }
        else {
            this.set('selector', null);
        }
        
        setTimeout(this.endIntermission, 100);
    },
    
    // Used to set the selector at the start of the game
    changeSelectorByForce: function(selector) {
        selector.set('position', new geom.Point(selector.get('contentSize').width / 2 * selector.get('scaleX'), 80));
        this.set('selectorX', selector.get('contentSize').width / 2 * selector.get('scaleX'));
        this.set('selectorY', 80);
        this.addChild({child: selector});
        this.set('selector', selector);
    },
    
    // Starts an intermission
    // STATIC BIND
    startIntermission: function(newVal, location) {
        this.endTurboBoost();
        
        var tm = this.get('turboMOT');
        if(tm != null) {
            tm.pause();
            this.set('turboMOT', tm);
        }
        
        // Stop the player on the checkpoint
        if(this.get('zCoordinate') > location) {
            this.set('zCoordinate', location);
        }
        
        this.set('intermission', true);
        this.set('preInter', this.get('zVelocity'));
        this.set('zVelocity', 0);
        this.set('newSelector', newVal);
        newVal.set('anchorPoint', new geom.Point(0.5, 0.5));
        var s = newVal.get('scale') * 3;
        var cs = newVal.get('contentSize');
        newVal.set('scale', 0.1);
        newVal.set('position', new geom.Point(400 + cs.width * 1.5, 100 + cs.height * 1.5));
        this.get('parent').addChild({child: newVal});
        
        if(this.get('selector') != null) {
            MOT.create(255, -255, 1.0).bindTo('value', this.get('selector'), 'opacity');
        }
        
        var a1 = cocos.actions.ScaleTo.create({scale: s, duration: 0.25});
        a1.startWithTarget(newVal);
        newVal.runAction(a1);
        
        setTimeout(this.startAnimationCallback, 1000);
    },
    
    // Finishes an intermission
    // STATIC BIND
    endIntermission: function() {
        this.set('intermission', false);
        
        var tm = this.get('turboMOT');
        if(tm != null) {
            tm.resume();
            this.set('turboMOT', tm);
        }
        
        this.set('zVelocity', this.get('preInter'));
        events.trigger(this, 'IntermissionComplete');
    },
    
    
    // Shows the new selector, schedules to hide if blink count is not exhausted
    // STATIC BIND
    startAnimationCallback: function() {
        var nv = this.get('newSelector');
        var ns = nv.get('scale') / 3;
        
        var a1 = cocos.actions.ScaleTo.create({scale: ns, duration: 1.0});
        a1.startWithTarget(nv);
        nv.runAction(a1);
        
        var pos = this.get('position');
        var a2 = cocos.actions.MoveTo.create({position: new geom.Point(pos.x, pos.y + this.get('selectorY')), duration: 1.0});
        a2.startWithTarget(nv);
        nv.runAction(a2);
        
        setTimeout(this.changeSelector.bind(this), 1000);
    },
    
    // Sets the wipeout status of the car, causing it to spin over time and slow down
    wipeout: function(spins) {
        this.set('wipeoutDuration', RC.maxTimeWindow / 2.0);
        this.set('wipeoutRotSpeed', spins * 360.0 / (RC.maxTimeWindow / 2.0));
        
        if(this.get('turbo')) {
            this.endTurboBoost();
        }
        else {
            this.incorrectSlowdown();
        }
    },
    
    // Slows the player down due to an incorrect answer
    incorrectSlowdown: function() {
        if(!this.speedChange((this.get('zVelocity') - this.get('minSpeed')) * RC.penaltySpeed, 0.1)) {
            setTimeout(this.incorrectSlowdown.bind(this), 100);
        }
    },
    
    // Accelerates the player
    accelerate: function (dt) {
        if(!this.get('intermission') && this.get('turboMOT') == null) {
            var s = this.get('zVelocity') + this.get('acceleration') * dt
            s = Math.min(this.get('maxSpeed'), s);
            this.set('zVelocity', s);
        }
    },
    
    // Decelerates the player
    decelerate: function (dt) {
        if(!this.get('intermission') && this.get('turboMOT') == null) {
            var s = this.get('zVelocity') - this.get('deceleration') * dt
            s = Math.max(this.get('minSpeed'), s);
            this.set('zVelocity', s);
        }
    },

    // Starts a turbo boost if not already boosting
    startTurboBoost: function() {
        if(!this.get('turbo') && !(this.get('wipeoutDuration') > 0) && !this.get('intermission') && this.get('turboMOT') == null) {
            this.set('turbo', true);
            this.set('preTurbo', this.get('zVelocity'))
            
            var tm = this.speedChange(this.get('turboSpeed') - this.get('zVelocity'), 0.1);
            this.set('turboMOT', tm);
            events.addListener(tm, 'Completed', this.turboCompleted);
            
            return true;
        }
        
        return false;
    },
    
    // STATIC BIND
    turboCompleted: function() {
        this.set('turboMOT', null);
    },
    
    // Ends a turbo boost if it is active (usually called when answering a question, but could be used to cut the boost early)
    endTurboBoost: function() {
        if(this.get('turbo')) {
            var tm = this.get('turboMOT');
            if(tm != null) {
                tm.kill();
                this.set('turboMOT', null);
            }
        
            this.set('turbo', false);
            var tm =this.speedChange(this.get('preTurbo') - this.get('zVelocity'), 0.1);
            this.set('turboMOT', tm);
            events.addListener(tm, 'Completed', this.turboCompleted);
        }
    },
    
    // Shortcut function for applying a speed change over time, returns the MOT
    speedChange: function (amt, dur) {
        var m = MOT.create(this.get('zVelocity'), amt, dur);
        m.bind(this, 'zVelocity');
        
        return m;
    },
    
    update: function(dt) {
        // Always maintain at least the minimum speed
        var v = this.get('zVelocity');
        if(v < this.get('minSpeed') && !this.get('intermission')) {
            this.set('zVelocity', this.get('minSpeed'));
        }
        else if(v < 0 || isNaN(v)) {
            this.set('zVelocity', 0);
        }
        
        // Stop on the finish line when crossed
        if(this.get('zCoordinate') > RC.finishLine) {
            this.set('zCoordinate', RC.finishLine);
            this.unbind('zVelocity');
            this.set('zVelocity', 0);
        }
    
        // Set the chase distance based on current speed
        this.set('chaseDist', this.get('chaseMin') + this.get('chaseDelta') * (this.get('zVelocity') / this.get('maxSpeed')));
        
        // Update the camera and include the current frame's velocity which has yet to be applied to the player (eliminates jitter)
        PNode.cameraZ = this.get('zCoordinate') - this.get('chaseDist') + (this.get('zVelocity') * dt);

        // Let PNode handle perspective rendering
        Player.superclass.update.call(this, dt);
        
        var pos = this.get('position');
        
        //Spin the car as a result of getting a wrong answer
        if(this.get('wipeoutDuration') > 0) {
            this.set('rotation', this.get('rotation') + this.get('wipeoutRotSpeed') * dt)
            this.set('wipeoutDuration', this.get('wipeoutDuration') - dt);
        }
        // Otherwise just rotate the player as they move to keep the visual angles realistic
        else {
            if(pos.x < 400.0) {
                this.set('rotation', (90 - 180.0/Math.PI * Math.atan((pos.y - 50) / (400.0 - pos.x))) / 1.5)
            }
            else {
                this.set('rotation', (90 - 180.0/Math.PI * Math.atan((pos.y - 50) / (pos.x - 400.0))) / -1.5)
            }
        }
    
        // Keep the selector from rotating with the car
        if(this.get('selector') != null) {
            // Do not rotate the label, keep its facing constant in respect to its own origin
            var rot = this.get('rotation');
            this.get('selector').set('rotation', rot * -1);
            
            //Cocos works in degrees, Math works in radians, so convert
            rot = rot * Math.PI / 180.0
            
            // Keep the label in a fixed position beneath the car, regardless of car rotation
            var x =      this.get('selectorX') * Math.cos(rot) + this.get('selectorY') * Math.sin(rot)
            var y = -1 * this.get('selectorX') * Math.sin(rot) + this.get('selectorY') * Math.cos(rot)
            
            this.get('selector').set('position', new geom.Point(x, y));
        }
    },
});

exports.Player = Player;
}};
__resources__["/Preloader.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
Copyright 2011, Carnegie Learning

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

// Import the cocos2d module
var cocos = require('cocos2d');
var geo = require('geometry');
var events = require('events');

// Preloading screen
var Preloader = cocos.nodes.Node.extend({
    pct: 0.0,       // Percent loaded
    txt: null,      // Holds the loading text
    
    init: function() {
        Preloader.superclass.init.call(this);
    
        this.scheduleUpdate();
        
        txt = cocos.nodes.Label.create({string: 'Loading'});
        txt.set('position', new geo.Point(450, 350));
        txt.set('anchorPoint', new geo.Point(0.5, 0.5));
        
        this.addChild({child: txt});
    },
    
    // Fake loading update
    update: function(dt) {
        this.pct += dt * 0.33;
        if(this.pct > 1) {
            this.pct = 1;
            events.trigger(this, 'loaded');
        }
    },
    
    // Draw the screen (no images as they may of not loaded at this point)
    draw: function(context) {
        // Cover the screen
        context.fillStyle = "#000000";
        context.fillRect(-10, -10, 820, 620);
        
        // Outline of the progress box
        context.fillStyle = "#FFFFFF";
        context.fillRect(340, 400, 220, 40);
        
        // Progress bar
        context.fillStyle = "#AA2222";
        context.fillRect(350, 405, 200 * this.pct, 30);
    }
});

exports.Preloader = Preloader
}};
__resources__["/Question.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
Copyright 2011, Carnegie Learning

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

var cocos = require('cocos2d');
var events = require('events');
var geom = require('geometry');

var Content = require('Content').Content;
var PNode = require('PerspectiveNode').PerspectiveNode;
var RC = require('RaceControl').RaceControl;
var XML = require('XML').XML;

// Represents a single question to be answered by the player
var Question = PNode.extend({
    correctAnswer    : null,    // The correct response
    answer           : null,    // The answer provided by the player
    answeredCorrectly: null,    // Stores if question has been correctly/incorrectly (null=not answered)
    delimiters       : null,    // Holds the delimiters
    timeElapsed      : 0.0,     // Real time elapsed since start of question (including delimeterStaticTime)
    init: function(node, z) {
        var superOpts = {
            xCoordinate : 0,
            zCoordinate : z,
            lockX       : true,
            minScale    : 1,
            maxScale    : 1
        }
        Question.superclass.init.call(this, superOpts);
        
        // Build delimiters for question
        this.delimiters = [];
        for(var i=0; i<node.children.length-1; i+=1) {
            this.buildDelim(node.children[i], z);
            this.delimiters[i].xCoordinate = RC.delimiterSpacing[node.children.length][i];
        }
        
        //HACK: need better way of determining/setting this
        RC.curNumLanes = node.children.length;

        this.set('correctAnswer', node.children[i].attributes['VALUE']);
        
        return this
    },
    
    buildDelim: function(node, z) {
        var c = Content.buildFrom(node);
        c.set('position', new geom.Point(c.get('contentSize').width / 2, 0))
        
        var pSet = XML.getChildByName(node, 'PerspectiveSettings');
        pSet = pSet == null ? {attributes:{}} : pSet;
        
        // Create option settings
        var opts = {
            lockY       : true,
            silent      : true,
            minScale    : pSet.attributes['minScale']   == null ? 1 : pSet.attributes['minScale'],
            maxScale    : pSet.attributes['maxScale']   == null ? 4 : pSet.attributes['maxScale'],
            alignH      : 0.5,
            alignV      : 1,
            visibility  : pSet.attributes['visibility'] == null ? 5 : pSet.attributes['visibility'],
            xCoordinate : 0,
            zCoordinate : z,
            content     : c
        }
    
        // Create the first delimiter
        var delim = PNode.create(opts);
        delim.scheduleUpdate();
        this.addChild({child: delim});
        this.delimiters.push(delim);
    },
    
    // Called when the question is answered, sets and returns the result
    answerQuestion: function(ans) {
        if(this.get('answeredCorrectly') == null) {
            this.set('answer', ans);
            if(this.get('correctAnswer') == ans) {
                this.set('answeredCorrectly', true);
                return true;
            }
            this.set('answeredCorrectly', false);
            return false;
        }
        
        return null;
    },
    
    // Manages question timing and movement
    update: function(dt) {
        Question.superclass.update.call(this, dt);
        
        if(this.added) {
            if(this.answeredCorrectly == null) {
                this.set('timeElapsed', this.timeElapsed + dt);
                
                // TODO: Get the chaseDist from the player, otherwise answers will be up to a meter late
                if(PNode.cameraZ + 6 >= this.zCoordinate) {
                    events.trigger(this, "questionTimeExpired", this);
                }
            }
            
            // Pulls the delimiters more onto the lane lines as they progress down the screen
            var shift = (this.position.y - PNode.horizonStart) / PNode.horizonHeight / 1.5;
            
            if(this.delimiters.length > 1) {
                this.delimiters[0].set('alignH', 1 - shift);
                this.delimiters[this.delimiters.length-1].set('alignH', 0 + shift);
            }
        }
    },
	
	// Should prevent race condition of being removed before being answered
	onExit: function () {
		if(this.answeredCorrectly == null) {
			events.trigger(this, "questionTimeExpired", this);
		}
        Question.superclass.onExit.call(this);
    },
});

exports.Question = Question
}};
__resources__["/RaceControl.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
Copyright 2011, Carnegie Learning

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

var cocos = require('cocos2d');

var RaceControl = BObject.extend({
    init: function () {
        RaceControl.superclass.init.call(this);
    }
});

RaceControl.finishLine          = 3200;                     // Holds the z value of the finish line
RaceControl.initialCountdown    = 3000;                     // Initial countdown time in milliseconds

RaceControl.curNumLanes = 3;

// <AudioSettings>
RaceControl.crossFadeSpeed = 30;

// <MEDALS>
RaceControl.times               = [32, 42, 68, 100, 200];   // Holds [min, gold, silver, bronze, max] times
RaceControl.medalNames          = ['Ludicrous Speed', 'Gold', 'Silver', 'Bronze', ' - '];

RaceControl.gold    = '#CC9900';        // Color for gold medals
RaceControl.silver  = '#C0C0C0';        // Color for silver medals
RaceControl.bronze  = '#E26B10';        // Color for bronze medals
RaceControl.noMedal = '#202020';        // Color for no medal

// <GlobalSpacing>
RaceControl.intermissionSpacing = 110;                      // Distance in meters from previous object to intermission
RaceControl.questionSpacing     = 150;                      // Distance in meters from previous object to question
RaceControl.finishSpacing       = 110;                      // Distance in meters after the last question to the finish line

RaceControl.delimiterSpacing    = {2: [0], 3: [-1.5, 1.5], 4: [-3, 0, 3]};

// <PenaltySettings>
RaceControl.penaltyTime         = 15;                       // Time in seconds lost for a incorrect answer
RaceControl.penaltySpeed        = -0.1;                     // Percentage speed LOST for an incorrect answer

RaceControl.maxTimeWindow       = 110 / 200.0 * 0.9;        // Maximum time between two important z values: min z spacing / max speed * 90%
RaceControl.maxDistWindow       = 300;                      // Maximum distance coverable in 2 seconds

exports.RaceControl = RaceControl
}};
__resources__["/resources/car0.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/car1.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/car2.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/car_white.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAADICAYAAAAePETBAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfbCA8OJTQf5xSDAAA68ElEQVR4Xu2dB7RcVdn3d3oP6aH3rpCA+IIVLIDyiQXBlw8pKi4VXXZQdNlwCSpNxb4UVIKgiAUUhURUbCBSDCAhQEgCpBdIIfXmzrd/+9z/3CdPzpk5Z+bewLfWPVk3M3PmzD57P/+n72fvE0Lf0UeBPgr0UaCPAn0U6KNAHwX6KNBHgT4K9FGgjwJ9FOijQB8F+ijQR4E+CvRRoAUK9GvhN73+kzVr1hy6fMWKmWvXrA0dW7aEzs7OUKvVQi2+bun6vGnTptB/QP90rl+//mHI0CFhQP8BYdiwoWHw4MFhyJD4ecCAMGjQIN5fusMOO5zX6x3vgRs8rwBZsWJlbf36dWHz5s3hySefDOvWrQtjx44NI0aMSETmr3///un8xo0bM5DiH4ABVL9+/cLQoUPTNQD27LPPhghu+hs2bFh44QtfGPbaa6/n1Zg9hs+Lzi1durT27LPrEkEHDhwY/wakVwjLIcLzHuKvXr06rF+/Pr3nN7xy8JtRo0YlADkAqaOjI70HZL7vjAD2R6KiBE2cOOF5MX4LynPaoZUrn66tXr0qERzuR8VAYD5z8F6A5AHjvwMYVFTeb2lLbUvt8XnwkKFh+LBhZ44ePWpaD2ictpt4zgBZsmRpDdUzINoBKw1FIxJI9pX3Ak3g2M++LStpkrYtWzqjLYq2J6q64cOHTYkSdn/bVG2jge0OyKpVqy5Zu3btueh4uFlqiVdxsJUMAeClodmY7e90rW/Lg0wfhgwdFiZPmrjd6aI+brcbZwZ7fdTpm5NqEgBSL1IplvBeTeWBkCc59rpGwHjgM4nrnyRm1MiRS8aOHbNjM+B7+vvMavbysWz5ilqUiniXWgLDAiJg8lRNHjHLgNJMVdW5scuu0IfuPkXHYUtH9MzWTn7mmVXTe5k02zTfqxKycuXK2oaNm5IXNDAC0dmZuaYifpG+b8b1XgU1u947Cfq9lVIrjfR3wAC8vYG4yzGGGb3dYpheA2TJkiU12QmpJb024/xmBG4FEAu+3st+ecZQXAMg0ddLLvKECeN7jVZWTHrlJsQV69atj0HakHQv1IE40Lq1RcB4QLxd8YB4W5P3e88UAkPnvQ2Ta8x1nZ2ZW77jjpN7hV4WkB63IStWrEjuLGAwSHlSXlU1ck+tjvf6Po/T/fV5KtGe8/dW3/QKCLIrSAuqlgwCUt/bNqVHEcdm4EkpOFOgZzncxxF2gEWc7a+p4tJaycwDxYJhpSgDIsuhEe3zPoEU1djIESNmjBkz5rjeAKfHJOSZZ56ZDhiINoeCPc+tnsPzJKXROU/APGnyhPIS4IEpkigrKbwHmM0xfooe47G9AUZiiJ5qeMGChbX+/fsle+Ejb+Waiox1Gckoshv2fDPJyWOORl6fIntJCYDwhwdGEnPnnXfqMfppHD0iIXPnzqttib47XCQwbLzRU6BbA+zfe+NcJAVFfVm0aFH4xz/+EZYtW1a/hDYYB1KPGtaYGCtx1ZNPPtXjNqVtQB5+eHZtw4YNscOD62AAjOWuZnFHGbWTp4byDH6ZOMdLFcS9+OKLwxlnnBG+9rWvBcYjgBkHHheHAOF9yjrHtP7ChYt6FJS2AKEzzDmMGjUyApKly0V8C0gzCWnkOTX6bZ49KrIxRe3QT+Kl5cuXp/mT6JjUAfBjkJOCFiARvSWqrxXxerLWzcZY9vu2dODsRx6pDRo4KM4/DK+7t/Lv5ZXIW6FDzQK+ZgGjHVRe0tF/3+waK2H//ve/w3//+99w+OGHpz/FS77PjEe2BCdm06bNYeTIkWG//fZti5b1vpRFzl/30EOzaiQKx48fX58uFQfJiAsEzeaJ46zK8O32NCh5jJCn/iRtXsrttZoQ08QXkiX1NnHixBg47tg2KC2pLFxcjN/w4cO3cW8tGCJGURBo9X0je9DIbc37nT0nW9CM8YriozwmkjuM6pJXuWlzNjPZ7tESIBs2bDwWm0GORxxlUxFlieAJV2UwjRyFPJvkwc9jhjyV6O2IpESRvOIupIbijCpjyLu2JUDWrl0TwRiapMNG40U6vkwn86Sg6FwZCShr8L30WgC8+lR/ZB8FCucHxTqAmDKaWWasja6pDEj0RmoxX8V0ZwLEEs0PwBvVKvahUafLSECRlBapz7z75akxAUY7W8+j9EuFFE8//fTidkCpDEhMsCW3UCU56li9dqqrNEf2o6dAaAaQlyZvWwRQFUDsGCwQ1gFQMIznRfQep6gnb1dA8Cy4MZGriJDnXpZ1OVvtvCdsM0I3i3Wa/d7309qSVF4U3WGcnFqtX8DpaXVclSWEOWfAsOoqT9c265DX1UX6upEd8UGg/Zw3NdzIrjTrb57E0Wd5XHyPyorlRNGWrG85+VgJkPnzn0g5KyTEA+LdQ4m7HWgzLi1LlEbqp8iV9gRt5Ir7fujavOyD9faYBxo8eNCU+FdlKFtdWwkQSjKHDx+xVTGaj2TpoAWniPMtUfOkIO/7vFGWVTV51xXd19/HAmHbkYSoQCKrqumYPmFC6xWRlQAhMqfME6NuqwyLpKMsMEXgFHFqmfNenRVJallWZixFdktqC0Bimev2NeoMwMYe8q6simrk/uYRsyyXe+A8kZupoVZUppcIry4ZqyQEWkQvixR+y8nGShKi+XFbZZjHYdYFLsuBVUCx9qCRtDQDoNk9rX3wJUMCRvdXTIJhx5a0epQGJIriGdZzsYYuz4CXjT+sEW7kURUNsJFq8kTjWqkXS+yytqSR2lM8QltKOLYCSmlAIoEP9R6Mn5r1IJXtUJ5n1IrOt0Ru9vsq9/SA5TEm13TPKGYTWq0cpQGh8aLCMkkInfLZ3rxONePqPOmyv/EE8d95KShScc0k0ktUkSTpOmV+m6nCRkCVzt+jsmLa5GrsCH9EpYpWRUA6hAdWRNA8FdKoc7RDZgB3m2lWFuowq4dKYAUV6Qo+K1Blomj06NH1Pz5raZvukzc9UIaT7Zg8Q+kzfaQ/HAcddFBp2m4lzWU6wzWklmNF4kyIziAJDv3g+E4rlny7RSqC83IpATOmHcL8+fPDo48+Gh577LH0nvwZ5zGWGE3uwyu/Y+UVh4osYBSAYBXVuHHjWMIWZ/P2CwcccEDYe++946qpifU4qqyds2Px7q+kg1fAyIrKQ9hll11aWmtSCcU5c+bEUp/+CQzW7FmXVypNBQFbod6gwBoAFyxYEO69995w9913h5kzZ6b1hUiF0txSiSIGiU0BQkkOi26oLqzVsrWGHPIIJbX8Zueddw6HHnpoOOKII8IhhxwS9tlnnzSORhJdBJplJKlIGIZ+c0QGqETbulotKyFcByB0hEFYQBSxZpyaVbjnAWKNbkxThzvvvDP85S9/Cf/6178SCKgnH/lLCq2agMjd0tmvSyqzwE3ESUVtUYpgHv4kvZIwFpMedthh4ZWvfGV4xSteEXbbbbdtFgxpDBaUvABRcQiAoFbpQ5TK3gUElRVVx0wGjVpgkDYSpxMqaPCAWCNM/dOMGTPCLbfcEu655566zhVX0yZto3YylZTpZNqGmLJRkgQBpfJVrlX2VQXTAoF2NcMH8QCti3jh+OOPT38veMEL6s6LBcQyimUOBYack4TQ5r77tlb0UBpFAInETIBALAsInYIIdjGllRA6COf89re/Db/5zW8SEBBYRXUQidWzcS15GpTasUZSKtGvvvLcKzXq1amYh/MWGADHQaCP2Js3vOEN4S1veUuyOWUA4Rr6RPvbXUKirp9JxyEegxLn8gpQlmstIH/729/C9ddfH/74xz9u5ZnZZQoCgXPKJmdLpAfWvSg7ZSwpFKHtq8p0ILT+UIfWCWEcOCdIFudxGpAk2p0yZUo49dRTw8knn5w8Ntu2xqUQwFbakMuiHb7bf//9SzP7Vuq9ig15+OGHkw0BEGtDpK68AcTAXX311eGaa65JhlvqRMSU+oEotIdnBBgilE3RiJgy1vrMNbbMiLZFWI1NtVSAg0RAOJXy0GdUsDhdLjb9OOmkk8I73/nOZGusLZO0WqdDKgvbSB973YbQieiK1hgsqgUCepG2HIi7+r3vfS+BoUGjggQGREf18QdBVDtr3UjeQ0Tm8LkvB65sXAqQPiMJilVoD9WHJOAmS43C4eqrOB0wlHMCHOIa2qIvjAFQUD+AjUf23ve+N7zxjW9M95f94DvZIEkLv6GvtLPnnnu2JCGVInVJgIw3HeSc5x5iiK9+9atJOvBmdtppp8T98tAmTZqUvJrJkyenzovLJTHWWVDMIzUEwXUdhISg/F79gNC2gE3fWenlHOABLH2gfwCtIBTmAEjUERWNX/jCF8JPfvKTrRiwSLNAC6niKtqnrgqr/AhC2AHy2UbmEPypp54KX//618Ovf/3reseom4XrYmVfGjwSJtfVEoq2RGRF4rQJseKkT1JlEFwcLdUhr0pgcB5iU1UpWyfm0XglqYqrYBz6R+Aoe8hvkV7G9JWvfCX8+Mc/3opcikWs5HHOenxV6JsksMoP7r///hQYMliIYwdJR+DWCy+8MPzwhz9MhICodI7rsTu2WFnup9SAiKs2pY64n9QZBJeRBhQ5ETZghIDcB4n00wBWpfp4xzIG92FeAwMtbcC9kOwLLrgg2RaBZuMSVDL9i6C2vMKqMiB0Fi4CEDqlfBaEw1589rOfTRzM93AunKeSIeWcipKU0s9WV1v1CKHFfbIDIiRt+uUCVvV5b8zbPx87yY1VVTzX0xcM/CWXXJI8MTGN2mLcjLmdGt9KNgRiSJfTObmqdOjxxx8P1113XX0uQGDIK9LmMtL12j6J+AR1hveDURTni4CSENrhfnAgTMF5pEC7/4gBJGEWjDwtYPtvYxQrKTgD2BgYUIAQQ8F49F8qy94zaoYZVbSOv7YSIKgheTc+q/uHP/whRJWWjKv0sjha6onvABTCy/XkO2VpUTfyrADGBneclycl15Y2+FNeK0/CvFrNk4S8WEZSSv+wRUi6ACC4vf322+u0tI5Nu4tBKwEyePCQSNBuQy6CweHEGVIvyh8phySug8hIgiofAUDZWQw93A44SvghDdYOqB2kTxIHVSQ5Agju1cpZgeRfbTrHg6Rx2HvTJ9lNXNvf//73dUagX0XTDlWlpRIgDMLmk6yo4q9DTA5f1UiHLRhSQwoobcpF6/kYPL/TznG6lyWWuNgaftkn2gQYgaQ5FM5Jyr0EChgLnrV3knS+B3CCQEmHdRiqgmCvrwQIe1uR5vYcROdIazPvQGeVo7KxgXJUGgxSxYDwZFhrgmtJxpf3EE8SIDdXxLO6X++5xqstqy41qebzYHIMbHqF94Am4PTKWOQl4oYfe+yx9YyAtXftgJE8zSoNZF7MwHrgJWlhEKgbPBCf7oBoMtaamwBAQCP4QjfjFusVIHAfcTslAbQvKVLs41WE1Ib9XoBJ1YnzNdUKUNrL0S6+kbcmACWd+n3M5IYDDzywri1k8KvQsujaSoDEAZzJWnTFA6gD9GmcJ0ntA4j8fz4r3SHuEhGVbRXHCURxtVIYysKiv+OUaAoQrYoQ8TU4+12eJMlD1KtALnKJrUqU6uLc1KlTEzNZ11vZBnazaAeYSoDETkwbNy6LfiEaUgH333HHHYn4cM3uu+9e33CSa+B+2RQG7vc+8QZVg7EuNgOHK48++uikGnEABIbUi+KhMsQQcHneVd452QdecUK0KPSRRx6pr9rV7za3ubStEiAMdvfdd0sEQc/LWD/wwAOpY3AwBAMcCCovS6oNLpI06NUT0MYBSAxSgp3BvhATHHzwweFFL3pR2GOPPZLak863eTBxtjXOeXGJjz90b2sjraQhWbvuumuSVsbPlLNqCGAMTRWUYYoeUVk0EoneLxYLxLFmUTpqC32PkYaAcA/E5hxExFjzHYMtkgadz1Mdug/TvRCA+xGoMZnEJBIgcUAQBY02VvJemb2HvrNxhGUIrwIhPnPx3B8mmTt37lbORNQYl0ZQztwugDCffuONN9a+853v1GIWNy1ro4NdFd/JlsClbFZMzkeqBE8KgLR8QQbSv1oOtkSTwcT7+vvf/56yrxREQAzAQlIABztDX2yuCy7WnwWMfufFDVaVWaICHL/hfkgnjoBS9IDP99yf3bPb3W62qcpiNVBMPdc++clPhi9/+cvhl7/8ZYigJLuBWmLA2JGHHnoovUqtaB5b+R4beeepDxtlixiK2rMF+tluC6RaugqaAzqceRf6EctuUkQt4slwyyUWIMom+/jExld5jgPt0T4Swj0WL15cl0g+w3hx/qcWaVSLhRstG/amgEybNu3Y73//+2nShxQ4N4/1WUkdwWWatoR74VrsBt6WHSDvcWW51nO/VETeeX5HZK/pV94rA4uXA5f+5z//SX+ApeILqSxJguyAHAGpKnlJStvbeES/hckk7ahInBaY4rbbbkt0EMP96U9/SoxKnutzn/tcAqcV1dUQkFtvnV7jxnAGagiCPPHEE/W91xmA8lKolFmzZiXA4CIMvzwfcZwKCqSuPAj2PAOF4BBDB4QDVO3nrnkRJAbi0DfltnzcYtMg3nbY2EXlQ5rkoj0OzsutJ5FK/Zj2oGdcjJ3PjBvAvvvd74aLLrqoxnaHVYApBITlvWQ2x4+fkHxuynfoiErtsQl0UqqIAeBt8RqnL5ObqgBwcHxqwahhsaJw8NCwJe4NYieYrC1RxyECXhu/t/MuEBJbRd4MABTRK+nHZyRIds17S/azQLCelgVGqRe+5z3SR/zBvZgRlXfHKwDQJ12nmdBoc9NEXZWjEJDIbZNZiz5mzA5h3rx5SWeiq5kHePvb3x5e9apXJa9KaWgGix1BtREcch0dTK4r06pxu9iO+LcuPoKCtvC+eIW7Vc8EseWZcV76XuqPtjCoqE4kVhlY7o2EAiKqUepGv6MfNii0n2Vj7KukRAzBK84DqSH6dNddd9WTpGpLqR6+p1+oNvr5wAMPRsl9srSUFAIyc+b9sWzntmi874x2YVisVzoxfPGLXwznnXdeKo/Bs8F7gkM46BBcSz0uXAQ3DY57aA2gGCDmvzZs2RzWdEQVtzmbzwAEiIhR5jdIH1wGt0kvi6BSGbSLeuA+SIJiHaVg8HQUhNIvORyaa+Ge+tN3fOZ7VaPInug6wIbpiK8gNPdGPVlXHYmglgsm5feMQ4/H4PWpp54sLSSFgOwZCX7GGaenDb2mTbs6XHHFN/qddtpp/VSnpIl8BkbnlKd68MEHk+2IdUlhx512DFu6No+kRykw7NrZGlWEGkCa+FMqXmvglWfiOv0pEyyPC+LIqwIA+mDnTKSClOrxLrFNJMpmIGGaihX3028YDDUdS6GSA6FsNNfQV7IUb3vb28I555yTwAM0GG7jxg2J6coelaZwaTQGZ3Fbpo5ERDr4zW9+M/z85z8PozFmUc0cEjtzcaw4IW3CdC4lo+hh5YKk4gDRlv7wWWl0fotxtIlHPquqHWBURCcPSm4tnK75cL0iTUgehFbVSlEey7rfYgqcmh/84Aepev7yyy8PP/vZz1LaiHb5TEqH+wIU1TQxeJ4Rtws8dvr06eHBuAfX2e86O5x22v8tRetSF1l0o6GP9M2Ky+j8ZZddFjBeI8lrxQGPioS77NJLU43sT3/601StIfGGGCrBoU3awBZIP+MI4BBQ/WGfrKP8l41P8jhOBlqcrdS93GXsGzaKZKiWOiBlfC+Dr3aVd6PvL3/5y8M3vvGNZBM/9KEPJe6n79isS+NYScVnKnh5qrDfe++96nSdPfuR2vjxqWqmFK1LXWQHf/fd99RYGq31IRAcKYB7N1ARGME679xzU2EZ8cEHPvCBxJ2SEgwd+ShSLBh+VBs6GImz8xVWR8uLsv2wKQ5/3kf9NqfFe8VPgDF79uzUT6J/dpSDywWO+sAYPvKRjyQgeI+aBhCuZa/GE044IZ1DRcFg7TxWqWlgmMeJNielFDnXsclwZ+QiImgGDefD9aibl7zkJeHjH/94IMgkgMI5oNoc50DFcnKB84LEvDxX3vU+F5XXf4Dnnqig173udYEsBCrpqquuCp/61KfSEgWy1HJWYCAkG/CUChLIgKeKFy/JZe2Gva4yIAr2xLVSQylfFfdBGdFvUJg7J4tXKIr7zGc+kwYLEB/+8IfDkUcemdSRP/KSfkVxRF6W1uah8lIzFjzei6lku2CaF7/4xeGDH/xgKoH91re+Fd797ncnjxJJpk3ceuynndYVIMpk23mTXgdk9eo1Z/AMEHEHnURPqzO4t5s6O8KTCxck/UpnGSTSgWG0KXerRvJUkSJrvVrd3igRKcIXEcNKkM+fCRz6il34/Oc/n1x9JB2VhIQg+ZbotOdVYitA6DeVJcQSVVFsKn6IEXhH/IuBR/Rm1tQLnm2HvVG2eaw8g90oz+VVWBk1V2R3itQyKkg1yc/E5OGCGMyqMMOqLElcxpjZkyBaPSoDYkWdASotjXcwOM63j4rpkX4xLl0YUy1en1vb49WGlYCyg2lk2PNUopcye42XFvVP55dEBwDnZGAEidSMVDYSbJnJreYrO5T6dZUBseXAFpDOiEhcEhPi+qcQF5GEJREQwLIdLsuhZa+rOtoi21MkIVJhfL9k0eKwJaZ+BnXl8PQbjU/Xeqar2sdKgEQ6z7ScJJWVzsU7y53kPRzlE3ieI4ukpOwgigZvz/trBLbN+HonwNsEPi9cvCis2ZDNy9jvvQ0p2/ei6yoBkhGwuylFyRo0ndM0Kj65TZ0XcaEFpZXBFDkHeSrIqyx5ZhYcr6r0G2IOzZ94tW37wBLtdo7KgKCyrJclN9gOBM8Lf12loEUdbES0VgbVrrrw91T/AILpB145R9om78jyatlKr1aPyoAgIdb7KbIRmozKc1Etp5bpeBW3sgooRfGK7xMMxtSA+mE9Te/KRyXR1lEJkDiAKR4MAcJ5JQc5p2pF746qt2WlI4/AzYje7PuyFNNYkXQSldbI6zsbJGZjKtt6/nVVATnUcoAnNqKsNIgml1rxmIrsgh1Cs2uqgJIXD1nbpqlqPUbcSrjvx3aVEGs/6JSMon0vQmgK1BvJZpJRhZBW2trjy241nNcOzIWDoulkC1aRF9dqfypJCGkTe+Rxv1IdxCAMoqyetoNsZTCtAFn2PlrK4ANd32f6wK5E7RwVAdna7fU3tu6jLRIo08HeIGhPtEkbAKKCOMUd0gpeZanAvMyY866pBEgk+Bneq6JD1rDbDG3ZzvUE4YoI0Grb9ndaou0TnXlSDSO2c1QCRFxhjZrlFN4LHBUHtGLU7YCa2Rx/bR4xWgVFYxMg1mZpXEUxSaugVAbEgyEQGLRSKepsq9yS50E186ossdoBJY+B8iRE17Wza0PbKisa6lRqrs6ISNZtVPGAl6ZWOaYd4pa9ZzMJkv0Qgyn28EXkzdop059KEqIaW68mrF3x6ejeAqYnBm8ZqVF7yloLEGkDAWJtSataQTStBIhHWJGrzWfJzW2VYFV+V+XaIu4ssnH2vKTeM54A8RqjjCQUXVMJEN95AeLPK40iTirbwVYI3Mpv8vrTyPnI+05TuaqULDvGZtdVAiTXCHXttajvlJK3UtOsE8/V92XA9Ewlu8n48LBs9N4T42gLkCKVpU73tAfSEwPOU7uN2s2TDlSVSkiLtn9qta+VAbEJRa+y9Fkp6Z720VsdZE/9zrreAKI17j3VPu1UBsR7WKrC8JykVLy9vt0gsScHXqUtracXIIwNz0vF32rLplWqtG+vrQRIHtG1M5ztVEK6a6GnP99qR5+L38nG2OdtSfqRELtLqvpXxi41GkslQLRugwbFDbITljvolKrT825eJQNcBYiidv15q3bLeFeqObazg7IhvlKxXbtZGRBPIHGP96qsj24H/XxXW3kc7rcAYQyMV8spvBqvwkT+2kqA+OytVUvyy61Bt0a9t6SimYfkmSGPIfL6ZpOadmtCKxHehuRlg6uCUwkQSnukrqydkJETJ/GdFru0q1OrDqg3rhcgAknVmtr2qSfvWRqQuMSgxlJgy2EAoUd4q+hanavSWZtTKqPS8mxAM1tQpl1PWAFglxlwTnu5aAdu67gAVjtHaUB4pAQLM/2B2NJJVJbdX0rLzooI4SWnFYJtLw/OSghMSJKVc3bjTfoCGKyNaecoDch99923zXZ7mWoCkMwvt3pXgIjwVk9bDm/khXlJKGuH/L0scHltFhFQTCLjDRgwHWOVSrZeJjYkri1kkWfL1VmlAGFTLnZJsMRlEHxm2S8l+J2d2bM+FK0LED9Yq56sPWqHq5oRtNW2NV4Zb7sjHu/9Jp8Awipdlsi1epQChEn+lSuzDR+taskAyZ5ew7pDrhORqc+yEW4R19qOl40PPMfnfS7jXZUhGmNUikR7ttA26krrIu39WenLSqtWj1KAZJMu3Zvu2w7AJVGSu0AZWN9rnUWRiDidt6qsHVtRdpCt3MPbNO/2avtBKy3a1tz2CynRfpFl+2uvKwUI+/VOnrxj4gg/2AyQbH92dCsqTJsjS7/mlf4X2ZRm5739KbJHZa8rQzTGo00OrPOi545IK+ieNgNcpv3KgLDxJapJ24LrxrIhvGrfE8ABOBZReptTZMDzbEkzLs/7vsjoN2vL98tKi8amjZS1YwTntdxN/ceGQiOt4K0KBteXkhC8KA52wWGrvYULF9YlRdxg9xhBv7IFhwckj/vzwPA2ocgzyrM5ZT2xKsRibNokWllexmbHiCuMh8XmBO0Ew6UAQUJQW1S0s1EZD2ph/3NtNAMAcFDaPKBrz3YvtmU5ugw356mpRkB4jq8CBtdqa3PGr2eKoAkYr2jCbnss/db6w6r30PWlAGFjR7ZqYmBwQtwuIm6bcW3a8o+d1Di0m4624dPjLGzHrMubx/W2AjLv+0b2xd+nyGOrIkFySOTual9J7sU5HnbG45De9a53JSZlkRI2BlXW6lEKEPbr1SOAiDeogtciFtSXclnaThzXTx6WNXje+DWyKf67MpJThQhV2mMs2A7ZCHb3IS67+eabw+9+97u0pYaARr1Bq1aPUoDQODfZOvfPypSsWrHrISZp0y5UF5LkJaSIYz1IRZJRFkxP6EaS1qhPIqgCXWWu9SQ5AaT7KcvNuHvdqNM5G+hx8+yve5E8EsOWGezmw58kpJmKyLMHrXJXO8a06J70j7Hg4rJRNKpKG56JSXjVvbEx201CFFdg5OUOasUQHce+0CG209Bmw7iB2q9Ke1Vp3qAKGArUxLHdTCHmaPxqAz0RP0+aRGQtpyDIwzaw3QZSwgac2u/EMoAkRA+naZmpyv4w6soaG7JgH/Ck1q59NnZwUIw3RsfI9Jn6HiAEUWx19+Y3v7kei7A/FRtqIs7YGa4BMCSKjcDgPvn5yqxq226YIG8K1QIkDrXSaEHnvd9/UVv5wST0Sc9rR93ImOsBAPTp29/+dnoUINLB9/SJa3FipNK5DzsH/eIXv2Ajs5ZWG5b+UXzET41NvJYuZdu6jYlTACTu5Bzfr65vQgOxX//614cTTzwxqTlAwPCTvofIv/rVr1Isk+W/uh+tqpSEAFE2VXkkC5Skw3K9uFVln9rEzG77qo0udc7u18t7GIM9d4866qiU/rBPZODJc3ynx3PrcRsCRA9TZnc5Hq9XdsMyLxClAfnrX/9a+9KXvhS5id0Mso2Rs81ZhkeuyR4XB5EhIJuXAQoD5DMSwmO66TSPCgIcq3fFkY30eFlJbnadtzP23uh+tixkEzLG97KXvSxJMddce+214ROf+ESKM9hTUe49r3yvIJHNMH/0ox+Vpqvvb2kvC8Kq+p0HyTOwzPPIjJ71wPJiELiOfdPt7g7S4XlEsh216qnIcBddo+vzbIhXdfRHm3p6QmXTDNmjWNlH66yzzqpvIKC2GVs7Hhb3LA0Ixjp7pizZ2+41IuhNC4h2BrVpEwaKSmDnToyjJQ7Xa4NLPQJPcylsgMaOc2wgxnt2p9tnn31S4KWdSpE69rNi73e+Z69HPWeRtuFwGIGN09i3i/0TeaA9/fABHOPAdece2nVUwHAt98JhQUroj5wcORq88vt2jvw9InJaZJAMAq9J8QcDIFDUvIdcRC8hcA77G7KnIZsnW8lgoAwCzqQd7emL8USq2EgMovLob4iJKuG57OTVAJBt+niiM5uLsWkaW7WSPWDnUFI7bOF3btwDko2b6bt2s2OXO/aqp0+aB6dfytPhWdlDG3bi0mNH2H/RXgMYqHA9PqNVUEpLSOTAfnAFbi7JRhll70IqFS+PR1XicDp7wstHlwTZqVAVRmg2DibA9+cRFSTtkALAlnuN1PI9kgGhmakDGHY1xQ6oOh2A8JJ48CUeEDuT2ieVagz0nXtiI2A+e3AvvtPDbGAwPbUtqZquSs3tprK4aSbimb2SOyo9LLEVMa2uh6uZ2oSwmYR1H7aWSfvJAwxqA6JAfDhdz63iCTdIBkAALtuy2owzgEBsOJkdT/G2eAikUj9UzrBHvfJyPhYhX8UDMm1Gm97qHkgFkojEeXvIfT2QVSWltIQIEDuAjOjdM4LiEnGOrsX2oMchkF3g4tuS/WFQcBqfZX/kNMiZQPVBGIJOAOfgWj6rHdQf5yCmNjrW0w7UtvWyaBugeSgNUmalnzGRv7r++utTTIWEaPma2oBh24nSk6RVQTDbPLk7TZARAXHNCMeAbPmP1BZcpX1xbX0w19OmfgvRCdL04Hs4DqJqI32uBwh0uB6lx/XKGii6lrFlSyXawhbpyQmoTbaBRRr1BGtLA9rDPnAfe2izfcaBlOn+uoY+0B5/7RyVAKFTKozToBOqERA+y14gBfYQUVAvthwVoqCTlXbgN4BH9hQQ4GzUgtrmVXP1bMjMe1QY7XO9+sSrUhi0TWzADqNs+nz++ecnJwICcm9Nw/IZxqDvfI8NsofqsGwNs6YL9Fu2Gec5VNsFEEqB5BGJo7NXYZrt3S5dr07RaVQLehkxt8RXtCs3loFBWPR4BnSW9rbpE7mrUn1K/UulSQJpC+bR45JwKvSEA87r0X+ZK58dckh4ugF9zjRAVmnD/bjWbozg1R3uNM+h2i6AaOryyCP/JxrcvSORMiAYeNbJrOPofut9cA3cSnwAN6LLdcgeaMpXXpO4nfNSDbQBgIDF/VBHmpPhFVVh91fRw8Aw8uh8FSpAVNVT2RJR+qScF/3UUyAECvdWkYcmrCyQxDhkJ9o9KqksOkJwd9ZZZ4bTTz89PgJoanQFJ0TOIvtLTNKZvAwLiAytylBVemo5kmv0mAnagCAQWMYYvY7uR03pkRNKRkI4/pAAPCtlEyAg0oE3hLtL5aU43W4AYB0LxkdbetKCwOCVfsvQ0zZtwHwAgRpku/KYWGw5ZVIHtyyisg+INZ7IMcccHacu3xm3D/9QOOWUkxM4xAMEanYuhPYhHr/RoyREBMUyMsoQQ6kL4goGjgd1zDHHpA3vAQ2bASHQ1wAEkbgfMYr2bJeEASRuNnEHoLDnPPu733DDDakvcoVFA4isJ/so2BUoSBMZA2IRmOP9739/iE+vS4lEnphAf3riKC0hcKa8KNkBOglBiKB5DNI73vGOlH62B8TXI+pkiL3KUgyD6oEQipy5D9nTk046qa5C1AfcWwFM35AodPirX/3qZKyV4ldwCKGJhXh8E44DfSGqljRLfXLezo5aCSKDfeWVV6Z94T/60Y+m+3F9UZ6sFYAqAQKxpHc1AE1twr2qxfId5BqIBqfaqj6f01IMYbfSQ0XKLsHBuKN6MAsDBmwxiDbURyLlLstTU6Bq+22JzXvax8Mjg2uXFeg67BiP2QBI23dJeCsA+N9UAgSiA4oIYL0fndPA5Z3oFWKh4221H53RwHjVXr9yhVUPJU9In6XPNZevqknUKqpR/eR7TT7pPvQHYgMk0biNtrkeYpMi0oYAAkOvtr+2/7yP6jE+rKC9ozQgDAAOUYdspMtArDtruyTPBeNKwAV3W27VoOS2kk2lrAZ7RDxgqwO5FttipVSRPNwtN5TfQViARTK1WhYguE6TV6guCwh9RQJRa3o8oGcsqVcLjN7Htq5uD44KkToqQLkmdUo1u3kzeDKGDAiOhsA8KdP6/YrA5UZigHFRyT0RsygFbtP7qDyITCkOKk5P21RwZvtGf+mjrcoXgbk3gFg3nOuV8scm5dmGPCB072Y7eZcBq5SExFTFoRBVg7Fqy3K453yJudIRBId6/Kr0P0SRG6knpSFN2idXBOZ35JL4I2hDvZFCQVq4Hr2vfsnLo10YgFe1I0YBCKRBG3VyXvENyUyfBLWOSJ6UcE8BX4bwRdeUAiTeaCbzHnq8EQOUelDnrJRo0HpF1fHYUptc5HcigAI6JQMBA8Jr718+M6fNLB3pD3JJtAkQPHgMj4cyTuY3FKdAbIJICE/frIoFBK71dbiSEKQZR0Kcb4lXJDXKw0XGaHn1FPcpBQiEIqmoUnwR04Ji7YiVFN4jBTwLXY9mleTA3XpyGlKk5w0Sa2AHSNcT0HUtE0vtoKaUD+P3nMOuEP8wacUaPyadxAz0GW5XCRKqCnXHPL9f5i0vjuhexQzWE/Pjstohm6zrrGeeW5WS0oAoh2PT4Najgjg2mLI2BM+HKVQ4TwlABipHgCgeYkp9oH6IGZhY4jsKvPmMQ6DknqSVPvAeqaF4As+Jh1sCJFJgPTAIzjkYQ23ZZCF9I66yEiLCWi9L/baepSSnXbVVKtSPeaMaXAVHKUNq3UENikFK7cg35zoIy2D5nuceIg2SLpsXkhGWMecz0bG8HoBl/lzpGDhfCU3axl6QQKSvzB5qtSxEJZ7hM4BBNIDSjtUiOmBcccUV6TzxC5E/bSpG4VXZBZvt5jxMoQcUxz6XomueFJWSEKXTrf70upTPMp6SHN2QdMNLX/rSNAto9bLakBHW9RBOBWxIBq4vGQCISmkOhHrta1+b2qQoD44GCMCCKEgBRFWqBZXGuj/UmdaYy67YvsqG8BBiu+DIG3Svuuw4tsuei/KuPKGtDeF9kR3BuKJ20O2+w8q+ShVqjt2Xm/K9JpXIW5HewLArM6tkowDHKyS/xG8kCVZNQmQV38kWyMkAOO/CWufF08ED1qr9KG3UBUijG1lx9h3GY4GbkRQFcOnmkchwvkpnBIKmYNWOntqD64t94PHZ2BzcX9Lweqi9onDahqA4DLjHSIqdNNN4bHyjc/QRSdREWJ505HlaApXvouMxvVVQSqks68ZaI2dFV9d448416Hce9I6hlYRwHp1NOgUC2NIhGUa4GwLh9vKHusH7wXboIfaakKJd3GDUk9InWu0EsW0xhXVGrBcFiIDMvRTTWECKshGePtFGHtvrgFggrEG3HZZKkLcllcZ0KMTCE7IqCz2N6lEKHQKqukMpdIgA8VF7vBJXQDjNBPKea5EGjL+KtwEA8ORNyb5ZQlkwOE/b2CwkUvk0q5aLJMMTn9+3epSWEA9IEShcZz0QBqHSHRUmqy24Ea8HInAgJfLYaB9JIV7gHERnoAoWIbRWNJE+4Q8ASL0AjCJnzmmpmeyA+u4TorRNNgEpR9K86m0EiFQerzYdUxWYUoAoKafclUTUcxjnuYaBYlQ1YAbHn+bKZXghFDEBgRiV5kTz/M4WD6j6HWJhL1BXAEl8ApD6IzJHpQEw16gKXtO1WkijYrs8Ncw5YhnupTLTvGCwSIXLPYYhWj1KAbJ5M1nSzroe9kD4z1rQIlDgGIqUcU3tAcdDQHQ2cyUYbIipaVwcAdIlZH9f85rXJNVG20gSqsk+aAWu5hxMIDvGey1BQMXRNkzAe2Ihm1ejXxCfKVmifs3z6HyRZ+U1h5iiVwERt8k4+k7Ym0usleLmFcIz7QlhUV/29+I2qR+IrS0riCnuuOOOJA2yDarZkhSqXgoCSppUroQrrGoReVpIqZ18on9SZcQ3rKrFfqigrhFhrZrSe9rrdZXVGZ8CbT2VPDdYUiJA9MrAZBfe9KY3pWIA1JOA0MomBZZSiyrQJsjDzY3rU1Jgh3ojL4ZEyR1WG942+HlxO+PJfVQQwb0p6qZYAbUJ6LYqsQy3a54Fqe31vU4EAIOwHbUckiclDJQOakoVNfHWt741XHjhhWlRj+azZbC5Xp6WMspSL6gbqR/aFAHkzsrw+0kozlspQbIAUt4T0vCe97wnrbmnNkDxlGKavGDYAyTbwb2QDpW2lgHSX1PKhlBgLUNr/fmiG1opgXAQmXMQgs6SaCSnddFFF6WAEc6FW/lOZaJcD5AQTOtHVISnqF7SJMmgHaktrR+RkwCwtE8f+B0qkIpGKlEAQ4XZaktzNN4TywNDjEqfsVHN7E0joEolwR5/fG4Nb4bdHBi0Ft0UNWz1Kd4PxlggKQUCsfnDFf7zn/8cZsyYkdYe4r6Ke0VgpUXsRJYFXcBoEk1zIlJJyg4gKeS7qGQ57rjj0qvKUGVLZE9k8JXTKspRSTrICGCfbrnlliS9F1xwQSnaehqW+tG8efNr6O2xY7OKdNW9FnGCCKqATYGfJSIdgYDKZUE8bARuJ/MguMO4uXC11IgkwxKPNiW1SlIKAACEoIAwderUVHTNnL3W0Uu90RebRuE9qod2be2WzTLIBgoQGAknhC02SHZ++tOfLkXblgCJUXZt+vQZcb55x/oC+maizI0YAB31gKgTAkiFzKqcV32vJpLwsjDiROOoBE1mSRLlYcHt5M0o6obouK8QhyQj5+mzbI9As3MbNjWC6qR9SYh+awmo+9NfNAEZZVYqsyT8Yx/7WO8BEsWxRpUehCWw0o4GnuM92nAYolwEiHx8/U5lRcrCqlpE4KrEE5WkySz6kGc77JSt3HaBIMn2E02SQL7HU+KzVtdyTu6yAlsBQl9gHpbdAQirlaOL3xIgpYx6JNCMFStWJpdTRtG7wduIXhyA5TipBP9qbYs8GxlgPCv+lL+CyETQVAsiBcQ0/AE4TKI9ELVOEXWnjQ5kT7x0ejddfZaaFNPIqZGqsiqL7wAQtQ7ocut7zcuK4n4c3EqeSMk62yHbSXVCdsQToBkwlkACCCZQYlGeGCpFfyK8om/Nf9gUjIy1Xq3K9ZIuuySb5MdnmZF70D9ybizmITvdzkrcUhJCh3bbbdc0LQooCvaagWJVUh4nFoHTDDSv6vx98qTQqycrmXpvOdo6Dt5ueOmAMZiAQ21RasoC2Vakg9+UBoQiN1QGNya5J33sg0P58VYyLKd6YlqgirjWcnWRyvOc79vyoOUxiye87uVTJD4YZbLsn//8ZwpAcafbOSoBcthhh6dJJlxT1IQFJS8TLHA0iZQX2VsApeY8SGWBKlJHIr6XUhl3z0SK+vMCUI2TsWOX8PpuvfXWNI9P+SqLW9s5SgMSDWc/1mhw3HTTTeGmG28Ki2KmtjNmgT1RfYcUqCn3ZCNsT4w8Tm5EUKtubFzkz+s7/yr1o/SNlk5oGkFRuE2PcC12igpHIn1W5gIQ0X5UV2e2A0j3DmQlWrnsssu/gGg+9N8Hw7y588KquNv16CHDwsRYLd6PVVRd/yxRVeWhEn9F23aOxUtGESgWmDzV18y2WN0vDteMI58Bg1iHuRv6h9cmaemM33NuU5xzWbc2bgb6l9vDVT/+UbjxxhtT8R7SdOqpp7Ks7aQSpCy8pJLxocY3JgZnfu3yy9MupeNjx18+Zrdw+iuOD6NPfEkYtUvXuonYORFHXhlbWRB94xKy3pCADXeVYM4umsmLDfJUjZcGL2lSjxYEAS9VpKlhJpRIDVGdDzBsw0S/cKUBLGWTu6Ri3ZwnwkM3/y1c/aebw10L54RVa9ek3+B+E6XHsqRKNPXIVP4x2zSdc845YVaMSvtFwo8ftUN4/YBdwtQXHBJ2P+6osNOrXhRGxXTFAPZjjFKzPmZ44axp06al5V/y7wm4Jk2anALNvfbaM7qKe6TYYsKE8SkY0w7ZRbVeFgCrhgSeXFOpIlxiOFmlqyrcJsJWeSq/JdnJEmqSk0hImjbeuCGsWBT3aPnXo+Hvv7gp/H72veG+jpgx2BTnzlmlG6l65plnsrXTmWwYut0khBtFI7Y4ctBk9g6ppdW32RrCg4aMC4cMmxQOm3pY2PnVR4S9jpoaho3fIeraGFV3bXjGnAaFDuSsli9fWV9PaKPtESOy/X9JWZDuUCEE5yCQTTQKCM1tqPhBu8PZ7QVV8OAX/COdJEsp4mNGk1wXKZfNG+MzQmLstTCmbFbeOyssu/uh8NDsh8ON8+4PizZR0tpdU03frrzyqrjxzSmVGbxtCaGB2267rXb22Wcnv1vHwK50+ZSB48MeI8eFww56YTjif44I/Q7fJ4Rxo8L4SROYI43ivymlU+bPfzIFU+SpqEhZtmx52pluY+TGosmhPFdWksKOElJP2u5Dny3gEA8AUDGAsG+sUkRCJ0yYGAYNHhQ6O7aEFYuXho45i0LHg/PCYw/PD3fPnxXuWxHV2uo4b7+lI3R2SUWymXFMODuoq6jinhtAnn76mcXnn//JyaxoTfmdSIxaV1eilgojBg8New7eIbx8yMSw7y57hzEH7hNGH3VwmLD/7tEBmBT6D2WtSSRX17o+rZYlfa0KEkBDlZCSIHUiD01V7D4KHzCA7QIHxViAJzRk6gbVh4Em1UKGWrsLIXmaJkbh1CK3b16/Iax+anlY/9jisPr+OWHprMfCPUsfD3etXxoeXx3XxEcgEsBpsN3biwAq8ymnnNK+dCS726q+u+uuf9cuueTi5ALXyy7THstxdwf+UXkSibPrkB3ClKGTw76jdw77TNo1TDo4FhBM3TNMPHy/MGb82DREO/ml/lgbII+MV03XbpsWyfZwZEMDFTnYYje1t5WRjx82PLs+dDy2LHTOXx4Wz18QZs+fF+6e92C4d/njYcWGtaEjAgFgeZTCQTnvvPPYr6tlOvaIylIjs2Y9XMNQX3fdtSk93sVCSVroYbZXUDbXMHLI8LDbyCgxY6JnFTcG2OmIg8JxJ78x7LXv3ttsaGN9f0tA3guIvIDSelYWWOuR6XzKRMepgQduvyvMvevBMHfJojBrydyweNWysAFj3dX3Lj2Y1G3i4K7sMmrqfe97H25uj4HRloRYZOPG/DVWOE2fPn2bRTC6rn8aEBlgNrcfFIZGtTbl8MNS7oc8GTpdakW7Y9tssYiNGlPqQm6sqhy5F06ABY5rkSoVH6AScXNJd1D8/dgjj4Y1z67JAtyuzqKWkHIxgx0rlfGUJuFVtboVrJcK+7nH0I0SUrvmmmtS1Ep9lS21yeNQcThE114nEJPJJBZekobA+GIDVOWOClIZjzaf0YQT7XFO+6mQ0iAYBQDsEe4unzXBZfvXiEACHTvEHDzB3zHHHNNjdPP37vGG4/Rr7YYbfhml5dY0g8bAuwHJ9tTKPCLxY+apZBoh+54P/ZEmYw/YAornXLGnCueRuKytbBlERyzm64y7pSry7s4EdD83C1e1S/Mkae2WgOwBA14iaHvs2HHh+OOPD//7v29jL+Iep1evA8INli9fUZsz57G0Vy+rp5gjXxsjWhE8L4nILk9sYpP0KIBA8C63UoRPUpUuif91+bk2ircERe3gnnZuwWnIQNnWRaaZbCejbquX2TxUKIuBTjjh/0SJOHoGc0KNJKmnvut1xGOpaI3sMEEhqftHH30krN+wbivXMcvS4plJUiJRIkJJWCC+vIMu0mU6Xkem7a1azICLxQ9dgGybZbbDzvYgxm0eP35CXEI3Ne1hQkVKLH/tdfpsFwkp4hYeuHjPvfeEO++4M86u3R2zpXPi3EpW2tnN6ZkU5NkdKwH1dEk8mYGXqa/smiSL26igOoRdntKIESOjzdolHBIj9MPj1AJg7Lff/tiu7Q5EN3v1lKxVbIfCifnR52eenqlPlgEsWrQwqjYq10lvb0wJPeyCTE4ieldgJsFJ0pFUXRcASmkkqYt2J3K+6oXHjBub8mUEcwcecFBMlx+Q9tmK6uk5A+A5lZBGmLGF4NKlS7KihJgGX7BgYQJo6TK8pKUpYl+/fl1YuXxFeJoZy1oEK7q0Sft3qTeM/YTxk1LSEq9op512jsnL6FLHvx1jCVO27+6YthOAFXmv0uXPG84o0+vVq1ddsuqZVecyhby5I0uJp0CxSwUNiSkTclI7jB49ZeTIUfeXabPvmj4K9FGgjwJ9FOijQB8F+ijQR4E+CvRRoI8C/79SYNWaNZesWbN263XfLQzm/wHV0G57rxQmrwAAAABJRU5ErkJggg==")};
__resources__["/resources/checkpoint_p.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA4QAAABkCAYAAADe4v4kAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sKHxQwNBM60M4AAAAdaVRYdENvbW1lbnQAAAAAAENyZWF0ZWQgd2l0aCBHSU1QZC5lBwAAIABJREFUeNrtvWlwHNeZJXpuZu0oAARAECQIkiAJkuACgCAB7ov2fbN2S7It2223+72Y6Pc8EfPizfsxrZjpiYno/jFrj2O6x+Not91epJYsy5YltyRLpjaCFCmR4iZS3AACJAGCWGuvfD8O72RWAQRBIAuoAr4TUQGyCqi8efO7937nWxUErsPasqURHs+3odSjAKqhVHq23DqU8ooECAQCgUAgmF6NxEpc+5eSySgIKAAxWNZhJJM/QF/fS+rIkX6ZlqmbfIGb+09r6zJ4vd+GaT4Nw1gmMyIQCAQCgUAgEIwD6XQUlrUPqdR/QjT6z+rAgasyKbmHIVPgIhncuHEhfL4nYZpfgVJLZUYEAoFAIBAIBILxMhMjAKU2wzS/i1Bol9XSUiyTIoSwcMhgc3M5vN6vwDCeglJ1UEq8rwKBQCAQCAQCwc1AKROGsQ2G8V14vdusDRtCMilCCPOfDLa0hBEI3A+v92sA6iWPTiAQCAQCgUAgmBAhVACKANwG03wegcAWa8uWgExM7uCRKZgkGVy9ugQ+304o9Q0o1QilRGAFAoFAIBAIBIIJUkIoBSgVhGXdAyCKdDphlZV9rHp74zI97kM8hJMhg1u2BDFnTisM47swze1CBgUCgUAgEAgEAtcwB4ZxPzyer6Oubv2AcBchhHlFBpuafLCsJij1dSi1S8igQCAQCAQCgUDgIugprIRS98HrfS68YUODJfzFdZgyBRMgg7W1JkpLG+H1fg2m+SiUKodSFqSNh0AgEAgEAoFA4DaKoVQ1PB4P5s8/V9/Xd+WlRMKSaXEHwrBvEr8KBAxUVa2C1/sYDONhKDUXLCgqZFAgEAgEAoFAIHAb9BRWwzAegd//tadXrVpsbdsmPEYI4fTgoaamxfB6H4FhPAalFkO6SwgEAoFAIBAIBLkmhSaUWgqlnkQw+DTi8UVWRYVwGRcgIaM3Aau+fh5CoSdgms9AqdVQSoRQIBAIBAKBQCCYGlKoAJRCqYUwjCEEAmdXXLw49E8yM0IIp4QMNjeXIxx+GB7P12AY66GUtOwQCAQCgUAgEAimlhQa10hhDbzegcZ589pf6OwclImZOMTDNR4yuGJFEQKB2+HxPHONDErjeYFAIBAIBALBDFN6rdFf+UcKfVCqAab5dfj9d1kbN1bKw5s4xMt1o3XR1BREKLQLpvlNKLURSgXzbuGOvWDs35F8R4FAIBAIBAJBtq5omvbLMGwdM5WyX+n0SL1zOnVLegpbYBhR+HwJq6HhDXXo0BV5oEII3eVaGzYE4PNtgGl+HUptg1KleUP+WG0J8HgyX3oRp9NAMslXImEvZOffCgQCgUAgEAhmIQPwAIEA4PcDwSBQVASUlPAVDPLzZBIYGgIGBoD+fv47FuP78Tj/nUqN1E+nlhT6oNRWGEYCRUVxq77+d+rYsSF5wEII3eFeq1d74fOtg2F8DcCdUKpkyoU8e4F5vVy4oRB/BgL24i0p4WL2+WxC2NsL9PXxNTAADA5yMUcimeRQIBAIBAKBQDDz4fUC4TAwdy6wcCFQXQ2UllKHnDOH/w6HqU+m09QZ+/ttfTIa5aunB7hwAejuBoaH+YpGbf1yKnVMwwgC2AFgGKWlMWv9+nfUwYNCCoUQTpKHAQYCgRUwzadhGA9AqbJrVY2mlggaBolfOMwFWlbGhVtdzYVbVMTPiov572CQC10vwqEh4OpVLuTBQeDSJeD0ab4uX+bCTqfFYygQCAQCgUAwk6EUHQrz5wMrV/K1aBH/Hw7TI5gdNqoU9cR0OjN0NJWiXnnxInXLnh7g/Hng3Dn+u7/f9h5OlY6pVBEM41Z4vUkoFWuvqflDTXt7Qh78OKdPpiAT+wG1YePG5fD7n4Zpfvtar0GV87ly5vn5fCSAFRVcrEuXkgSWldGiU1pqL1zDsBftjb6/vx/o7CQhPHwY+OwzLuZYzL62QCAQCAQCgWDmwDBI+pYtA5qagMZGYMkSvuf1Up+cqO6aSNAz2NsLdHTwdfIkCeKlS3Q+xOOZxDS3+nQPUqk3kUr9DWKxverAgbgIgBDCm5ejlpbF8Pkeu1ZEpuGa4Fo5mStnSKjXS09fZSVQUwOsWMHFumABiWFR0fiI33gwNEQrzv79QFsbcPw4Xf3iKRQIBAKBQCCYWSguBurqgK1bgeZmOhmCQbvuhFvQIabd3XQ4nDwJHD0KnDkDXLlCXTPXXkPq1pdhWa8ilfofGB7erw4eTIkQjA0JGXXKUHPzPPj998AwnrzWeD43xNnpDQwE6PnTJHDVKsZ0z5tHy42Rg84gRUW8TkkJwweSSeDUKS5igUAgEAgEAsHMgM9HvbKpCWhooL4ZzFHBfMOwU5qWLAHq64ENG0gMjx8HvvySeYf9/dQ9tS7sJvh9c2FZ90KpGLzeqLV+/RF18GBShEEI4Y052qpVxQgE7oBST0OpDTlrPG9ZmXHcy5czjnv5ci7SsjI7DzCXMAxef8MGuvqHh4GzZ23LjUAw1XC2SBGIDIg8CAQCweT31HCY3sG1axl1posPTgVKSuidXLwYWL+e0WlHjwKHDlHnzB0xVFCqCko9DJ9vGIbxI2vevOPq0iUhhUIIx+BoDQ1FKCq6DYbxNJRqhVLurxat2IRCXJCrVtFSs3IlvYFFRROP4Z4oTJNWo+ZmLswrV1iERpNWwcw+JK4no1O+AC0eCLrAkWXZSe0ih7MH6TRzUfQztyw7V1ogEAgEE9Pz5sxhPYoFC3IXeXYjfSMUyixo09BAUnj4MOta9PW5H0qqlAnDqIZlPQaPZxiLFv3UunTpCwWkRTBGEZXZPgF9S5d6/eXlO+HxPA/D2A3DcLfXoFayAwF6ADduBG67Ddi1C1i3Dqiq4mdTvUCdm4XHQyLY0cFFKYRwZpI/Z3WwRMLuUZlMjmw4O1X5pPp6Xi/Xgc/HyrpCAmYfDMPufeXz8SVewtm9bzlfAoHg5uHzMXRzwwZ66YLB6V1PhkFiWFUF1NbSKVFSwjFFoyxy6KYOyu8pBbAQphlFdXXHCx0dvSIYIzGrPYTW2rVehELrYRjPQaldUKrMdUXX52Nl0FWruCDXrKGVJhfJvBNFcbEdrnr+fGY1KEFhQzePNQy7j6WzQq1l8aVLSicSfKXTtrEgV4dHMskxNTUx0T0Q4HvFxcA//ANlUYwTMx+pFGWtvh64665MT/EbbwAnTti/I5g9MhGNZr7n9U5tqFshEefRdA+BQPevLi+nfuf358956vHYVfOXLKGD5OBBvs6fZ00Lt85/pQwYRh2UegZAwmptfVG1tZ0VARFCyD0TMBEMroHP9zUYxp3XYo3d+XKtTJeV0TW+fj1L/C5eTMtIvhBB58JcsIChq14vD2JRvgr3AEin7VYi2hJXXc2QkaoqbsBOr3QyyRzSK1dYFezCBf7s7eX7pum+IqYUv7u2FrjzTuD++zM//+EPOa58WysC9+VAGwbq6oCvfCVTsf30U+DYMVFyZ9XhbFEeqqoy349EWCFbjESZa8fZCFzPXa4KhggKUMv3MEy0qIj/zjd4vQwjrahgi7XVq4F9+0gMu7rcyC9U1/5eAVgLw3gaHk/Caml5Ue3bd0EEZJYTQisYNLB27TL4fE/BMB6EYVS5dpBpJXzJEqClha/aWrrE85lkFRUxzjwQYJKvoLCJYFWVXd1r0SJa4srKKId+/8i/TybZZHZggETw3DnG9h8+zN6Vw8O2ddEN5VwpjlVX13WuoaNHec10mgeYkIGZTwC0Bzv7/VjM9hgKZpdMfP/7lAm9Dxw9CvzmN/QYl5TIvpBOc34WL7b3SdPkXn3pEr2sYlAT6OgfZ0pIPsLrpWOirIw6y6JFwN69XO8DA+4YgpQyoFQTTDMJIGKtWfNP6siRHhGSWUwI0dBQA4/nEZjmY1CqBoDhyqIzTSreDQ3Ali10gc+bl59WmdEOYG1llEOk8MigthIvXEjZ27aNikJNzfiep8dDg4BOPq+vp2f79Gngo4+ADz4Aenrcy+dJpUgwly6l91IjkQDefZc/RQ5nFyEMBEbuqfG4TQgEs0ce+vpoVF240H6/upql6/fvZ5SDGIq4T956Kw3PPh/XyfnzwCuvcN8Oh2WeZvtaSqXsOgE6RSSfDWyBAPWCsjJg2TLqHgcPMnJJG7wnM37D8CKdXg/DeBalpXGrtfVV1dYmOYWzkRBara3V8Hjuu1ZRdDmUMie94LQQr1wJtLaycExtLb1uhWLZ1gqX3jhEGS8cMtjfz81z1y7gjjsYclGWlQ4bi9FqfPUqyaPOyQoGmbM3b15mmJHPRzI5fz7l+NAh4PJlXm+ynm6lGP5VXc01Ew7bn/X3Ax9+SPnTOY6CmS2/6bRdUCb7s0RCQgRnmzwoRUPA/v0MI9OGgvJynqtaqZW54jydOQM8+ijnB+Ac9fcz3DqREGPKbEcqxfM2lZo8mZoqmCbXfkkJ9YS6OmDPHuDzz2ksmjwpDABogVIJKBW1Ght/rT77bFgI4Wwigxs3VsDrvROm+SyUanCFDBoGvSoNDaweuno1BbnQNmFdbVIO2sLC1av0RD/6KLB7t60UaJw8yRysL7+k5binh4dDOk3SV1oKVFZSiVi5kvI7Z06mjHd3M4TTDTKoN/KhIRLYlSszD66ODo5ZF70RzIKN+ToeQsBuRyKYXTAMNrHetcuWCx1REA5LGLGGz8eIioceAjZtst9rbGQ7qffe4x4vmN2EsK+PZ24yaVdvLgR4vTRMaz2lqoqGovZ225A4cT2kCMAmGEYC4fCAtWHDu+qTT4aEEM4GnaOxsRg+3y3XPIMbodTkur9rhbqmhhUSt26lFSMUKswJ6usjuUgmpaBMoWzyqRQ9gk89xVxB5+Z46hTw1lv25jk8bCvXztBgw6DxIhBgqGhrK7BjB/P6PB4aCvbsYX6h1+vSYrwWxtLURAVPIx5nntDgIEmptByYHdDh9tkeQt2fUjyEs8s4oBtp69BQXVzG7+e+Vl6e2a9yVmtwHhbeOHiQlcw1+aupYcXet9+WOZrtSCZZF6C7m9FBhaijFhczhWXePHoM//AHGrkjkYmTQkYjlMCytkKpCLzepNXS8q7aty8mhHAmnzHr1wcRCu2EYXwVSm0HMPESXFpBDYepNO/cCWzezNA6txTm6cDgoO09koM2/xVopYAHHyQZXLbM/uzqVRLB3/6W+X865l6Tv2yyn07zwOjvB44cYZx+ezurfra2strop5+62yQ+laIXfcmSTE/6lStUAnWrCyGDs4cEmOZID6GuouhsQyGYHfD5GJXw4ouUDU0Uda67RA/YCAaZL7hpE5VmTZ4bG2nkGxgQI+9s1xf6+2k4GB5mOkkh6nh+PyOZwmHW6vjgA+CTT0h2J2M0VKoEwG6YZgxKRaxVq9rU8eNRIYQzUdcADASDm655BndDqeIJC45WSObO5ca7cydDRcvKCvuASiZJJAYHJX8w36Gfz5NPAo89RkOExpkzwM9/DrzzDj2+Hs+NjRT6WZsmD47eXuD99+3m4J9+Ssuim/0I02lasysq7PdiMVYTO37cJgbptN0XUSfE6zHrVhi57JN4M/uC9mY5x+ocr66iqXtA5gMJ030ntRfOGZqp59jjyf2YxwoZHW9lvOv9Ti5lw3nN0a6j5UH39dS/p73yPt/0y4Kz6ER2BIEeq2nasjuVa023pnHKpVJTN45smdLX1HmvzvXjzM9yzleun69l0eNz/DjQ1kaFWYf8z5nDkNtf/9p+ltOxTgTTj8FBO2Vk3jySq0KMvFCK+vfmzbyPOXMYFt3dPZkwcgNKlcE074ZhRDB3bsIKBvergwcTQghnFhlU2Lp1PUzzaSh1G5SaOykyaBgUwi1bgFtuYf5TKFT4m2l/P/DFF/TQyOGQ32TQ76fsPftsZq7fwYPAT38KfPwxlZTRWkvccFu8Rg6Hh9kHqKeH7Sfc9A7qipHNzdzYNa5e5TWvXuU4hoa4ttau5TqrrLTv6epVej+PHuW/3cptnMiekEgw1HXOHFZmXbaM/y4qosKfSNBCf/kyQ1zOnCH59Xqnx/BiWXblzooKjre2lqFmoZAdJtzfzyJE7e0cd18f7ycX49YhoxMlhLGYfU/Z8hwMupvPrZTdND2RyHy/uNguhJNMUr5XruQcl5Vx/mIxW34//5zzrIn3dBgCEwl7ndXWUiaKijimWIzPvauL50N7O5+Fzzd1suvxcC9whojq8OJctaTRRDQWyySBfj9lNB7n3JWXM0pIV0QMBu3ne+IEc7f7+7lmchU9pAvL9PUBb7zBHPAdO/hZIMC88nfeYW729fKyDYMyIF7EmYtYjGf56dOs3Dt3buHqeTqkfNUqrjm/nx7y8+e5FiZKCg2jHJZ1L9LpCAKBpFVVdUBdvJgSQjgTyOC8eQaWLFkJw3gGhnEPgOpJkUGPh2X8t20Dtm/nIT+aAlOI6OhgbsbgoJDBfN0A43HK244dwDe+kUkG9+8HfvxjEiqlJtdEXnuyrl4FDhywDSFuIRKhErV+feY9XLnC6qKxGJXSJ54gaayuprLlVFhiMXoyDx0CXnqJhGWqw8hiMc7N8uUk6KtXk7TOncvn5PFwPLp1wuAgrZjHjwO//z1/JpNTSwRiMc7h6tWMblizxu5PGQjYCqNzzFeuMHTv+HH2hDpzxq5Q6yZJvV7I6FiEMJ0mWdi2jRZjbWDQMptIMHy6rc09o8HQEBWq224j2dNjTyaB//gfuW4qKtgKYPNmhkWXllJxMQzbq9TbS4L11luU+6tXue6myvOVSHBM27dzrEuWcNyhkF10IpWiHAwM0Dhw7hxzdw4coCzlujiF9rJ/73tcZ5EI57q7G3jzTRqEctGAva8PuPde5uAND9uhyx9/zFD8cJg1A/Qa0vNmmvac9fTwXP3wQxKyrq7ctMq4ehV4/HFGKgWDzB3U8Hq5z/7lX/L62kuYrdcAwN/+LdMD3GorJMgvpNPcy8+fp8yUl2eGYhcifD4ase67j/0L33mHe4JesxPDfAAPwzCiqK2NWxcvHlbArKlqNnM9hEuX1sA0n4JhPHCt1+DEJERvmqtX2/1+FiyYnNKdT0ileNh3dk4uQVeQOzKoe/I1NADPPMO8EI22NuAnP6GH0M0qoFoZc1sehodZTGb58sw11NfH/MWvfY3Kdk0NS05f7yAoLiZZDIWozJw+PTGv6ET2g6EhegXuuYdKYU0NlbHrHUJ+P8e7YAFJxLp1fGYff8z5yDUptCx6tBYt4phvvZVzN5Yy7RxzfT3JzW23Ab/6FQnt0BD/3g0F93oho7qZslMms8lgczPw1a/yZyBgf1c8TvJy5sxIRXgySCbt/Kzdu22FqreX17/lFubfrls3eq6O18vfKy6mgbGhgd65l16iDOeaFOqc4QULSHruu+/6vXL1WEtKSILXrWNecVsb8PLLNBLo8MhceequXKEBadcue651esPeve4TQsMgAdakz+ezw2rr6ihT997LcP3a2pGeP+ecLV1KOdm4EfjlLxmKX1Hh7lzpddDSwjWd7SUPBvnZ9Sr1asPJ2bPAP/4j/y2ewpmpRwwO0tO/Zg1TTYqLZwCD8VDui4sZ2eD1Ms1leHhie75SCoZRA6UehVJxtLb+GG1tR2eLmMzIlW81N8+D1/sEPJ5noVTdpCqK+nxUXu+7jwdEoRePycaVK8DvfgccPkwlSg6D/CPsySQ38aefpuKrFcZYDPjrv6aHEHD32eXKUjwwAPzZnzHcQ483nea91NezfcbChXaOg9NDlD0ew2AFwo4Oei+i0dzKr85pvPVW4NvfBu68k9d3KvE6B8uZQ+gct8dDT1ZtLQlwZ2du83a1MtvczDHfey8JgHMP02PN9sbpcRsGn0dlJVuCHD5M45F+RpOVs6EhHup3351ZIj8WA/7pn7hHOcmnlpdVq4Dnn6fCqwm59qa/+y7w3/4bvUluhjwnElQ8mpsZJeIMKays5PyuW2f3oB1rXjXxXrWKFvuzZ+lZyqUMJ5Oc64ceYh5yRcVIr9H15Nc0qXitWEHDhg5Dy1WvO8PgfDQ2cm/QMuv18j5efdX9lA0dLlpczHO/qso2KJSX83r33cdn79y/rrdP6VYZNTV2CL6bc2WaXB9LltDgcz3dRK+N7Jf+jooKruvLl3NjCBTkhy4xPEyZnDfP9hLOBLIbCNjROTqyZaLho/ybUihVCcNQfzFv3vkXOjtnReP6GechtLZurYRh3APDeAZKrYBSE3fl+f3c+O+6i3mD2YdnoSOZZOz1oUN2OJkgvza6SIQE6c47GRrnJIOvvso8JJ0HlO9VGC2LYaJ1dZmKi1IkSMuWcX11dzP89dAhhjFZFudg82a+nApVKETv/Qcf8BBwg6Rcb+zxOENZH300s11GKsWQrI8/ptfkyhWurVCIXqCmJpKEcNj+m2XL6HFrbyfJykU+lFbuW1qA73yHnigndJuPvXs5joEBGsDmzOG4162jUlxUZP9+f7/7BFaHXWZHXWT3RdWhe8kk5/+551hZ0eklSiQYOvQ3f0Pl1m2Pm/Y+RiIch5Zjv5/PU99DPM4csk8+oedvcNAOcdq6lc9C77eGwVDwRAL4r/+V8pMLo2MqxTFs3UovplMeAcpAWxvH3dPDua+oIBnbsYNKpCYQ69aRvJeUsBJortoVmSa9Gp2d9pozTRKs4mL3Q950kZYLFxh14WwlZRjAI4/YnuxYjGP78EM+42iU89HYyL3aWfBr/Xoawv7yL2nAcmvMPh/X5Dvv0LCwfPnoId26sJEmgtl7TVUV9ZwvvqBsF8J5Irh5DA1xfS9eTAJVVTVz2voUF9Mbr/eIzz6beBqUUgaUWgngMfj9Eauh4Sfq0KF2IYSFRAabmkqg1C0AvgGgEUpNLMnPsqhkrFjBQ37LFlpTZhIZtCwesm1tVLql0W9+PiPL4ia3e7dNhBIJEqbXXqMSUgjhy5qcZBMjreh7PMxjff11ejx7euxiEgDDQLSycscdmd/r8fAw8PlyI8fOyq5PPUVyqtHRwfC5Dz9k2GskwjFrktPWxipo27fz752FdOrr+erocN/LomVn7Vp6Blevzryfw4eBV15hq5G+Piq3yaSdQ6rD3hYvJhnQIXtDQ7lpA6GrbmYTQmeom67mWFPDudy1K7OnVirFcNa/+zuSwVysC50vGI/zepq4OXN3P/yQcnziBJX1SIS/qxQJ4jvvUPl++GG70q7Px16id97J56J/323jUmsr9xKnHFoW19xPfsI1qNedZfH+3n+flSofeojj1gaCRYu4HgAWtMpFCFogQK/a+fP0gukzuLiYctDd7a5Cq8/+gQEaS86fJ9HS0MaHM2eYT/jRRxyDfsaGQQPLW2+RPG7bZs/X8uU0YvzkJ1zzbo3b66VcvfACDROlpfS233mn/TuXLzMk9OhRe2/Khi6ikyujmmD6DcypFPW9o0ft/OapSLWYKsyZw33U4+Fa3b/fLjw3gd0eSq2EYTyFoqKEtXHjT9T+/ReFEBaC7lxXF0IwuAOG8RyUaoVSfgAWbjZ3UFsI6+sZGrZpEw/PmeY9Gx6mwnLqFA8zQf4hmaQS4bQ2p1IMLXvtNSoruhBIIXgHDYM5d9kHUGcnlat//mcqLloxcYY1DQ7yvrOLmmjC4AxxcxOa/GzbxpDd6mr7s/37gf/1v0iuNJlyjtuyuM50P8iqKoabaaVy8WIqtR4PCYabc60UZeaBB2jY0op0JAL88Y/MaTpxIrMYj/6pK6f29VFxPXaMhLy5md4rN3PyNAxjJIFzVg7VZf6rq0mk7rprZIPl119ncaWLF3NnJNE5vdlVTS2LRoyf/xzYs4ceY53765TjaJTr9he/4GcPPURjI8Bz5q67WLTlxAl32yvE4yT4a9dS7pzjPn+eebjHjtlrS485lSKp7etjCO7Fi8yfq6zk39fU0Nv45Zcct5vznk5zrVy8yHW/fr2dV+z1Mox+z57r58dNxjiRTHLdHjmSSQgBRmW8/DLJoK6K7Fzzg4NcL729/Oz2221yu3Ur7+ellzin+m8nK5N6vKmU/QydhLCyknmjv/0tCWxp6ch50+tawkVnLgyDMnvsGAlhTQ3PCTfD6vOBFK5fTz3D57PX6cTWlg+GUQ+P52mY5pC1Y8cv1J49MzZ8dEasfGvTpgCqqjbB49G9BsNQSt00GUynuWmvWsVNfMsWbqSeGRZZq0Pc9u5lQZmZEjIwk6A9Rrt2sfCEhlboDx0qnJ6R2jtYVmYXatA4cgT4z/8Z+NGPbE+ZJrlOcqUPLO2Z+d82vGvl8YeH3Z8Pnb9ZX882H1VV9mfvvQf89/9Oy7xupZE9ZqXskMWLF3kIDw5mEteKCh5gbheaCAS4f+3endnX8eOPmZfn9BSMlluk+88BJDp/+APwgx9Q0dWeI7c9hNlhkvF4Zo/Hqip6Ph54YKSX+dVX6QHp6Mjtfq0JYSyWKYfRKMfwq1+RYI0lEx4PSdZrr9nzqb+7upoWbrcJbSJBElBXl+kdHB6mV1VX6h1NHkyTr+Fhei81qdCoq2MxqFDIfXLm9dJjefo0jUVOeWlspNI33l6VN6s4X7zI/SlbJg8coJJ56dLoe5VeO6dPc64OHbL/vrSUhYfWrLH3FzfOXv2c/H7K5pdfcnzOebz7bpIALZv6ueqXG+RUkP9QirLx2WcME59p+q1SNBw1NDCne/t2u8DXRPYJpYIwjHUwjG/Asu63Nm0qF0KYr7omSV8TgK9CqbugVOk1MnjzSqvXS2v67bczV6miYmbm1UWjVET27uUBJxbB/NvQ+vtJRHbuzCQikQj7TRVSixCtONfXMw/IKW8nTzJXJxa7vkKiDRZeLz0G2cpyVxfny205TqVIPB56iGPXe8Hp0yzEdOjQ+PryaQ/uhQu8TydKS3kNZ8+zyZJB02RY65YtmcTp6FHKztGj4/fyaUUzHqfHQ4/fzRA9TZKyFZNEwlaa586lx+PhhzPblQAMZ3zxRdtjnstCloAOAAAgAElEQVR1oUNGswmhlhddqXmsMej7vXCBBoWuLvuzQIDW7epq97zemviXlTHU0vnck0m7SNBYhaR0KGFPDz2xhw/b5M/joRF12zb3c2F1K4czZzhfTkKoW73kIjrANOnBO38+832fj/fq8YxdxEqvr4MHSSCde0FNDcPetSy5HRrs8/E5vfnmSOPTihWUAR2SPFqRGcHMhpa7Y8eAt9+mnLudApAPOlQoxOJXd9/NSD8duj2x7wuCaWjfgsdzh7VxY/FMFI3CZwIbNzbA630KhnE3lKqc0KamlZLly+0w0ZlKBgEecr//PQ8NQX4ikaAlecWKTIXz6FFarQvl8Na95Hw+hhw6lf5olHmBuhjMjYiOz5fp3QCY63P2LL0XbnqttIe2qYnESo87mbRzh3R4ViJx/Zf2aCYS9F6VlmY+O933beINdTP3sXSaJFAXhHHez6efkoBPpI+g00vr+ilkjP7dsZjt2brjDhJzXdhE4403SAbPnHGXqN5InrM91doqPd7wbf17x44xbN9JdBYvtlvLuOVxU8rOF9LfmUpRJoeHxzd3lsW/v3CBeZJffml/VlTEaIa5c90naKbJcXZ2Zr5XU2MXUclFzmU6TU9KNincuJFhdje6R4+HZ+ynn2Z+h9fL2gS6BYXb0QF6P9mzh+vd+f3r19Mop3OzBbMThkEj6t69NBxEozPPIKCrj65YQWNiU9Pk8pwNI3QtHe15eDy7rKamGUcKC5YQWoCyWluXwe9/HIbxAAxjEZQyJrw4FiyghXPrVnpkZqrXrKODuVqffy4WwXwmg4sWMd/HmSfV0UEiX0iyqXPwKitHVrk8doyEcDwVCpWiZ8jZeBmgMt3R4W6VQ52TM2cOFTcnCe3u5jUTCd5TcTGJwFiv0lLbE5gd6hiN8uWGUqjneu5czvXcufYaP32a861znvLt4B5tTJEID3RNBrOf/VtvsZjJ2bP2Pj4V0M3Hk8nMMyQcvjkZNAySnPZ2O4fUMChXdXXuWu11GHEwaM9TOk3Zu5kK09q7cPQo5Ska5fs+HxUu3U7G7XDi7u7MMFWAa6+xkfeT7a1167p9fQyzdhIorS8UFY1N2LWh49QpfodTXjweu4JvLnIgleK6ePvtkYRQ51e5mbcsKDyYJs+D115joSu9lmciKayvZ/rEsmV28bkJfBsMIwzT3A2P55sIBrdZmzcHZ9J0FW7w8IYN8+HxPAbDeARKLZ0wubUsKms7dtgNm2cqenp4QLz1Fg+nQqhOORsRi7GBuLNseTzOlgaffEIlohDCO3TOn9dLgrJkSaYR4vBhVhAcq8S+UpwPv58kOZsUfPopFUU3Q550AZz58xk67kRlJfBv/+3EPBLZoYTJJA/koaHJk1ldAMTjoRdNt/DQOHGCCqIbnki3cT0PYSpFL/ntt2cWQkkk6KH68Y95T1PZN83pIXQq+Epl9h4cr0LW28uQ0eFhez/Wsq6Lm7gxZk1inR56w7ALGo03j1x7ijs7uR81N9tVd8vK6Jnev5+eezflIxLhPDm926ZJEurzcQ25SaB1ConOGdyyJXPvWbmS4aCXL18/B8uyqIz29nJOmpszvfabNnH/6+x03/tuGJyTt99myxmNBQto9P78c1aqnjfPfUIqKAzoKIX2dha5CgZ53gWDM+9eAwHqIBcv0jN67txkogpCMIxbAcSRTMat8vI96sqVGeFyL0g3mLVx4xwEg4/A630ShrECSnkmJShr1pAQOsvJzzQMDbFZ85tvMkRPyGB+Ip2m5Xv7druiHkDioMvYF0oosyaEwSCVkOxwjePHSebGChdVyu7vtWaNXZFR49AhzombifHam7J48cjrmSYV/5IS3s/NvLJzGKJRKpRDQ5Nfj05CWFU1MrT23Dmu+3wrIKXJ3GhGgfp6lul3VnlMJKiI//3f0+s51fczFiEMhWw5HA8x0bLd22uHber35893txehzkt2egEMg3LpDCMdryI5PEyZcuY/GgbDs3SRJLeJhq426kRt7eQKRtyIEFoWPXy6CJPGmjUMvbSssb2THg8/P3WKxjwnNm60G9y7Qfyzn1E6zbDeM2cyx97SQnKanc8smH3Q0TBffsnK021tM89TqI1YlZU0IK1ZY+8ZE/0+pcpgGHfC43kGdXWbrGXLZoRCXVCE0Fq7VlktLeXw+e6GUs8AWDPhXoP6wVZUUFldunTmVVtyKp4ffshww9OnJVQ0bwX8mnKxYgU9BE6S0NNje0MK7X7Ky0d62rq7aZkcqzCDRixGS3ZTU+bvptOck2jUXQ+RrojqbD6fC/T3U8mNRNwpxpFMUrlfuHAk+b540V2vjZsyMlpBGYCku7Iy02CgZSoWmz7PxvVyCEOhm/P0aCLQ18ciUc7vKiuz79uNNa/LzTtbDClFOSkr472M9zqafF24wHBt5/s1NbZh1c28Pp+Pe8aJE5njNE16vW6W1I53zgyDhL2tLfO6tbVULIuLx95/tDJ66RI9ck4sWUJSGA6TYLvt5dbK/u9+lylfgQA9nJWV7hNRQWESJoBGj1/+knI6E0mhz8czfcMGrt+Jh44CSikoNRemeR98vmdRWdkohHDqEYTHsxWm+TwMoxlKhSashKTTtNi3tjKmPju3Z6YgmWT+wmuv0SMjZDC/CZTfT0LozB1MJqlQdHdn9o0rhPsJBqkgOr2dAMOwurvH7+2sqWFelRNnzlBZc3NOtJI/b95IQqi9OTqfqadnYq/ubn6XrpyoPXuTVfxTKcpPZeXIeR0acr+ioVvkarQehGMRg/Xr2QYkFwVMxot4PDOvTCnK+s08R+3djMdHKmChkN0uxA14PPQQDw2NvM7ChTdHCJ0E05nXp/N8dQN5N/P6/H4aUE6eJIF2YsUKnuW5yCM0DD6bgwcz3y8tZVn7hQtHzulo3zE4SGOsE14vQ1EXLHDfW6dlKxBgm6LjxzPldfFiktGbfe6CmUsK02mGEv/852xJMRPloqiIYe2bN3MNTCbaimfpAih1Pzyer1utrU1WOFzQxUcKxiVmrVgRRFHRJpjm81BqM4DJBTp7PPTC3HorN+SZWkSmrY29sY4ccbfwhsD9A1w3Yl68mAYKrbx7PLQgX7hQWHKaTNIDn93YubeXhHBwcHzVRYuLR1aXjMcZgqXL/LuFVIqKWlXVyHzi3/6WPfy6uibfs0uHeLq9Jn2+0ctr56JXm1tyb5pjh0fqYjl6vgMBFvu5epV5hH19U9dYWV8jkRgZMhoI3Fzor7537XF0fpfHw71Ae+Mme2+mSQ+xs5effl9Hx9wsIdT9P7O/r7rabsvgRiinrpypjSidnZmtR9as4TnX35+bEOJkktEMg4OZhq36epLRd98dn8x0d3Pfa27OJGZLl9Jom4teij4fz4133uF1Kir42aJFrAp78iT3YzeND4LCRTrNfNeyMr6cVc5nAgyDZ3tLCw1kOkpn4nuGglKLYBgPwu+PYN26H+Kjj44X7PQUhK68bp0f5eVN8HqfhmHcfq3X4MTHrkNybrmF1gI3czXySdE6fRp46SUW79B93gT5Cb0hRaNUNLKV+kgkM9wr36Gt9YsX05LuxIkTrFCYSHDtjRW2kUzSO+gs6GBZ9LQdPGiHHLoVVqfDLquq6AVwoqODJCQa5bMYHp74a2iIa9LNIhi6V2M2KYlG7Sbp+VZAQj+/6xGpCxeooJw5kzl2n4+VR3WT+qkso29ZoxNCv5/jGi8Jcjavd36XZdly6FZunPZEdnVletg8HhKFsjL72jdjwMr2bOqKwn6/u95bTZw7OzPbdACMHFi4kPOYSLjffgLgmt2/P5O4l5by2vpebyTjsRjw3ntUQp1YtIhG6Vx4OPX433mHe5dGSQmJ6YYNNBRI5JDAKTN799KRkN22ZKbc34IF9JCvWTM5YwgNlQpKLYRSj8AwnrOamxdbS5cWpLKd94O2AIVAYBVM80kYxkNQqmxCjeedCmYwyApfu3bNTI+ZZdEa+dJLtEjqpsOC/IZpMoSrtDSTvA8MUBkqL3efFOZis9eVQYNB24ruxL59tMrpex5LYQZYmc8ZvqmLNJw6ZefouHUfqRTHXVo60lCkn4m+5mRfbhtoTNMuYpFNCEtLSVbc7tc2WTkZK2S0rw/4x38E/s2/AX72M4ZNOxEKAU88wSqk4fDUldFXyu4x6YTPd3MewnSaMhYOj8yT7O3NlDm3iMG5c/R2OWW6upo5ZTdjMEgmqUh5vZn5aVoOfT535Vu3JuntZasaJ+bP5x4RDLpPCPUcGQZ7j+rnolFWRmPVWGROF6gBeB7rXqAaq1cziiKVyo3BRinuldn9FGtr2dIlF0RUULjwemkA+f3vgb/9W8r9TMs11bn2q1Yx+miye5VSXii1FKb5BAKBJ1FVVWNt3lxwpDD/B9zauhJ+/xPX2ktUXdvsJ7bjp9M8rObPp8t4zpyZR5SSSXpg/u7v2F4ikRDPYKGQeF0g4dKlkYe0JjxuVIfVlntNTNwmhUrxQJk3j/le2ZU6DxwYX6sFXaF01Sq7UbcmbYcP00voJrHSc6ILl2SPTxfLyMfDUZOLZJJhgdmFN+bO5ef5pvzpcY8WOvzKK+yZevEiPSuvvDLSIzV3LvD446zKGwxODSkcixAGAuM/U7S86X6Vzve7umxDnlvy7fUyauToUdujqvP+WlvHX5hFezS9Xt5vdo++y5ftMGA39xbDoHEsOxcvFKLhqbg4d7l4fj/3nC+/zHzu1dWMMrpRSLbea7u6GB7qXIfLlrGfYjicm8qfWh737Mk0Bng83FuXLJE8QsHItRaJkAz+6EcMyZ5p91dRYRusb5S6Mn5SWAeP5+tQ6kEMDc0TQugS3geUtX79Evh8D8MwvgLTXDqpMFHn4bF4sW1RnGlk8PhxNmt++227cpl4B/Mf6bQdQqlzhzTCYSq+zqbSk1Fw4nFatr/5TYZN3ChscyJIJOxKfNkk7/x5Kj5jyaUubb9gAZUWZ85QMsn+g2731LMsKvWRyOj5jbW17lQzzJVXVs/Z5cuZ81JczHkMBic29lwWbtFtJ0YzdPT0kAD6fCQCb74JvPjiyN9buhR49FGSGk2Kp2KvzSaEHs/NVQbVZLiqimGWzjnp6WFooVvrUhes6upiPrkzl9DvB+677+aK9GiDSUlJZgEswG5v4rYhUhd4yfYUA1TsclU1U+d0XrzIYhvOvMmqKhq9iopubIzQkRN79mSOs6KCFZSXLOG+4/a8WRafU1ubnXetUVREL6Hb5F0wM0hTOk0Hw89+RtmZSdVHvV4ampubeT66ES1IjrICpvk8iosfsDZunC+E0AVsW7euEqHQg1DqCShV74rCrctib9s2ssH1TMCXXzJM9N13cxM6I8gN9HPSFd+yNyalmKuydi2Vjokq9TpccPNm4N/9O+Cxx+xiQ263bQgEqODoIgZaid63z85hupF8xmIjw0X195w6lbsedLHY6KG5ZWV8BoGAXTDjZkmVDjfNFbkaGhqZowRwHuvqbs6LpsesG8fnQu51Ht1oFlo9Tk12L11iYZ9f/3rk7zY0AF/5Cn/mogde9rhH8xDqwjLjWUt6fEuX8uW8/2TS9hC6KePa2HH4MImNc47mzAEefpjRMzfyIicSvM+qqtH7eQ0N2c3u3Z53y2IuXHZvvaoqvnSzbbeva5q877a2zKqipaU0etXW8v2xnpUuJPXFFyOL8axeTVKYK4U7GGQayfvvZ/ZyLCoC7rrLLvwl4aMCJ0yTMrFvH/Dv/z3wm9+MrPJbyIS3qIiRPzU1bhVWUjAMP5Rqhml+HX7/7VZzc4UQwsnoNevWlSAcvg+m+TQMowFKTV4b0ZXKqqsZojGTeg7G48AHHzBM9A9/yL/CEYIbK946/+vUqdGf37x5zJXavJlW5BuFKGmlWCuUqRSt6P/6XwN/9VcMc/riC+YUuS0v8Ti98EuWZL4/MECFZDzeAx3eXVeX2WQ9nWbIWHd37izaStGDcuxY5vuLFtGYtHSpXcDiRs/V+ZwCAT7D558nAbiRl3Qi447HGRaWXXhj7VrKzvz5HNNYz1yPO52md/quu4BvfSs3IafjJYQ6NLijg6GjH3wwciwtLQwfXbmSpCpX8qFbKsRiI8cQCNzYy6bnt6SERT0aGuz7T6XoQT9xwn2jnm4D09VFo2F2T7+nn2bV7ZKS67cj0IalYJBGhpUrbe+uZfH59PXl7gzSoWyHD4/0Bs6dy7Hn6tpKsSy/kxCaJve59etvTOb0sxwcZIEaZ3hocTGJZSiUm/HrPMi2NuDQIft9HTb62GPcs3Xl49HWqXgQZycMg3v/pUvAf/gPDHnWFX0LHT4fz8QVK7gG3TGMKxiGCcNogWE8D7//DquxcU5B8P+8042bmkoQCt0Gr/ebMIzWCfcaHG0zrqhgiNzmze7EDOcDhoaoZP/iF7TiaEVaUJjQlQrXrs0Mo/N4uGGVllKRuHTJPridh7UmgFoB8PtZQOnP/oxEZPVqysfly8CrrzIMJBRyV/GMRnnNW26xyVwqRQ/2iy9SYfR4xr5mMsn7feihzP6Dg4OsmPfBByNDa90kVT4fr+v0TipFg1JREcPinKQ02yulx6WrLt5+O/C97wFPPkmv7N69vEc3DVOmSdlIJnnALVuW+XlNDQ/2zk4Wx9Ael2wFVBPBTZuAP/1TEoXOTvYzS6XcLXQSiVBGNm0a2WfyzTdpsNAGBO1R7Ovj3C9bRg+VHo8uKV5URFm7etX9vVApyndxMY0qK1dmXuPqVY55eNgmhnp+9Tq1LJtoP/KInZuqSfCnnzL/u7/f/ZB/3Q6it5d7w8qVmZbxjRv5O7rNgpZt58vn4+89/DD3KSdZPHOG6/PChdyEjeo5LC/ntZ17QHs7n3suwi71s+/q4lp2GrtCIa6LV16hXNyIECYSdm60s5JxXx/zOwcHcxP5YJq8hmVR5ubPt2VCR3N89hmvr3OpnUZFXRFXiOHshDbMvf0299/58ykzhRyJpsceidAQd/Wqm2HnXgDzoVQxvN6+v5g3r/2Fzs54Pk9HXjEHq6nJh2BwGzye78AwdsIwil07RAyDFs2tW6lIzATS1NUFvP468PLLtPbmMhxNMAULwNGLcNkyKj1OxUaHaa1cSaJSVGSXY9fWrvJy/u2mTbT6/smfAPfey/c0wUylaOn+5S9pUHCjUI2TyPl8bAewebNdXS8Wo+Hi7bdt5WQsRCJU+O65JzPstKuLvQAvXMiNUUeTpHicY9RW+/+9xV/LO1i7lkqUHoNWnPx+EpwVK1jF+Kmn2ET91luphCUSDHk8eXJ88zARxGJU+puaMtuX+P0MbVu9mmNMJu3DT7faWLcOuP9+4LnngAcfpNzoULlPPnFXydfFh6qqKK/ZocG/+x09Tprs6Z/pNBWSgQEq1c6CLF4vFRW/n3vi8HBmD0O3DAahEGWjvt6WcaV4xmzbxucfDmcSQm2Nbm2lXNx/v62Uaxk6e5b7+dGjtlEnF8QgGuVa0h4uTQoNgzKwYQPJdjLJ56/z0OrqOO7HH6ccOed1cJCex/ff57znsjek18v5r6zMbA1x5gz3BjefufPZ9/dzvvT+69y733hjfNfUhpClS2lg0vKTTjN39IsvbJ0lF/vb5cs8A7RXRL9fW8vnru8zkbBldssW5ulWVNgtg2ZSlJVgfDAMPvdPPqFRaf587t+FSgq18TyZpNHzwgX3CjtxD/JCqQVQKgyg5y9KSs690N2dt3HZebOirYYGP3y+Jng8z0Op7dcm0N1DsKqKm7mbCvB0IJWiQvTTn7L63pUr7lajE0zf5pRIUJFta6O8VmSFnxcVUQleuJCKZzxuh8fp0I5gkAprKDS67HR00EN17pz7hZUiERLW+vrM68diDFWKRsdH5FIpEhpnhdJkkmM/cSK3Hn6Ph/fx2Wf01Dz2WKbyEwhQMa6uBnbv5j1lPwO/n4Qg+xnEYnaYbi6s7brtxOHD9Fg8+2ym4hoOs6Lh8uUkfPG47fXTVTKLi0e2QbhyJTehbDqi4Xoho6PNjz7A33+f6+OppxhSrVFcTC9Ofz8jJ3RFWzeUFmcItl57Tvh8dl+5rVtJUpx5v16v3Vomu61JTw/38/37+f256o+rlbrubpJP06ThRecD6pzlRYtI/iIRO8/Y5yMxDIczz5tkkkaO996jlT1Xxcx0TtOlS7xefb09jupqkqzDhznmXOwRwSD3sa1baVTR1/b7ua4OHx4771NXLO3p4R7f0GDvweXlNBbs28ew+OxetG7A7+d6eO89rpNnnsksaLRqFfDnf05lf3jY3qd0K56tW7knXro0c6KsBDeP8nIWRzp1iq1/Hn10dH2jUBAMcj2HQjQ0utmeSaliKLUbXm8Mc+ZErMbGPeqzzxL5OA15QQithgYfQqE18HqfgVJ3Qqm5k+o1OBqKipg4X+iVRYeG6N357W8ZNheJiFdwJhFCw6BC9eabPHB37aIVzql8KcXDvHicDvREgq/Ll6ls/OEP9EDcKGxzIkgm6WFYsCDz/eFhyu14ZDWV4nrNblkRjVJRunyZCmkun4NSVHp+8xvO0x13ZOYYGAbHMN5x6CbeFy7YPRhzZcBRivvE737H+X744Uxv82itDsZ6FgMDucvZ1LndoykTmmyNJqPay/Lmm1RU7703U7EtL6eXur+fv6PDCN2Qd00Io9HMPFLdUF6H15WV2Q3fb4SLF9li41e/4li93txa3fVcaMNiTw/JX02NbTDVXuPx7C+nTwN///ckabnybDr3yMFB7if3329/VllJr1dFBb1sE62qO5YxIBSiF/foUV5LVz8Oh0mWTp26sazpKISPP2YhJL1XBgIkuC0tvLdcEEKdRzo0RB2ir4/RAIsW2QYIvz/Tc+1EKMT9/aOP3A0fFxQeiop4Fv/gBwxz/853aEgqJJlwtpUpLbWjrtzNlbegVDmUuh2WFUUwGLPmzduvLl2K5dt0TDuT6ALM8MKFdfB6vwrTfBJKVbtKBnXIzrx53Mh0KE+hIZ2m0vDuu2zWfOAAD2IhgzOPFKbTVMIvX6ZnRjevdipzY8m7LngRidiW6FdeYf7e22/TQ5ULQqILhNx1l52/FotR+Th4kKGSOg9lrPEnk/SAPvgg73toiN/d0UH5//zz3Fsjnflq7e2cx6Iiu8/cjTzyqRTXZyzG7zhxgiFlL7/M78tFSFu2wjk0xGetrfmhkK2oXm/suv1JLMZ7/uQTPrePP+Z7bnp+lKLyXFvLkNGSEhoOYjGO47XXOIbR5kq/NzzM+wuFbA9XJEKvnNdLgnPlCvdO3aZkMuNXyu7Bpyv/OhX3I0eYi6KLRI21znSl0iNHGAb9+utc87kmg9lzGImQQJ08yf+Hw3YbguudL7r4iK5c+bOf0aOeTOY2VDRbTnfu5Dh1QZd4nKTs+HEacNw2YpgmrxEIULbKymwvsGHwul1dNybFSjFEbds27nW6MqvHw7n/9a8pV7mYR2fV1LNn6dUMhUhudfGmsa6rQ3Nz6QkWFAb0/nDmDM+IhQtpjCsU77HeA3X14tOneeZow55LV7l2nRCA+QCKUFJy7i8qKrpfuHgxrypATutKPmsYxuKNG5fB630ChvEtGIbuNeg+IdSVtG65pfC8hDoc5/XXM0NEBTMXekOqqKD1traWYX6LFtG4UVycKQOWxQO+r49eqLNn7Xyajg475O9GhGwy0NUH166ltU2HA8bjlN/29vGFwaVS9EysWmVXtjRNbtjHjpFETFX+iq62WVrKcLTly0l2Fy/mGJ0FebTyOThIxb69nc/g7FkSkosXSfSn6rDUxgHdAmTVKhrEamtHjl0r093dHO+pUzwc29upuOrD023EYgzVqavLrBDp8TCs+UYFNnRI24IFfCa6H5xWyJNJ3k9Xl3t9K2Mxzul99zHkTheFSadtL59eB/X1JA7ZjecHBjjHn3/O16lTXLt+//Ts7bqqaHk5ZWT1av5cssT2gulxRaOUiVOnuB6PHrWL/0yVgVKvtZ077dBrnd+p5TdXRiPt1V69mnIXidiGgtOnaRAYj5d0eJjh9YsW8fu0LMfjJNlT4Wlx5q03NTGHsL7e7lvqvOeBAYaSnjxJ49axY7kNbRYUDrQh1zQZmfH445le53wf+/AwQ8F/9Sv+1AW13L9WGpbViXT6RcTj/xOJxDF18GDehI9OK6uwNmyoQSDwFZjmn8A0G3MSkqQPipUrGed8222Fk0Ook8z372fY04EDEqYxm5BO28SwuJiKc1mZ7anSngRNBqNRhsj19lJuBgYyS/bnWtHUoXSJhK3YOxuP34zcOotZ6HGb5tR5T0Y77AB6TyoqqDiHw7wvr9duRZBI8HBxPgddYGOqnsNopFArfRUVlCOdJ6jnM52mYqvDQy9fptdC55vlas/RpC07X9Cyxt/TTz+f0arD6fBNN71WugrtHXcw3K621h7Hu+8C/+W/kEiXl1Ox1mtWr4FolK/ubhprBgbsec4HpQ7geCsrKSvhMGXF2W6jv5+e2e5u23M8Hd6i0fqFer1T02hd55A679nj4XMez7V1zvhoLVL0fE/lWROL0fC1YAGffThsr/1kkvvY4CDl9coVu/2RGKcF2XJUVcX89e3b3Wv6nssxDw0x7PW11+gxzxUh5D5rwbLOI5X6ByST/4ChoS/U558n82Eqpu0EshobK+Dz3QvTfD5nZHA0xSMaLQxCGInQ8vrOO4zX7+zMbW6GIP+gC5RYFjco3XDc2efMSZicoYxK2cr+VB3YeiyjWQVvdgyaPGV/x3QoH5pU6DDMwUF6ArL3LE3Onc/BMOww02kx+SmbjMbj9Bi3t4/eK0+P0dmyZCpC/5QafU8e717nJH3X+9ztfo/pNOczuzl9MEiy7fHQo93fP3pbGP2aLiPH9e5L7zeRCL3bp0+PzMNzjl8T2ekav+77ONo6zDW83tFJ/HivbVnXN7ZM9XzqfSoSoQfwxInR78e5r0m4qOB6cnTlCvDXfwiS+eQAAAu6SURBVE0D2aOPslhSSUn+yovOCXcWAMvlPgsshGk+BSCOoqKfWvPnn1JdXdMePjothNBqagqhuHg3DOPbUGpDTjdvZ5+RSCT/e+jEYiR/e/YwPPT0aQrqVORlCPIP2crXWEqHU/GdTgLiVuGOfJJ35zNw9mQba8/Jl3twelidbSPGkqGpHLcb15vKMTtbk4xGCDWR1kT8erKSr5WhnVEFY409H+R7Osfg1rXzRQayn/toe0S+7W2C/Nw/tIFu/36GFu/cyZoAK1eOr5jZlJERy46iiUSof6empCuEAaWWXaubMoglS17+H319Z74biUwrKZweD2FJySYo9V0o1TJlAppI2BZbZzPYfEEiwfCbTz+lV/Dzz22PkBSOEcgBLM9C5Ci/FIlYLLPKKEAyqHNENfku1EbeIiuyvwkEk5GjUIj75BtvMOVp1y4Sw0WL8qNNhU63GRpiKHQkknsPoS4yQ6yCUs/ANBPfaWh4+bt7956fVYTQ2rGjBUr9Kyh1K6aqymk6zfj3vj6Ge+kiFfmAVIq5RkeO0Cv4ySfMzdDKhGzMAoFAkD/QuXSjeQj9frvJe6ESQYFAIHCLcOmCSd3drKb83nssOrN2LQuBVVRMn5dc5w92drLomyaEY/USdZc0mzCMBgBfhceTsFpaXlH79nXOCkJo7dpVDeD7UOo2AFObyBeN8oGfO8cqjdkNv6cauqLfyZO0nOzbx+poutKYeAUFAoEgfxWdeJzWbyd8PiGEAoFA4NwrdZ54Ok2Hxw9+wF6Xra0sPFNfzwJWU11IKR5nvuOZM+QG01EoSSkvDGMDgDi83pi1YcOv1SefXJ7RhNDauXMxgP8LwAMApr5JSTxOK8Dx4xTEUGh62k/EYiyBfuIE+8MdOMD/a+VhuivNCQQCgWCsA5w/dR9B5/teL88VZ4EhIYYCgUBgF52xLBKwri7gj38kMdy5ky2dysr4yhU51WQwFqNT5swZtqnp7Jy+OiNK+WAYLQBSCARi1rp1r6rDhwdmJCG0du+ugGV9B8A3oVTxtAhiKsUS8CdPsiRuURH7Q01FJb1kkvmAFy9S8A4cYIhoezuF0ucTIigQCASFhERiZA6h12v3dxQiKBAIBKMRIBaXSaXY4uj3v6eDZP58oLERuP126ujZ/TDdIIK6gIzmA599xp9Xr47eumjq5iQEw2iBZUVQVBSxmpv/WR040D+jCKG1c2cZLOsRKPWnAOZMm/BZFsNGz59nnp4uHb5gAQXPbVd1Om03qO7qIgE8doxVQ69cIRH0eHhtURwEAoGgcJQZYPTeh6GQXV49nZa5EggEguvpyLrHsu653dkJfPEFW62VlgI7dgDNzeyJGQoBc+bcfNs4rV/rXs1Xr1IvP3eOrd2OH2cYa3b4//ScLcUwjG3weJJQKmo1NLyrDh0amhGE0LrllmKk049AqX8JoHLaD/F0moVljh9nqE80ysTWqiq6qIPByRFD3Rh8cJCk74svbE/ghQtMXk0maUV2VqITCAQCQWGRwmiUSszAAPd9pezG7VIQTCAQCMZHDAESvlCIe+ipU9xHjx8Hli5lmGllJdDSAjQ08Pd0H0+vlzU3/H67B7Izxzsa5WtoiK/2djpmdMiqdtDkz9kyB4axE0AMoVDUamr6SH366fCUXDpXX3x+40ajpqjoIQAvQKnGvJlsndcRCgELFwK1tcDy5cCKFUxqDQRogdBhnNkNj1MpkjpdYS6R4P+HhihkJ08yNPTyZVo7env5OzqpVkKJBAKBoPCVGK8XqK5mCfWhIduYeOkS0NHBs8Ljkf1eIBAIbo4U8ZVM0sGSSFB/rq5mZVIdll9SQqJYVcXPiottUhiJUP/u7uae3NvLfbqnhyRwYIBEMT8jOSxY1hWkUr9GOv1DDA62qUOHogVJCI/ecYdZn0jcBsv6l1Dq7vyb6msHtGEwZLOqiqGjFRX0FFZU8DVnDl3VPp/dd2pggILV08PX1asUvP5+WhsuXWKLC93c0uPJz+bDAoFAIJjcOTI8zJduQA/QqFhUJMY/gUAgcIscah08EiFR1AVqwmG7EI3fz/e11zCRoG6uI/ciEermhlEIPWLTSKcvw7JeRjz+Q1y48Klqb48XHCG0du26BUr93wDuwVS3l7hZUqhhmhSu4mLGLhcXU9ACAQpOOk1rwvAwBauvj0I2PEyh0/HQSkm4kEAgEMwmZSX7bBEiKBAIBLnZc517rY7aSyaph+vWbX5/ZrHG0XTyQtDTLasDqdQvkEz+BL29n6kTJxK5upTrOYTWzp2rAHwPwH2Yhsb3Ny1U+uBOpWxrb1fX9cnjaA0rtbVBSKBAIBDMHgj5EwgEgqndc50wTduhM9beXLj6+UIYxiPweuOoqEgcAg43ADmJc3V1hqxdu5ZDqe8D+CqAshkhbOOxUggEAoFAIBAIBAKBu7zEgmWdQDr9cyQSP0vu3XvMC7huiTRdG+/OnWVQ6v+FUk8BqCjYidchQDd6CQQCgUAgEAgEAkHueImCZZUBmAvDsIwFCy680NFxxe3LuFLtxNq6NQzD+DaUegLAXHl6AoFAIBAIBAKBQDBpUmhCqXoo9Rg8nkes9esX5h0htHbtCsPn+yqA7wKYJ09NIBAIBAKBQCAQCFwhhIBheGEYq2EYTyAYfNRqbJyfN4TQ2rnTB8u6F8D/A6AOOexrKBAIBAKBQCAQCASzlBj6YRjr4PE8jXD4fmvjRteiMidMCJObNnkA7IJSfw5guZBBgUAgEAgEAoFAIMgZKQzBMJpgGF+Hz3e3tWZN+bQRwgubNxtmILADSn0fSm2RpyMQCAQCgUAgEAgEOUcRgA0wza+htPRWa/360sl+4YT6BC7w+5ug1PcA3A2XCtMIBAKBQCAQCAQCgeAGMM0QLGs7lIoiEIhYq1f/UR09OjBlhNDasWMVgO8AeEDIoEAgEAgEAoFAIBBMKQwoFYZl7YJhRFFcnLKWL9+jTp0ayjkhtHbtWgLg/4BST4LuSoFAIBAIBAKBQCAQTDWUKoNp3g6loqisjFuBwIfq88+jOSOE1u7dIVjWn0Cpx1HIjecFAoFAIBAIBAKBoPAJIQDMhVJ3wzTjKC6OWzU1H6n29pTrhNC69dYipFLfgVLPAKiW2RcIBAKBQCAQCASCPCCFhlGFdJqksLo6bnV371fRaHq8XzG+HMBk8lko9X8CWCazLhAIBAKBQCAQCAR5QwoVDGMRlLoPXu/TaGxca91ES8Axf9G65x4vhodvAfBXUGodAFNmXCAQCAQCgUAgEAjyDJaVhGV9iXT6FcRi/xP79n2hAOtGf3ZdD6G1c6cXg4PbAfx/UGqNkEGBQCAQCAQCgUAgyFMo5YFSS2GajyAQeBItLUvG4ykcK2R0FZT6V1BqOwCvzLBAIBAIBAKBQCAQ5DUp9EKppVDqSXi9T6C1tcYqLTVumhBau3atBvAvoNQ9mGDzeoFAIBAIBAKBQCAQTDk8AOpgmk/D43kQdXXV1pw51/UUmqOQwToo9S+g1LNQKiDzKRAIBAKBQCAQCAQFRwrnQqlKmGYfwuGOF7q6Rm1cn+EhtLZuLYdlPQvg6wBKZB4FAoFAIBAIBAKBoKCgrlUe9UGpRhjG1xEM3mWtX185JiG0tm8vh8fzLRjGc0IGBQKBQCAQCAQCgaDQqaEKQanNMM1nEArdYjU2ll2XEMIwnoVSfwqgTmZOIBAIBAKBQCAQCAqeECooFYBS22AYzyEcvsVauzbk/BWPddttXqTT9yKd/gaUqgOQvvZSORqWde27pY2FQCAQCAQCgUAgEIwfSQBAOh118KrxwATQDKAXxcVXrdbWj1RbWwQAPEgk1kCp2wAMwLLev3YRlcObSECpCgCl1waWzvH1BAKBQCAQCAQCgaBQoYlfGkA/LKsHSpkADKTTVwEkrn1+oyb0CkASSi0DcArAORJC4DMA35d5FggEAoFAIBAIBILCQsuRI9a+NWvCSKfDsKzrk0KlAMuyMDycQE/PoMycQCAQCAQCgUAgEMxy/P8KoY6dZpxf1gAAAABJRU5ErkJggg==")};
__resources__["/resources/Dashboard/dashBoardFPO.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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+g6ZkxPkqtpnclhZgOARgl+pRDybojvS5rjWunhwcND2h80GAIiyfD5vB7cIK0OxWOTIkck1V3w+n8c0zb54PL6rVlvP2prFs0EdHR32Wq3ipSTJivWORCJccsklDe8XGTBXrVqF2+0mlUoxNDRkZ5U0TWvJN7AceKdPn7a3fD6PJElixZ8p/orqXP6KopBOpzl48CBPP/20vbShoGpTlKIoU1JE1NtUVSUYDHLXXXfhcrl417veZSe30iWTpJ4joxenJPaSanzN1decNSkykt+F4tWQc0WMZI59+/bxtre9jSuuuIIvf/nLLF++nKGhoYpJX420K3Es9gMDA7S2thIMBunu7iYWi3HixFSzprDtz9Q5LDbhkFbQibryKLKf9nArilLZVqYjZ85brgxxx8bzODOa4UdPHOWRrSc52rePo337CEdbWbLyQtZfdOFkcykKfr8fwzCmrCsgUgFMN3lspvvx8XHS6bStIYt2yJcK7D1ZGSHknEA1ZYiUgUJ2aURa4LP/J8aN1+SQJJO//HSEHz1sSfeP/8bL1m1u7v9onP/9cWt+wJ6DkyYgSZL40UN+7rs3yb3vSvO/Pt68eagRqbKCVtbinVFm4m/esilLMKDzyFOTKaKrr7nx6ixLegu866+seifTEu//RIinfhQDTP72L9NIUoD/eswE00Ayq+YaiAijMhaZJoSDIfKxUTKFHMdHB+htq4zYM02TF198keuvv74pbWA6LcB5Pjo6aq+PYJrWama//OUvAUilUmJOw+3AD2q16evmI2hmA2yNACwHnNfrrejcYrFILBZjzZo1LF++fArTrMWkZVlG0zQ6OztZuXIl69evR9M0QqEQL730EoODgzz77LP4/X42btzIO97xDi688EK6uroIhUJWBsJgkEAggM/nw+/34/V6beYuNBGv18v4+DiJRIKhoSHbji80CzEdvFb4Zz0/gKZpLFy4kL/+67/m17/+NR/72MesyUYSjBfTjBfTFM3ms6VKNf6dE0kSkqYg+8oaW8mg/8QJfvrTn+L3+7n++uvJZrPkcrkp2kGjzTRNO2+QmPgUjUaJx+N2AkHDsLIwztQsVP2biEILaRnaPHlaw0HaW0LIstvaJA1ZtrQCscmSiiK7iQQCbLhwHu+9+XzmtPlJZoocOzlKcnyUNatW2n8rGAzaocL9/f0VocKjo6M18yid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")};
__resources__["/resources/finishline.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAABkCAYAAACoy2Z3AAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sKHxQ2IF+6ozUAAAAdaVRYdENvbW1lbnQAAAAAAENyZWF0ZWQgd2l0aCBHSU1QZC5lBwAAEClJREFUeNrtndlXVFcaxfelqrBAKECG4AAiMskgKqDBlgRE7RhdncmYaMzwkvf+T/KU/h/6qZ8ymUgkJjGSBCVIEOdoVAwKCVgyWJXTDwVZtstEhrpV9bt99lqspQ/iPt/97tn3nPOd/TlKLFZJ+pekDUpdVM39wRgjChzHwXC1cbVxhcf1fIpSvSnpn47j9CXqP/QneIC1kp6RlJfqSZOdnS0LCxImJiYweVtaWqpr164huPb29mrLli2P/chMMZRJapaUMAFJS/AAtxPEQ5La2towEwflRbRwF2NjYxiudXV1GK4fffQRhWq6pCZjTMIWBokUkBxJT1OexP79+zEJfvbsWQzXUChkZ3qXcOfOHQzXR77oUxoffvghKQ22Sir0ooCUSMJ8duzZsweTMd9//z2Ga15enizcwe3btzFcm5qaMFx7enpIaVAmqdqLAtIkqYjyFNavX28FxAUUFhbKwh0MDw9juNbX12O4RiIRTU5OUujmK3ZU4CkB8Sl2uBMkPIFVq1ahJg7SFtZTTz1lZ3qXcOvWLc5nclkZKrYnT54k0d1qjElINUWiBKRQ0jZK9Ds7O1HJffXqVQzXlStX2pneJdy8eRPDNRAIoGILOwdpkLTaSwJSLamcEn3SAbokRaNRDFfa6o4E0haWJBUXF2O4fvLJJ6jQStrsJQFpVWxvDoH29nZMpty4cQM1aVgBcQ+kQ3RJ2rBhA4YraZtYUqZi5byu39ZMhIBkKVZahkFREeasXwMDA/ar00KSNDIyguK7efNmFN+7d++S6LZKKvCCgKxRbE8OgdraWlRSnz592gqIBXGCQ90FkaTu7m4S3QpJlV4QkEZJmJNT0v0PiVXCK9kyXjcxPj6O4rtx40YU3w8++IBEt0AJuLjttoA4klokLadEfd++faik7u/vR/G1Fwndw8zMDIov6a6VJB07doxEN01SszEm0+0J3tUPTkn/kfQ3StTD4bAyMzMxWRIMBjU9PY3hG4lE5PP5MHxJrrESy5HXxtd1DEra7zjOZeoKpFIJ2IeLFwKBAEo8JKHEQxJKPIiYmppC8c3Pz0fxJd25UuwuiKvnz24LyNNKQCVAvLB1K6pYDFf3b+E+fv31VxTf6upqFN+uri4S3ZBcroB1U0AyFbMvSaNEe+/evahkHhwcRPG1PVbcB60Sq7GxEcUXdpAuSduNMSuIArJS0iZSpJ977jlUZtBKeO0Buvug3QWhlfJ+8cUXtJSolrSOKCANit0BscnsEnp7e1F8CwoKZOEuaLfRaSsQUs+VuddOLm5juSkgLZIwexa5ubm4ipAffvgBxdc68boPkiOvJFVWVuJiDCudDyhma7KMJCAJ9aSPB0gtbOdw6dIlFF97C90KyOM+3Gg4evQojXKTXOpS6JaAlCuBXbHigeeffx6XyPfv30fxtVbu7oNYmUdrcwzqkT6HtZJcca50S0BaBCrflaRdu3ahMuKXX37BTRRWQNwH7QxE4m1jffPNN7QQ5ylmrogQkOCsgKA6xlRUVKAyYmhoyAqIhSc+LGieWOFwGGcbI+lpY0wOQUCKJKHKmUpLS3Ev3ZkzZ3Cc7SG6+6DdA5F4tu6S1NPTQ6NcKynuE50bAlLnBlE30dHRgUtgWgmvZJ14E4GxsTEcZ1opryR9/PHHNMqufNi7ISDbJKFKK4gH6LQSXklasWKFLNzFvXv3cJxpdiYSshIrQzF3Xn88f2m8Lz7kSvq3JFRTjeHhYdz2Sk5ODq7/w/T0tNLT01GcaXeDJJ4jLzHOPp9PkUiEFuYeSS84jhO3Ur14r0DK5FK5mJsg7s3TxEMSTjyoePDgAY4zzQU7Go3ijCsVu15RFc9fGG8Bce3CiltoaGjAvWzEg1KLxGFiYgLHuby8HMf5q6++olHOV5zLeeMpIAHF3HeDpIju3r0bl7jnz5/HcbZOvInD6OgojjPxQw54odCR1GKMyUpFASlQ7P4HCjQHXknq6+vDcSZaVlABNPzTpk2bcJxhLW7n8IpijaZSTkBqFNvCQqG1tRWXATQbd8k68SYSxMuERAE5d+4cNUXi9jUXTwHBrT6CwaCysrJwT59YwltUVGRn9gSB6IdVU1ODjPXPP/9MpP12KgrIm7QotrS0IJOWeAZib6FbAfkrlJSUIGPd3d1NpH0gFQWknhZF4vmHxDwktT5YVkD+Co7jIMu8gQfpklRojIlLVUu8BKSDGMU9e/bgOANrz62AWAGZF8rKyuwKJHF4KZUE5G1iBIkmbhcuXEBmq20mlTgQD9Elqa6uDscZegYStzk7XgLyEi16+fn58vl8uKdOPECX7BlIIkEs45WYpoqSNDg4SKS9M1UEpFBSiBa9HTt2IJOVWMIrWSfeRILoyCsxS3klqaurC8nbGLPkJV88BORVYvCoB+jUFYh14k0ciD5pklRbW4vkDbR2n8MbS/0F8bDA/EYxC3cUhoaGVFVVhXvixcXFyLal4XAYZ5gnMd14Z78ucZxnZma0bNky5McR1J/uiuM4SzIhi8fbYewLZic0G+/Uwu+//47k7vf7FY1GkeIXCASIqbLMcZxF9+dd6hbWNmLE1q1bZ7cmLDwNoiOvxL1QSOwQOou9S/nHSxWQN4kRa25uRj7pW7du2ZnRYt4rEPtxlzh89tln1FRZUjnvktobnj59+oDE2p6IRqNqamrSu+++q1OnTsnv9yN4z8zMqL29XUNDQwqHw5h4O46j0dFRVVdXa/ny5bhtCeKXZVZWlt555x1dvXpVaWlpGN6Tk5M6cuSI3n//fU1NTWF4+3w+DQ4Oqqqqiuitl5x+3saYkAHD7/cbxc5vMD/vvfceMtb9/f24WM/9UNHZ2YmM98GDB5HxfvDgATbHFeskm/AtrBepa7bx8XFiP2Nt3LjRbr1ZzAtU6xjopTz5/X6FQiFquryWDAF5ixqtU6dOIXlXV1cjeRPLjumgWsdcvnwZG/Nt27ZRqR9OhoB0UqN19OhRJO/Vq1cjeVPN/cigWseQzvceBdGcdRaL3tpYlIAYYxrILxexYoLY+MoKiF2BLAY3btxA8t61axc5ZRblqL7YFcgb5EgR7UDKy8ux8bZbWIkHuQPk0NAQ8zMeekY5i0UdSSxWQF6jRml4eBhZI0+0urYCkjyQzSv7+/uRvNPS0sgrvxcSIiDGmKCWUPaVbJw4cQLJm+pUKkkjIyN2Rk8wyOaVZ86cwXJva2ujUs+TtOBl62JWIPvILxb1AJ28PIYazaGRm5uL5T4wMIDlDj5Il6SXEyEgb5EjdPz4cSTvmpoabMypbXjJIBddXLx4Ecu9vb2dnDZHFvoPFmzXaYyZkrSMGiGqu2okEkF2UJRie8NUN14qb3Ku27gnl75rKxBjTAVZPKj9xDMzM7HiQZ8MyCD2X5kDta+7JFVWVpLTpsU1AZH0Ojky3d3dSN5Uh1JJunfvnp3JkwSwtQb2Y0+Snn32WXLaLOhW+kIF5BA5MtQDdGqrT0n67bff7EyeJJArsc6ePYvlDj9IP+CKgBhjfJJqyZH58ssvkbwbGxuxMbcVWMlDQUEBlntfXx+W+44dO8hps0ZSthsrkN3kqESjUawrLLmE194BSR7IlwnJK5CVK1eizywl7XdDQN4kR4T8RbNhwwYsd/JhKB1UQ0WJfQZC3zXQAsp5FyIg+8kR6erqwnIvLS3Fcrc2JlZAFgO6AefOnTvJ9Oe92zQvATHGrJEUIkeE2rM4GAwqPT3dTgQW/1cCIkljY2NY7nBn3oCkeW17zHcFcoD+MlGbSK1duxYdd7sCsQKyWFy6dAnLHdxcag7zMsydr4AcJkciHA5j7TTIJbxWQJIL8iG6xPbEys3N1fLly62AzKKFHIlvv/0Wyx3eY8BWYSUR+fn5aP7kwhdJamlBT5s1im1lLU1AjDHP0F+kY8eOWQFJEuw9kOQhLy8PzZ9cyitJnZ2d9BR64o3I+axA3qBHgSwg5BJeyTrxJhNkKxOJ25nQQwLyxHLeJzovGmNuaxGNRlIJGRkZmpqaQnK/f/++MjIysLEPBAKKRCJY/nQjSLIzrM/nQ+fO1NQU+t2VNC4pZ9ErEGNMIV08RkZGsOKRnp5OT0D0BOAFkEvAo9GoJiYmsPyDwSC9kCEkqXTRAiLpRfoLdPLkSSx38gVCyTrxpgKys7PR/K9cuYLm39raSk+hV5YiIIfpo//000+x3MldCCXrxJsKILe2laQff/wRzX/37t30FDq0FAFpp4+e2gNE4ldgjY6O2hk8yaCX8vb396P5w3uDSE+4wvGnAmKMafHCC0QuBaQLyJ07d+wMnmTQLxPSBaS+vt4LafTMYlYgr9NHfeXKFXQVDb2E1zrxJh9FRegaGJ07dw7N33EcdEfRWRxejIC8Qh81tYHUHOiJZwXECshSce3aNfwzgDeYkqQXFiQgxpgcSWvpoyYfoPv9fnwFjXXiTT7ohorT09OanJxEj8EDB+nFkgoXsgLZ54WXh7wCKSkpwcffGinaFUg88NNPP9kVSPLxj4UICL581xiDriGvrq7GZ5zdwrICEg/Qz0HWrVuHdgSYxaGFCAh+zUU3YmtoaMC/+NaJN/koKCjAj4FeiSV5ohqrfV4CYoypl5ROH+3x48etgCQZ1ok3+aA78npFQNrb2+lD8EnaMp8VyEEvvDhkB16J30hKsk68qQD6TXSJv4UlecKZV3pMkynnMSuQQcWaiaBRXFyMPsQdHR3Ffz0Gg0FNT0+jx0B3441EIgoEAugxZGdna3x8HD2G27dvq7i4mD6tXpJU8acCYozJkHSfPsrJyUllZmZy14pwG+s/kot/cIgXEClWEh6NRtFjmJ6eRjsLS1JmZia+JFlStqQ/XFIf3cLaIw+gt7cXzX/16tX4ZxAOh2WRGsjKysKP4fr16/gxbNmyxQvptPfhvzwqIIe9MMLPP/8czb+qqgr/DKwTb+ogJycHP4bz58/jx9DR0eGFdDr0VwKy1wpI8uEFA7axsTE7c6cIvFCJRS/L95CA/P2xAmKMWa/Y/hYe3333HZq/F0p4rRNv6sDeBUkNNDc3eyGdMiVVP24FcsALo7t79y6+YqOurg7/HOwlwtQB3dJdkgYHB/FjCIVC+P4sj2rFwwLiifsfPT09+DGUl5fjx2BtTFIHXrAzuXz5sieexdatW70wjFf/R0CMMX495pYhEV1dXWj+juN44ovRGilaAYknRkdH8aXIkrRz504vpFSjpMDDK5AOr7ws5Ba2kjdKeK2AWAFxAzdv3sSPwQMtbufQ+bCAHPLKqPr6+tD8KyoqPPEc7BaWFZB448KFC/xP98ZGr6TV6w8LyH4vjOj69euamZlBj8ELB+iSrcJKJXihCkuSBgYG8GNIT0/3RK8fzfaMSjPGrNGfdJui4euvv8aPwQslvJJ14k0leKTyxxOlvJK0fft2T3yXSCpJk/SyV14U+gG6l1Yg9iJh6sALjrySN0p5Jc8cpEvSy37FDtBHJc3QR3PixAn8E1m/fr0nMot+F8dLCIVCnhjHxYsXPTGOtrY2LwwjXVLHfwG9eUqa8y41wgAAAABJRU5ErkJggg==")};
__resources__["/resources/retry-selected.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/retry.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/Retry_Down.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/Retry_Up.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/start-button.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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h97eXmiahocffhiGYeDnP/85rrnmGgwMDOCZZ56BbdtMUXjllVfi+OOPZ8zwM5/5DK6//nrYtg1VVdHe3g5N05BMJtHe3o5NmzbB8zycccYZ6O7uxhlnnIHJyUm88soreOqppzB37lyccMIJWLBgAf7nf/4HK1asYOnIm266CTfeeCPmzp2Lzs7O3amZqbroM888g2w2i1NPPRXd3d341Kc+hbPOOgtPPPEE5s6di5UrV6K3txfnnnsutm7ditHRUdi2jWw2izPPPBNdXV1YunQpVFXFqaeeivb2dhx33HGwLIsBYXD2KADccMMNuP7669nGg1LbQZENfRa6rtfVnoO1zXQ6XSc40jStTpCydu1arF69Gtdeey2uuuoq3H///XjggQdw1FFH4cMf/jAefPBB/Nu//RtuvvlmnH766dA0ra7F5plnnsGOHTtw+umnszproVCAaZo48cQTcfLJJ0OWZTzyyCO49957oes6rr76anieh9WrV+NrX/saTjzxRCiKgkQiUZctCet3jCNOjcZxEABhsC6UTCaxYsUKPPDAAygUCli9ejUefPBBPPjgg+ju7kZvby8cx8ERRxyBBx54ADt27MCnPvUpPPTQQ7jrrruwaNEitLW1wXVdHHnkkXj44YexdetWfOYzn8EjjzyC22+/HUcffTSrvRC7uOqqq3DyySdj/fr1WLt2Le666y7853/+JyRJgq7rdc3RkiQxgPA8D6ZpQlGUut46SocR83Uchy22JJ+fP38+LrjgAra4K4oCVVVZirG7uxuCIODYY4/Fl7/8ZTz33HN49tln8ac//Qlbt27Fhz70oT2UpAQogiAwkZBpmvA8j9X9qJ6m6zqrc65btw6f/OQn8Y1vfAMvvPAClixZskf7hqIo0HWdqWp1XWeCHL7GSDVDqmeS2pTeO2Jy9Nnz6XFa6ElIUy6XUa1WGQPkRU9UM6bH4ad/+77P0tr8+8632lDNU1VVpFIppjBdsmQJSx/PmTOHiWDOOeccxsZlWcYvfvELdHZ2IpVKsc/8oYcewty5c9HX18dStzfddBNeeuklXHPNNUilUsjn8/jBD36A3/3udzj99NNx1FFH4Wtf+xrK5TJkWcbzzz8P0zQxf/589p7yfbFxxIwwjoMYFAFA0zScdtppeOKJJ+B5Hg4//HAcf/zxuP766/G3f/u3EEURqqribW97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")};
__resources__["/resources/tree_1.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/volume-control-off.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/volume-control.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/XML.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
Copyright 2011, Carnegie Learning

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

// Static class, so nothing much here
var XML = BObject.extend({
    init: function() {
        XML.superclass.init.call(this);
    }
});

// Simple, general XML parser
XML.parser = function(root, ret) {
	var r = {}

    r.name = root.tagName;
    
	// Process attributes
    r.attributes = {}
	for (var i = 0; i < root.attributes.length; i++) {
		var n = root.attributes[i].nodeName;
        
        r.attributes[n] = root.attributes[i].nodeValue;
	}
	
    r.children = [];
    
    // Process children
	for (var i = root.firstElementChild; i != null; i = i.nextElementSibling) {
		r.children.push(XML.parser(i));
	}
	
    // Process tagged value (ex: <TAG>This info here<INNER></INNER>but not here</TAG>
    r.value = null;
    if(root.childNodes) {
        if(root.childNodes.length > 0) {
            r.value = root.childNodes[0].nodeValue;
        }
    }
	
	return r;
}

// Gets the first child of the current node with the specified name
XML.getChildByName = function(root, name) {
    for(var i = 0; i < root.children.length; i++) {
        if(root.children[i].name == name) {
            return root.children[i];
        }
    }
    
    return null;
}

// As getChildByName, but at any depth from the current node
XML.getDeepChildByName = function(root, name) {
    for(var i = 0; i < root.children.length; i++) {
        if(root.children[i].name == name) {
            return root.children[i];
        }
        else {
            var ret = XML.getDeepChildByName(root.children[i], name);
            if(ret != null) {
                return ret;
            }
        }
    }
    
    return null;
}

// Gets an array of all children with the specified name
XML.getChildrenByName = function(root, name) {
    var ret = []
    
    for(var i = 0; i < root.children.length; i++) {
        if(root.children[i].name == name) {
            ret.push(root.children[i]);
        }
    }
    
    return ret;
}

exports.XML = XML
}};/*globals module exports resource require window Module __main_module_name__ __resources__*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

function resource(path) {
    // Check for packed resource
    var r = __resources__[path];
    if (r) {
        return r.data;
    }

    // Check for remote resource
    r = __remote_resources__[path];
    if (r) {
        // Load remote image
        if (r.meta.mimetype.split('/')[0] == 'image') {
            return require('cocos2d').RemoteImage.create({url: r.data, path: path});
        } else {
            return require('cocos2d').RemoteResource.create({url: r.data, path: path});
        }
    }

    throw("Unable to find resource: " + path.toString());
}

(function () {
    var process = {};
    var modulePaths = ['/__builtin__', '/__builtin__/libs', '/libs', '/'];

    var path; // Will be loaded further down

    function resolveModulePath(request, parent) {
        // If not a relative path then search the modulePaths for it
        var start = request.substring(0, 2);
        if (start !== "./" && start !== "..") {
            return modulePaths;
        }

        var parentIsIndex = path.basename(parent.filename).match(/^index\.js$/),
            parentPath    = parentIsIndex ? parent.id : path.dirname(parent.id);

        // Relative path so searching inside parent's directory
        return [path.dirname(parent.filename)];
    }

    function findModulePath(id, dirs) {
        if (id.charAt(0) === '/') {
            dirs = [''];
        }
        for (var i = 0; i < dirs.length; i++) {
            var dir = dirs[i];
            var p = path.join(dir, id);

            // Check for index first
            if (path.exists(path.join(p, 'index.js'))) {
                return path.join(p, 'index.js');
            } else if (path.exists(p + '.js')) {
                return p + '.js';
            }
        }

        return false;
    }

    function loadModule(request, parent) {
        parent = parent || process.mainModule;

        var paths    = resolveModulePath(request, parent),
            filename = findModulePath(request, paths);

        if (filename === false) {
            throw "Unable to find module: " + request;
        }


        if (parent) {
            var cachedModule = parent.moduleCache[filename];
            if (cachedModule) {
                return cachedModule;
            }
        }

        //console.log('Loading module: ', filename);

        var module = new Module(filename, parent);

        // Assign main module to process
        if (request == __main_module_name__ && !process.mainModule) {
            process.mainModule = module;
        }

        // Run all the code in the module
        module._initialize(filename);

        return module;
    }

    function Module(id, parent) {
        this.id = id;
        this.parent = parent;
        this.children = [];
        this.exports = {};

        if (parent) {
            this.moduleCache = parent.moduleCache;
            parent.children.push(this);
        } else {
            this.moduleCache = {};
        }
        this.moduleCache[this.id] = this;

        this.filename = null;
        this.dirname = null;
    }

    Module.prototype._initialize = function (filename) {
        var module = this;
        function require(request) {
            return loadModule(request, module).exports;
        }

        this.filename = filename;

        // Work around incase this IS the path module
        if (path) {
            this.dirname = path.dirname(filename);
        } else {
            this.dirname = '';
        }

        require.paths = modulePaths;
        require.main = process.mainModule;

        __resources__[this.filename].data.apply(this.exports, [this.exports, require, this, this.filename, this.dirname]);

        return this;
    };

    // Manually load the path module because we need it to load other modules
    path = (new Module('path'))._initialize('/__builtin__/path.js').exports;

    var util = loadModule('util').exports;
    util.ready(function () {
        // Populate globals
        var globals = loadModule('global').exports;
        for (var x in globals) {
            if (globals.hasOwnProperty(x)) {
                window[x] = globals[x];
            }
        }

        // Add a global require. Useful in the debug console.
        window.require = function require(request, parent) {
            return loadModule(request, parent).exports;
        };
        window.require.paths = modulePaths;

        process.mainModule = loadModule(__main_module_name__);

        window.require.main = process.mainModule;

        if (process.mainModule.exports.main) {
            process.mainModule.exports.main();
        }

    });
})();

// vim:ft=javascript

})();
